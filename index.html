<!DOCTYPE html>
<html lang="hu">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>360 selfie - KANDO BOOTH</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <style>
        /* --- DESIGN --- */
        body {
            margin: 0;
            padding: 0;
            background: #0f0f0f;
            color: #eee;
            font-family: 'Segoe UI', sans-serif;
            height: 100dvh;
            display: flex;
            overflow: hidden; /* keep horizontal/overall lock */
            padding-bottom: env(safe-area-inset-bottom);
            overscroll-behavior: none;
        }

        .container {
            display: flex;
            width: 100%;
            height: 100dvh;
            min-height: 0;
        }

        .panel {
            padding: 20px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            gap: 12px;
            overflow-y: auto;
            min-height: 0; /* critical for flex children to be scrollable on mobile */
            -webkit-overflow-scrolling: touch;
        }

        .left-panel {
            width: 28%;
            background: #181818;
            border-right: 1px solid #333;
            z-index: 2;
            box-shadow: 5px 0 15px rgba(0, 0, 0, 0.5);
            padding-bottom: calc(20px + env(safe-area-inset-bottom));
        }

        .center-panel {
            width: 44%;
            background: #000;
            align-items: center;
            justify-content: center;
            position: relative;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            padding-bottom: 20px;
        }

        .right-panel {
            width: 28%;
            background: #181818;
            border-left: 1px solid #333;
        }

        .app-header {
            font-size: 24px;
            font-weight: 800;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 20px;
            text-align: center;
            background: linear-gradient(90deg, #fff, #03dac6);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        h3 {
            margin: 0 0 5px 0;
            color: #03dac6;
            border-bottom: 1px solid #333;
            padding-bottom: 5px;
            text-transform: uppercase;
            font-size: 12px;
            letter-spacing: 1px;
        }

        label {
            font-size: 11px;
            color: #888;
            text-transform: uppercase;
            margin-top: 8px;
            display: block;
            font-weight: bold;
        }

        input,
        select,
        button {
            width: 100%;
            padding: 10px;
            background: #252525;
            border: 1px solid #333;
            color: #fff;
            border-radius: 4px;
            box-sizing: border-box;
            margin-bottom: 4px;
            font-size: 13px;
        }

        /* Range (slider) inputs must not inherit padding from the generic input rule */
        input[type="range"] {
            padding: 0 !important;
            height: 18px;
            border-radius: 999px;
            background: transparent;
            border: none;
            box-sizing: border-box;
        }

        /* M√ìDV√ÅLT√ì */
        .mode-switch {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
            background: #222;
            padding: 5px;
            border-radius: 5px;
        }

        .mode-btn {
            flex: 1;
            border: none;
            background: transparent;
            color: #666;
            cursor: pointer;
            padding: 8px;
            font-weight: bold;
        }

        .mode-btn.active {
            background: #03dac6;
            color: #000;
            border-radius: 4px;
        }

        /* DROP ZONE */
        #dropZone {
            border: 2px dashed #444;
            background: #1a1a1a;
            color: #aaa;
            height: 150px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            cursor: pointer;
            transition: 0.2s;
            margin-top: 10px;
        }

        #dropZone:hover {
            border-color: #03dac6;
            background: #222;
            color: #fff;
        }

        #dropZone.dragover {
            border-color: #03dac6;
            background: #2a2a2a;
        }

        /* VIDE√ì */
        #videoContainer {
            position: relative;
            width: 100%;
            height: auto;
            aspect-ratio: 16 / 9;
            /* alap: fekv≈ë kont√©ner */
            max-height: 70vh;
            background: #000;
            border: none;
            box-shadow: inset 0 0 0 2px #333;
            overflow: hidden;
            border-radius: 8px;
            will-change: transform;
            margin: 0 auto;
        }

        #videoContainer video,
        #videoContainer canvas,
        #videoContainer img {
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: #000;
        }

        /* Overlay PNG alpha must show through to the canvas/video under it (do not paint black behind transparent pixels) */
        #overlayImg {
            background: transparent !important;
        }

        #videoContainer canvas,
        #videoContainer img {
            object-fit: cover;
        }

        #videoContainer video {
            object-fit: cover;
        }

        #statusBadge {
            position: absolute;
            top: 15px;
            right: 15px;
            padding: 6px 12px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 20px;
            font-size: 11px;
            color: #03dac6;
            z-index: 5;
            border: 1px solid #333;
            text-transform: uppercase;
            font-weight: bold;
        }

        #progressBarContainer {
            width: 100%;
            height: 4px;
            background: #222;
            margin-top: 15px;
            border-radius: 2px;
            display: none;
            overflow: hidden;
        }

        #progressBar {
            width: 0%;
            height: 100%;
            background: #03dac6;
            transition: width 0.2s;
        }

        .btn-start {
            background: linear-gradient(135deg, #03dac6, #00695c);
            color: #fff;
            height: 60px;
            font-size: 18px;
            border: none;
            margin-top: 15px;
            font-weight: bold;
            cursor: pointer;
            border-radius: 8px;
        }

        .btn-projector {
            background: #6200ee;
            color: #fff;
            border: none;
            cursor: pointer;
        }

        .scroll-area {
            max-height: 150px;
            overflow-y: auto;
            border: 1px solid #333;
            background: #121212;
            padding: 5px;
        }

        .effect-item {
            font-size: 12px;
            padding: 6px 8px;
            border-bottom: 1px solid #222;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
        }

        /* EFFEKTEK ‚Äì stabil (Safari-kompatibilis) layout: nincs display:contents */
        .eff-compact {
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: 100%;
        }

        .eff-toprow {
            display: grid;
            grid-template-columns: clamp(72px, 10vw, 92px) minmax(0, 1fr) clamp(56px, 10vw, 84px);
            grid-template-areas:
                "tlabel tslider tval"
                "slabel sslider sval";
            column-gap: 12px;
            row-gap: 10px;
            align-items: center;
            width: 100%;
            max-width: 100%;
            overflow: hidden;
        }

        .eff-label {
            font-size: 11px;
            color: #888;
            text-transform: uppercase;
            font-weight: bold;
            margin: 0;
            white-space: nowrap;
            letter-spacing: 0.8px;
            line-height: 1;
        }

        .eff-value {
            font-size: 12px;
            color: #03dac6;
            font-weight: 800;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            line-height: 1;
            font-size: clamp(11px, 1.1vw, 12px);
            justify-self: end;
            text-align: right;
            min-width: 0;
        }

        .eff-slider {
            width: 100%; max-width: 100%;
            margin: 0;
            padding: 0;
            height: 18px;
            min-width: 0;
            max-width: 100%;
            box-sizing: border-box;
        }

        .eff-divider {
            width: 1px;
            height: 18px;
            background: #2a2a2a;
            justify-self: center;
            border-radius: 1px;
            display: none; /* alapb√≥l rejtve: iPad-en ne jelenjen meg √°rva cs√≠k */
        }

        /* grid-area k√∂t√©s a k√©t soros eff-toprow-hoz */
        .eff-time-label  { grid-area: tlabel; }
        .eff-time-slider { grid-area: tslider; }
        .eff-time-value  { grid-area: tval; }
        .eff-speed-label { grid-area: slabel; }
        .eff-speed-slider{ grid-area: sslider; }
        .eff-speed-value { grid-area: sval; }

        .eff-bottomrow {
            display: flex;
            justify-content: space-between;
            gap: 10px;
            flex-wrap: wrap;
            width: 100%;
        }

        .eff-preset {
            display: flex;
            gap: 6px;
            align-items: center;
            flex-wrap: wrap;
        }

        .eff-preset button {
            width: auto;
            padding: 6px 8px;
            background: #252525;
            border: 1px solid #333;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 800;
            color: #eee;
            font-size: 12px;
            line-height: 1;
        }

        .eff-preset button.active {
            background: #03dac6;
            color: #000;
            border: none;
        }

        .eff-actions {
            display: flex;
            gap: 6px;
            align-items: center;
            flex-wrap: wrap;
        }

        .eff-actions button {
            width: auto;
            padding: 8px 10px;
            font-size: 12px;
            margin: 0;
            white-space: nowrap;
        }

        /* Sz≈±kebb n√©zet: a k√©t sor marad, csak a fels≈ë grid t√∂rik */
        @media (max-width: 1100px) {
            .eff-toprow {
                column-gap: 10px;
                row-gap: 10px;
            }
        }

        /* Telefon / keskeny panel: minden egym√°s al√°, c√≠mke + √©rt√©k egy sorban */
        @media (max-width: 700px) {
            .eff-toprow {
                grid-template-columns: 1fr;
                grid-template-areas:
                    "tlabel"
                    "tslider"
                    "tval"
                    "slabel"
                    "sslider"
                    "sval";
            }

            .eff-divider {
                display: none;
            }
        }
        @media (min-width: 1400px) {
            .eff-toprow {
                grid-template-columns:
                    clamp(72px, 8vw, 92px) minmax(0, 1fr) clamp(56px, 8vw, 84px)
                    12px
                    clamp(72px, 8vw, 92px) minmax(0, 1fr) clamp(56px, 8vw, 84px);
                grid-template-areas: "tlabel tslider tval divider slabel sslider sval";
            }
            .eff-divider {
                display: block;
                grid-area: divider;
            }
        }

        /* Extra sz≈±k: kisebb gap √©s bet≈± */
        @media (max-width: 420px) {
            .eff-compact {
                gap: 8px;
            }
            .eff-toprow {
                row-gap: 8px;
            }
            .eff-label {
                font-size: 10px;
            }
        }

        /* Mobil / tablet (iPad/iPhone): panelek egym√°s alatt PORTRAIT-ban */
        @media (max-width: 1024px) and (orientation: portrait) {
            body {
                overflow: auto;
            }

            .container {
                flex-direction: column;
                height: 100dvh;
                min-height: 0;
            }

            .left-panel,
            .center-panel,
            .right-panel {
                width: 100%;
            }

            /* Vide√≥ el≈ën√©zet fel√ºl, majd Branding/M√©dia, majd Effektek */
            .center-panel { order: 0; }
            .left-panel   { order: 1; }
            .right-panel  { order: 2; }

            /* iOS/Safari flex+scroll stabiliz√°l√°s */
            .panel {
                min-height: 0;
            }

            /* Effektek: iPad portraitban ne l√≥gjon ki semmi, √©s legyen mindig l√°that√≥ a timeline */
            .eff-divider { display: none !important; }

            .eff-bottomrow {
                flex-wrap: nowrap;
                align-items: center;
                justify-content: space-between;
                gap: 8px;
            }
            .eff-preset,
            .eff-actions {
                flex-wrap: nowrap;
                gap: 6px;
            }
            .eff-actions button,
            .eff-preset button {
                padding: 7px 9px;
                font-size: 12px;
            }

            #effectsTimeline {
                min-height: 34px;
                height: 34px;
                flex: 0 0 auto;
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }

            #effectsList.scroll-area {
                max-height: 32dvh;
                min-height: 140px;
                overflow-y: auto;
            }
        }

        /* iPad / tablet LANDSCAPE: marad a 3 oszlop, csak kompaktabb paddings + biztos scroll */
        @media (max-width: 1366px) and (orientation: landscape) {
            body {
                overflow: hidden;
            }

            .left-panel,
            .right-panel {
                width: 32%;
            }

            .center-panel {
                width: 36%;
            }

            .panel {
                padding: 14px;
                gap: 10px;
            }

            .app-header {
                font-size: 20px;
                margin-bottom: 14px;
            }

            .btn-start {
                height: 54px;
                font-size: 17px;
            }

            /* Effektek: a f√ºgg≈ëleges elv√°laszt√≥ ne jelenjen meg ezen a m√©reten (cs√≠k bug) */
            .eff-divider { display: none !important; }

            /* iPad-on a hossz√∫ list√°k legyenek g√∂rgethet≈ëk a panelen bel√ºl */
            #effectsTimeline {
                min-height: 34px;
                height: 34px;
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }

            #effectsList.scroll-area {
                max-height: 28vh;
                min-height: 140px;
                overflow-y: auto;
            }

            /* Gombok egy sorban maradjanak */
            .eff-bottomrow {
                flex-wrap: nowrap;
                align-items: center;
                justify-content: space-between;
                gap: 8px;
            }
            .eff-preset,
            .eff-actions {
                flex-wrap: nowrap;
                gap: 6px;
            }
        }

        /* Kisebb mobilon m√©g kompaktabb */
        @media (max-width: 700px) {
            #effectsList.scroll-area {
                max-height: 28dvh;
            }
        }

        #btnApplySelected {
            display: none !important;
        }

        /* Effektek id≈ëvonal (timeline) ‚Äì gyors √°tl√°t√°s */
        #effectsTimeline {
            height: 34px;
            display: flex;
            width: 100%;
            min-width: 0;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
            border: 1px solid #333;
            border-radius: 8px;
            overflow: hidden;
            background: #121212;
            margin-top: 10px;
        }

        .eff-seg {
            display: flex;
            flex: 0 0 auto;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            letter-spacing: 0.3px;
            cursor: pointer;
            user-select: none;
            border-right: 1px solid #222;
            color: #ddd;
            padding: 0 6px;
            min-width: 18px;
        }

        .eff-seg:last-child {
            border-right: none;
        }

        .eff-seg.slow {
            background: rgba(3, 218, 198, 0.18);
        }

        .eff-seg.norm {
            background: rgba(255, 255, 255, 0.06);
        }

        .eff-seg.fast {
            background: rgba(98, 0, 238, 0.22);
        }

        .eff-seg.selected {
            outline: 2px solid #03dac6;
            outline-offset: -2px;
        }

        /* Kijel√∂lhet≈ë lista sor */
        .effect-item.selectable {
            cursor: pointer;
        }

        .effect-item.selectable.selected {
            background: rgba(3, 218, 198, 0.10);
        }

        .eff-del {
            width: auto;
            padding: 6px 8px;
            background: transparent;
            border: 1px solid #333;
            color: #aaa;
            border-radius: 6px;
            cursor: pointer;
            font-size: 11px;
        }

        #effectsSummary {
            font-size: 11px;
            color: #888;
            margin-top: 6px;
            line-height: 1.25;
        }

        /* LAST OUTPUT (k√©sz vide√≥) ‚Äì ne nyomja √∂ssze a preview-t, ne legyen √≥ri√°si portraitban */
        #lastOutput {
            width: 100%;
            max-width: 100%;
            margin-left: auto;
            margin-right: auto;
            align-self: center;
            /* NE stretch: ne h√∫zza sz√©t a dobozt */
        }

        /* A be√©p√≠tett vide√≥-el≈ën√©zet sok b√∂ng√©sz≈ëben (k√ºl√∂n√∂sen portraitn√°l) sz√©tveri a layoutot.
           A vide√≥ √≠gy is automatikusan let√∂lt≈ëdik, √©s a ‚ÄûMegnyit√°s √∫j lapon / Let√∂lt√©s‚Äù gombok megmaradnak. */
        #lastOutputVideo {
            display: none;
        }

        #lastOutput video {
            max-height: 34vh;
        }

        /* Portrait m√≥dban a player nagyon magas lenne (9:16) ‚Äì korl√°tozzuk */
        body[data-aspect="portrait"] #lastOutput video {
            max-height: 28vh;
        }

        /* Ha sz≈±k a viewport, m√©g agressz√≠vebb limit */
        @media (max-height: 800px) {
            #lastOutput video {
                max-height: 28vh;
            }

            body[data-aspect="portrait"] #lastOutput video {
                max-height: 24vh;
            }
        }
    </style>
</head>

<body>

    <div class="container">
        <!-- BAL PANEL -->
        <div class="panel left-panel">
            <h3>1. Branding & Kijelz≈ë</h3>
            <label>Esem√©ny Neve</label>
            <input type="text" id="brandTitleInput" placeholder="Pl: Moln√°r Esk√ºv≈ë" oninput="updateBranding()">
            <label>Log√≥ (PNG)</label>
            <input type="file" id="logoInput" accept="image/png" onchange="updateLogo()">
            <button class="btn-projector" onclick="openProjectorWindow()">üñ•Ô∏è Kivet√≠t≈ë Nyit√°sa</button>

            <hr style="border-color:#333; width:100%; margin:10px 0;">

            <h3>2. M√©dia elemek</h3>
            <label>Overlay Keret</label>
            <input type="file" id="overlayFile" accept="image/png" onchange="loadOverlay(this)">
            <label>Zene (.mp3)</label>
            <input type="file" id="musicFile" accept="audio/*,.mp3,.m4a,.aac,.wav,.ogg">
        </div>

        <!-- K√ñZ√âP PANEL -->
        <div class="panel center-panel">
            <div class="app-header">360 selfie - KANDO BOOTH</div>

            <div id="videoContainer">
                <!-- √âl≈ëk√©p (csak webkamera m√≥dban) -->
                <video id="liveVideo" autoplay muted playsinline></video>
                <!-- Lej√°tsz√°s (F√°jl m√≥dban √©s renderel√©skor) -->
                <video id="rawPlayback" style="display:none;" muted playsinline></video>
                <canvas id="renderCanvas" width="1280" height="720" style="display:none;"></canvas>
                <img id="overlayImg" style="display:none;">
                <div id="statusBadge">K√âSZENL√âT</div>

            </div>

            <div id="lastOutput" style="display:none; margin-top:12px; align-self:center;">
                <div
                    style="background:rgba(0,0,0,0.75); border:1px solid #333; border-radius:10px; padding:10px; display:flex; flex-direction:column; gap:10px; align-items:stretch;">
                    <video id="lastOutputVideo" controls playsinline muted
                        style="width:100%; height:auto; aspect-ratio:16/9; object-fit:cover; border-radius:8px; border:1px solid #333;"></video>
                    <div style="flex:1; min-width:0;">
                        <div
                            style="font-size:12px; color:#03dac6; font-weight:800; letter-spacing:1px; text-transform:uppercase;">
                            Utols√≥ vide√≥</div>
                        <div id="lastOutputInfo" style="font-size:11px; color:#aaa; margin-top:4px;">Megtekinthet≈ë
                            itt is, ha a rendszer nem nyitja meg.</div>
                        <div style="display:flex; gap:8px; margin-top:8px; flex-wrap:wrap;">
                            <button id="btnOpenLast"
                                style="width:auto; padding:8px 10px; background:#252525; border:1px solid #333; border-radius:6px; cursor:pointer;">Megnyit√°s
                                √∫j lapon</button>
                            <button id="btnDownloadLast"
                                style="width:auto; padding:8px 10px; background:#03dac6; color:#000; border:none; border-radius:6px; cursor:pointer; font-weight:800;">Let√∂lt√©s</button>
                            <button id="btnHideLast"
                                style="width:auto; padding:8px 10px; background:transparent; border:1px solid #333; color:#aaa; border-radius:6px; cursor:pointer;">Elrejt</button>
                        </div>
                        <div style="font-size:10px; color:#666; margin-top:6px;">MP4-hez szerveres konvert (FFmpeg)
                            aj√°nlott; b√∂ng√©sz≈ëben nem garant√°lt a k√∂zvetlen MP4 r√∂gz√≠t√©s.</div>
                    </div>
                </div>
            </div>

            <div id="progressBarContainer">
                <div id="progressBar"></div>
            </div>
            <p id="processText" style="color:#aaa; font-size:11px; margin-top:5px; text-align:center; height:15px;"></p>
        </div>

        <!-- JOBB PANEL -->
        <div class="panel right-panel">
            <h3>3. M≈±k√∂d√©si M√≥d</h3>
            <div class="mode-switch">
                <button class="mode-btn active" id="btnModeCam" onclick="setMode('cam')">Kamera ind√≠t√°s</button>
                <button class="mode-btn" id="btnModeFile" onclick="setMode('file')">F√°jl Import</button>
            </div>

            <div id="camControls">
                <label>Kamera Forr√°s</label>
                <select id="camSelect" onchange="startCamera()">
                    <option>Bet√∂lt√©s...</option>
                </select>
                <label>Felv√©tel hossza (mp)</label>
                <input type="number" id="recDuration" value="4" min="2" max="10">

                <label>Kimenet k√©par√°ny</label>
                <select id="outputAspect" onchange="applyOutputAspectFromUI()">
                    <option value="landscape" selected>Fekv≈ë 16:9</option>
                    <option value="portrait">√Åll√≥ 9:16</option>
                </select>

                <label>Overlay illeszt√©s</label>
                <select id="overlayFit" onchange="applyOverlayFitFromUI()">
                    <option value="stretch" selected>Sz√©lekhez h√∫z (stretch)</option>
                    <option value="cover">Kit√∂lt (crop) (cover)</option>
                    <option value="contain">Teljes k√©p (contain)</option>
                </select>

                <label>Forr√°s forgat√°s</label>
                <select id="sourceRotate" onchange="applySourceRotateFromUI()">
                    <option value="0" selected>0¬∞ (nincs)</option>
                    <option value="90">90¬∞ (√°ll√≥ ‚Äì balra)</option>
                    <option value="270">270¬∞ (√°ll√≥ ‚Äì jobbra)</option>
                </select>

                <button id="startBtn" class="btn-start" onclick="initiateCamSequence()">FELV√âTEL START</button>
            </div>

            <div id="fileControls" style="display:none;">
                <p style="font-size:12px; color:#aaa;">H√∫zd ide a GoPro vide√≥t, vagy kattints a dobozra a tall√≥z√°shoz.
                </p>

                <div id="dropZone" onclick="document.getElementById('videoInput').click()">
                    <span style="font-size:24px;">üìÇ</span>
                    <br>Kattints vagy H√∫zd ide<br>a vide√≥t
                </div>
                <input type="file" id="videoInput" accept="video/*" style="display:none;"
                    onchange="handleFileSelect(this)">

                <button id="processFileBtn" class="btn-start" style="background:#3700b3;" disabled>FELDOLGOZ√ÅS
                    START</button>
            </div>

            <hr style="border-color:#333; width:100%; margin:15px 0;">

            <h3>4. Effektek</h3>

            <div class="eff-compact">
                <div class="eff-toprow">
                    <div class="eff-label eff-time-label">Szakasz</div>
                    <input class="eff-slider eff-time-slider" type="range" id="effTimeSlider" min="0.5" max="10" step="0.5" value="2">
                    <div class="eff-value eff-time-value" id="effTimeVal">2.0 s</div>

                    <div class="eff-divider" aria-hidden="true"></div>

                    <div class="eff-label eff-speed-label">Seb.</div>
                    <input class="eff-slider eff-speed-slider" type="range" id="effSpeedSlider" min="0.25" max="3" step="0.05"
                        value="0.5">
                    <div class="eff-value eff-speed-value" id="effSpeedVal">0.5√ó</div>
                </div>

                <div class="eff-bottomrow">
                    <div class="eff-preset" aria-label="Sebess√©g preset">
                        <button type="button" id="btnSpeed05" onclick="setSpeedPreset(0.5)">0.5√ó</button>
                        <button type="button" id="btnSpeed10" onclick="setSpeedPreset(1.0)">1√ó</button>
                        <button type="button" id="btnSpeed20" onclick="setSpeedPreset(2.0)">2√ó</button>
                    </div>

                    <div class="eff-actions">
                        <button type="button" onclick="addEffect()" style="background:#333;">+ Szakasz</button>
                        <button type="button" onclick="clearEffects()"
                            style="background:transparent; border:1px solid #333; color:#aaa;">T√∂rl√©s</button>
                    </div>
                </div>
            </div>

            <div id="effectsTimeline"
                title="Kattints egy szegmensre: kijel√∂l√©s. A 'Friss√≠t' gomb a kijel√∂lt szakaszt √°t√≠rja a cs√∫szk√°k alapj√°n.">
            </div>
            <div class="scroll-area" id="effectsList" style="margin-top:8px; max-height:180px;"></div>
            <div id="effectsSummary"></div>

            <label style="margin-top:10px; display:flex; align-items:center;">
                <input type="checkbox" id="boomerangMode" style="width:auto; margin-right:8px;"> Boomerang
            </label>
        </div>
    </div>

    <script>
        // --- V√ÅLTOZ√ìK ---
        let currentMode = 'cam'; // 'cam' vagy 'file'
        let projectorWin = null;
        let stream = null;
        let mediaRecorder = null;
        let chunks = [];
        let effects = [];
        let selectedEffectIndex = -1;
        let isProcessing = false;
        let rawVideoBlob = null;
        let currentLogoData = null;

        // Overlay bet√∂lt√©s √°llapot (stabil rajzol√°s + debug)
        let overlayReady = false;

        // Overlay PNG √°tl√°tsz√≥ perem lev√°g√°s (alpha bbox) ‚Äì hogy a keret t√©nyleg kifusson a sz√©lekig
        // { sx, sy, sw, sh } forr√°s-kiv√°g√°s a PNG-b≈ël
        let overlayCrop = null;

        // Prevent infinite onload recursion when we crop the overlay image for preview
        let overlayCroppedOnce = false;

        // Kimenet k√©par√°ny / overlay illeszt√©s
        let outputAspectMode = 'landscape'; // 'landscape' | 'portrait'
        let overlayFitMode = 'stretch'; // 'stretch' | 'cover' | 'contain'

        // Forr√°s forgat√°s (NDI/telefon √°ll√≥ m√≥dhoz)
        let sourceRotateDeg = 0; // 0 | 90 | 270

        // Ha a forr√°s fixen fekv≈ë (16:9) √©s a kimenet portrait (9:16), akkor ment√©skor
        // automatikusan elforgatjuk a forr√°st 270¬∞-kal, KIV√âVE ha a felhaszn√°l√≥ explicit
        // be√°ll√≠tott 90/270 forgat√°st.
        function getEffectiveRotateDeg(videoEl) {
            // explicit user be√°ll√≠t√°s els≈ëbbs√©get √©lvez
            const forced = sourceRotateDeg || 0;
            if (forced === 90 || forced === 270) return forced;

            // Auto-rotate csak akkor, ha PORTRAIT kimenetet k√©rsz √âS a forr√°s t√©nylegesen fekv≈ë (w>h)
            if (outputAspectMode === 'portrait') {
                const v = videoEl || liveVideo || rawPlayback;
                const vw = (v && v.videoWidth) ? v.videoWidth : 0;
                const vh = (v && v.videoHeight) ? v.videoHeight : 0;
                if (vw > 0 && vh > 0 && vw > vh) return 270;
            }
            return 0;
        }

        function applyPreviewAspect() {
            const vc = document.getElementById('videoContainer');
            if (!vc) return;

            // PREVIEW keret: alapb√≥l 16:9 fekv≈ë.
            // Portrait m√≥dban nem 9:16-re rajzoljuk √°t (ebb≈ël lesz a ‚Äûn√©gyzetes‚Äù √∂sszeoml√°s),
            // hanem a 16:9 keretet forgatjuk 270¬∞-kal √©s m√©retezz√ºk, hogy stabilan bef√©rjen.

            const portrait = (outputAspectMode === 'portrait');

            vc.style.transformOrigin = '50% 50%';

            if (portrait) {
                // Portrait preview keret: t√©nylegesen 9:16, NEM forgatjuk a kont√©nert.
                // √çgy a doboz nem fog "kil√≥gni" a center panelb≈ël.
                vc.style.transform = 'none';
                vc.style.aspectRatio = '9 / 16';

                // Stabil illeszt√©s: max 70vh magas, √©s a sz√©less√©g ehhez igazodik.
                // (Ha a panel sz≈±k, a maxWidth=100% fogja meg.)
                vc.style.height = '70vh';
                vc.style.maxHeight = '70vh';
                vc.style.width = 'calc(70vh * 9 / 16)';
                vc.style.maxWidth = '100%';
            } else {
                vc.style.aspectRatio = '16 / 9';
                vc.style.width = '100%';
                vc.style.height = 'auto';
                vc.style.maxHeight = '70vh';
                vc.style.transform = 'none';
                vc.style.maxWidth = '100%';
            }
            syncLastOutputWidth();
        }

        function applySourceRotateFromUI() {
            const sel = document.getElementById('sourceRotate');
            const v = sel ? parseInt(sel.value, 10) : 0;
            sourceRotateDeg = (v === 90 || v === 270) ? v : 0;

            // Preview keret + video transzform friss√≠t√©se
            applyPreviewAspect();
            if (currentMode === 'cam') {
                syncPreviewCanvasToMode(liveVideo);
            }
            requestAnimationFrame(() => applyLiveVideoTransform());
            setTimeout(applyLiveVideoTransform, 0);
        }

        function applyLiveVideoTransform() {
            const vc = document.getElementById('videoContainer');
            if (!vc || !liveVideo) return;

            const eff = getEffectiveRotateDeg(liveVideo);
            const deg = ((eff % 360) + 360) % 360;

            // A liveVideo elemet NEM CSS-sel pr√≥b√°ljuk j√≥l m√©retezni/forgatni, mert abb√≥l j√∂n a zoom/kicsiny√≠t√©s.
            // A korrekt el≈ën√©zetet a canvas-ra rajzoljuk (drawLivePreviewLoop).
            liveVideo.style.transform = 'none';
            liveVideo.style.objectFit = 'cover';
            liveVideo.style.transformOrigin = '50% 50%';

            // A st√°tusz badge maradjon a kont√©nerben, nem forgatjuk.
            // A forgat√°s a canvas rajzol√°sn√°l t√∂rt√©nik.

            // Biztons√°g: ha valaki m√©gis bekapcsolja a liveVideo megjelen√≠t√©st, legal√°bb forogjon.
            if (liveVideo.style.display !== 'none' && deg !== 0) {
                liveVideo.style.transform = `rotate(${deg}deg)`;
            }
        }

        function applyOutputAspectFromUI() {
            const sel = document.getElementById('outputAspect');
            outputAspectMode = sel ? sel.value : 'landscape';
            document.body.setAttribute('data-aspect', outputAspectMode);

            // Preview keret k√©par√°ny
            applyPreviewAspect();

            // Last output preview (a doboz ne torl√≥djon √∂ssze portraitn√°l)
            applyLastOutputAspectFromMode();

            // Ha kamer√°n vagyunk, igaz√≠tsuk a preview canvas m√©ret√©t is (portrait/landscape v√°lt√°sn√°l)
            if (currentMode === 'cam') {
                syncPreviewCanvasToMode(liveVideo);
            }

            // A vide√≥ transzform √∫jrasz√°mol√°sa
            requestAnimationFrame(() => applyLiveVideoTransform());
            setTimeout(applyLiveVideoTransform, 0);
            setTimeout(applyLiveVideoTransform, 50);
        }

        function applyOverlayFitFromUI() {
            const sel = document.getElementById('overlayFit');
            overlayFitMode = sel ? sel.value : 'stretch';

            // √âl≈ë el≈ën√©zet IMG illeszt√©se
            if (overlayFitMode === 'stretch') overlayImg.style.objectFit = 'fill';
            else if (overlayFitMode === 'contain') overlayImg.style.objectFit = 'contain';
            else overlayImg.style.objectFit = 'cover';
        }

        function setVideoContainerAspectFromCanvas() {
            const vc = document.getElementById('videoContainer');
            if (!vc) return;

            // A renderCanvas m√©rete dikt√°lja a kimeneti k√©par√°nyt (ez lesz a mentett vide√≥ is)
            if (canvas && canvas.width && canvas.height) {
                vc.style.aspectRatio = `${canvas.width} / ${canvas.height}`;
            } else {
                // fallback
                applyPreviewAspect();
            }
        }

        function chooseCanvasSizeByMode(sourceW, sourceH) {
            // A portrait/landscape itt m√°r T√âNYLEG a kimenet m√©ret√©t √°ll√≠tja.
            // auto: NDI-n√©l alapb√≥l 16:9 a stabil alap.
            const mode = outputAspectMode;

            if (mode === 'portrait') {
                // √Åll√≥ kimenet (720x1280)
                return { w: 720, h: 1280 };
            }

            // Fekv≈ë kimenet (1280x720)
            return { w: 1280, h: 720 };
        }

        function drawVideoCoverToRect(ctx2, videoEl, dx, dy, dw, dh) {
            const vw = videoEl.videoWidth || dw;
            const vh = videoEl.videoHeight || dh;

            const srcAspect = vw / vh;
            const dstAspect = dw / dh;

            let sx = 0, sy = 0, sw = vw, sh = vh;

            if (srcAspect > dstAspect) {
                sh = vh;
                sw = Math.round(vh * dstAspect);
                sx = Math.round((vw - sw) / 2);
                sy = 0;
            } else {
                sw = vw;
                sh = Math.round(vw / dstAspect);
                sx = 0;
                sy = Math.round((vh - sh) / 2);
            }

            ctx2.drawImage(videoEl, sx, sy, sw, sh, dx, dy, dw, dh);
        }

        function drawVideoCover(ctx2, videoEl, dstW, dstH) {
            drawVideoCoverToRect(ctx2, videoEl, 0, 0, dstW, dstH);
        }

        function drawVideoCoverRotated(ctx2, videoEl, dstW, dstH, rotateDeg) {
            const deg = (rotateDeg % 360 + 360) % 360;
            if (deg === 0) {
                drawVideoCoverToRect(ctx2, videoEl, 0, 0, dstW, dstH);
                return;
            }

            const rad = (deg * Math.PI) / 180;

            ctx2.save();
            ctx2.translate(dstW / 2, dstH / 2);
            ctx2.rotate(rad);

            const swap = (deg === 90 || deg === 270);
            const rw = swap ? dstH : dstW;
            const rh = swap ? dstW : dstH;

            drawVideoCoverToRect(ctx2, videoEl, -rw / 2, -rh / 2, rw, rh);
            ctx2.restore();
        }

        // R√∂gz√≠t≈ë kimenet form√°tum (pr√≥b√°lunk kompatibiliset v√°lasztani)
        let lastOutputUrl = null;
        let lastOutputExt = 'webm';
        let lastOutputMime = 'video/webm';

        // Elemek
        const liveVideo = document.getElementById('liveVideo');
        const rawPlayback = document.getElementById('rawPlayback');
        const canvas = document.getElementById('renderCanvas');
        const ctx = canvas.getContext('2d');
        const overlayImg = document.getElementById('overlayImg');
        const statusBadge = document.getElementById('statusBadge');
        const progressBar = document.getElementById('progressBar');
        const progressBarContainer = document.getElementById('progressBarContainer');
        const processText = document.getElementById('processText');

        // --- LIVE PREVIEW CANVAS LOOP (kamera el≈ën√©zet a canvas-on) ---
        let livePreviewRAF = 0;

        function stopLivePreviewLoop() {
            if (livePreviewRAF) {
                cancelAnimationFrame(livePreviewRAF);
                livePreviewRAF = 0;
            }
        }

        function syncPreviewCanvasToMode(videoEl) {
            const v = videoEl || liveVideo;
            const vw = (v && v.videoWidth) ? v.videoWidth : 1280;
            const vh = (v && v.videoHeight) ? v.videoHeight : 720;
            const chosen = chooseCanvasSizeByMode(vw, vh);
            if (canvas.width !== chosen.w || canvas.height !== chosen.h) {
                canvas.width = chosen.w;
                canvas.height = chosen.h;
            }
            setVideoContainerAspectFromCanvas();
        }

        function drawLivePreviewOnce() {
            if (currentMode !== 'cam') return;
            if (isProcessing) return;
            if (!liveVideo || !liveVideo.srcObject) return;
            if (liveVideo.readyState < 2) return; // nincs k√©p m√©g

            // A preview mindig a canvas-on megy, √≠gy nem lesz se "√≥ri√°si zoom", se "b√©lyegk√©p".
            try {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawVideoCoverRotated(ctx, liveVideo, canvas.width, canvas.height, getEffectiveRotateDeg(liveVideo));
            } catch (e) {
                // ne √∂lj√ºk meg a loopot
                console.warn('[PREVIEW] draw failed:', e);
            }
        }

        function drawLivePreviewLoop() {
            stopLivePreviewLoop();
            const loop = () => {
                drawLivePreviewOnce();
                livePreviewRAF = requestAnimationFrame(loop);
            };
            livePreviewRAF = requestAnimationFrame(loop);
        }

        // Utols√≥ kimenet UI

        const lastOutputBox = document.getElementById('lastOutput');
        const lastOutputVideo = document.getElementById('lastOutputVideo');
        const lastOutputInfo = document.getElementById('lastOutputInfo');
        const btnOpenLast = document.getElementById('btnOpenLast');
        const btnDownloadLast = document.getElementById('btnDownloadLast');
        const btnHideLast = document.getElementById('btnHideLast');

        function applyLastOutputAspectFromMode() {
            if (!lastOutputVideo) return;

            // Landscape: 16:9, Portrait: 9:16
            const ar = (outputAspectMode === 'portrait') ? '9/16' : '16/9';
            try {
                lastOutputVideo.style.aspectRatio = ar;
            } catch (_) {
                // Safari fallback: ignore
            }

            // Portraitban t√∫l magas lenne a player ‚Üí limitet CSS ad, itt csak biztos√≠tjuk a data-attr-t
            try {
                document.body.setAttribute('data-aspect', outputAspectMode);
            } catch (_) { }
        }

        function syncLastOutputWidth() {
            const vc = document.getElementById('videoContainer');
            const lo = document.getElementById('lastOutput');
            if (!vc || !lo) return;

            // A k√©sz vide√≥ + gombok doboza ugyanakkora sz√©less√©g≈± legyen, mint a preview keret.
            // √çgy portrait m√≥dban nem lesz ‚Äû≈±ber nagy‚Äù full panel sz√©less√©g≈±.
            const r = vc.getBoundingClientRect();
            const w = Math.max(0, Math.floor(r.width));
            if (w > 0) {
                lo.style.width = w + 'px';
                lo.style.maxWidth = w + 'px';
            } else {
                lo.style.width = '100%';
                lo.style.maxWidth = '100%';
            }
        }

        // MediaRecorder t√°mogatott mimeType kiv√°laszt√°sa (Mac-en a VP9 gyakran probl√©m√°s lej√°tsz√°sn√°l)
        function pickRecorderMime() {
            const candidates = [
                // MP4 r√∂gz√≠t√©s NEM garant√°lt (f≈ëleg Chrome-ban), de ha van, √∂r√ºl√ºnk
                { mime: 'video/mp4;codecs=avc1.42E01E,mp4a.40.2', ext: 'mp4' },
                { mime: 'video/mp4;codecs=avc1.42E01E', ext: 'mp4' },
                // WebM opci√≥k: VP8 √°ltal√°ban kompatibilisebb, mint VP9
                { mime: 'video/webm;codecs=vp8', ext: 'webm' },
                { mime: 'video/webm;codecs=vp9', ext: 'webm' },
                { mime: 'video/webm', ext: 'webm' }
            ];

            if (!window.MediaRecorder || !MediaRecorder.isTypeSupported) {
                return { mime: 'video/webm', ext: 'webm' };
            }

            for (const c of candidates) {
                try {
                    if (MediaRecorder.isTypeSupported(c.mime)) return c;
                } catch (_) { }
            }
            return { mime: 'video/webm', ext: 'webm' };
        }

        function setLastOutput(url, mime, ext, bytes) {
            // R√©gi URL felszabad√≠t√°s
            try { if (lastOutputUrl) URL.revokeObjectURL(lastOutputUrl); } catch (_) { }

            lastOutputUrl = url;
            lastOutputMime = mime;
            lastOutputExt = ext;

            lastOutputVideo.src = url;
            lastOutputBox.style.display = 'block';
            // Ensure the preview player matches the selected output aspect
            applyLastOutputAspectFromMode();
            syncLastOutputWidth();

            const sizeMB = bytes ? (bytes / (1024 * 1024)).toFixed(1) : '?';
            lastOutputInfo.innerText = `Form√°tum: ${ext.toUpperCase()} (${mime}) ‚Ä¢ M√©ret: ${sizeMB} MB`;
        }

        btnOpenLast.onclick = () => {
            if (!lastOutputUrl) return;
            window.open(lastOutputUrl, '_blank');
        };
        btnDownloadLast.onclick = () => {
            if (!lastOutputUrl) return;
            const a = document.createElement('a');
            const now = new Date();
            a.href = lastOutputUrl;
            a.download = `360_Video_${now.getHours()}${now.getMinutes()}${now.getSeconds()}.${lastOutputExt}`;
            a.click();
        };
        btnHideLast.onclick = () => {
            lastOutputBox.style.display = 'none';
        };

        // Safari/MediaRecorder diagnosztika: ha nincs MediaRecorder, a feldolgoz√°s nem fog menni.
        (function bootChecks() {
            // A "Utols√≥ vide√≥" doboz csak a feldolgoz√°s v√©g√©n jelenik meg.
            try {
                if (lastOutputInfo) {
                    lastOutputInfo.innerText = 'A feldolgoz√°s v√©g√©n itt jelenik meg az utols√≥ vide√≥ (el≈ën√©zet + let√∂lt√©s).';
                }
            } catch (_) { }

            if (!window.MediaRecorder) {
                console.error('[REC] MediaRecorder NOT available in this browser.');
                statusBadge.innerText = 'SAFARI: NINCS FELV√âTEL';
                statusBadge.style.color = 'red';
                processText.innerText = 'Ez a Safari verzi√≥ nem t√°mogatja a MediaRecorder-t. Haszn√°lj Chrome-ot, vagy enged√©lyezd a Safari k√≠s√©rleti MediaRecorder/WebRTC opci√≥it.';
            }
        })();

        // --- 0. M√ìDV√ÅLT√ÅS ---
        function setMode(mode) {
            currentMode = mode;
            document.getElementById('btnModeCam').className = mode === 'cam' ? 'mode-btn active' : 'mode-btn';
            document.getElementById('btnModeFile').className = mode === 'file' ? 'mode-btn active' : 'mode-btn';

            document.getElementById('camControls').style.display = mode === 'cam' ? 'block' : 'none';
            document.getElementById('fileControls').style.display = mode === 'file' ? 'block' : 'none';

            if (mode === 'cam') {
                // Kamera m√≥dban a korrekt el≈ën√©zetet canvas-on mutatjuk (nem a video elemen),
                // √≠gy a portrait/rotate nem fog sz√©tesni.
                liveVideo.style.display = 'none';
                canvas.style.display = 'block';
                rawPlayback.style.display = 'none';
                // DropZone elrejt√©se kamera m√≥dban
                const dz = document.getElementById('dropZone');
                if (dz) dz.style.display = 'none';
                loadCameras();
            } else {
                stopLivePreviewLoop();
                liveVideo.style.display = 'none';
                rawPlayback.style.display = 'none'; // Csak feldolgoz√°skor l√°tszik
                if (stream) stream.getTracks().forEach(t => t.stop());

                // Drop Zone Esem√©nyek
                const dz = document.getElementById('dropZone');
                // Biztosan l√°tsz√≥djon a drop zone f√°jl m√≥dban
                if (dz) dz.style.display = 'flex';
                dz.ondragover = (e) => { e.preventDefault(); dz.classList.add('dragover'); };
                dz.ondragleave = () => dz.classList.remove('dragover');
                dz.ondrop = (e) => {
                    e.preventDefault(); dz.classList.remove('dragover');
                    if (e.dataTransfer.files[0]) processImportedFile(e.dataTransfer.files[0]);
                };
            }
        }

        function handleFileSelect(input) {
            if (input.files[0]) processImportedFile(input.files[0]);
        }

        async function processImportedFile(file) {
            statusBadge.innerText = "F√ÅJL BET√ñLTVE";
            statusBadge.style.color = "#fff";

            // Blob l√©trehoz√°sa a f√°jlb√≥l
            rawVideoBlob = file;
            rawPlayback.src = URL.createObjectURL(rawVideoBlob);

            // Azonnali ind√≠t√°s
            startProcessingLoop();
        }


        // --- 1. BRANDING & KIVET√çT≈ê ---
        function updateBranding() {
            const text = document.getElementById('brandTitleInput').value || "360 Booth";
            if (projectorWin && !projectorWin.closed) {
                projectorWin.postMessage({ type: 'updateBrand', title: text, logo: currentLogoData }, '*');
            }
        }
        function updateLogo() {
            const file = document.getElementById('logoInput').files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function (e) { currentLogoData = e.target.result; updateBranding(); }
                reader.readAsDataURL(file);
            }
        }
        function openProjectorWindow() {
            if (projectorWin && !projectorWin.closed) { projectorWin.focus(); return; }
            // (A kor√°bbi kivet√≠t≈ë HTML k√≥dja v√°ltozatlan, itt egyszer≈±s√≠tve h√≠vom meg)
            const displayHTML = `<!DOCTYPE html><html lang="hu"><head><meta charset="UTF-8"><title>360 Booth - Kivet√≠t≈ë</title><style>body{margin:0;background:#000;color:#fff;font-family:sans-serif;display:grid;grid-template-columns:75% 25%;height:100vh;overflow:hidden}#main{display:flex;flex-direction:column;align-items:center;justify-content:center;background:radial-gradient(circle,#1a1a1a 0%,#000 100%)}#side{background:#111;border-left:1px solid #333;padding:20px;display:flex;flex-direction:column;align-items:center}video{max-width:90%;border:1px solid #333;border-radius:10px}.g-item{width:100%;margin-bottom:10px;border:1px solid #333;border-radius:5px;cursor:pointer}.g-item video{width:100%;display:block}</style></head><body><div id="main"><h1 id="title" style="text-transform:uppercase;letter-spacing:4px">360 Booth</h1><img id="logo" style="max-height:80px;margin-bottom:20px;display:none"><video id="disp" controls autoplay loop style="display:none"></video><h2 id="wait">V√°rakoz√°s...</h2></div><div id="side"><h3>Gal√©ria</h3><div id="gal" style="width:100%;overflow-y:auto"></div></div><script>window.addEventListener('message',e=>{const d=e.data;if(d.type==='updateBrand'){document.getElementById('title').innerText=d.title;if(d.logo){document.getElementById('logo').src=d.logo;document.getElementById('logo').style.display='block'}else{document.getElementById('logo').style.display='none'}}if(d.type==='newVideo'){document.getElementById('wait').style.display='none';const v=document.getElementById('disp');v.style.display='block';v.src=d.url;v.play();const g=document.createElement('div');g.className='g-item';g.innerHTML='<video src="'+d.url+'" muted></video>';g.onclick=()=>{v.src=d.url;v.play()};document.getElementById('gal').prepend(g)}})<\/script></body></html>`;
            projectorWin = window.open("", "ProjectorWindow", "width=1280,height=720,menubar=no,toolbar=no");
            projectorWin.document.write(displayHTML);
            setTimeout(() => updateBranding(), 500);
        }
        function sendToProjector(blobUrl) {
            if (projectorWin && !projectorWin.closed) { projectorWin.postMessage({ type: 'newVideo', url: blobUrl }, '*'); }
        }

        // --- 2. KAMERA (Ha m√©gis kell) ---
        async function loadCameras() {
            // Kamera lista megb√≠zhat√≥ bet√∂lt√©se: el≈ëbb enged√©lyt k√©r√ºnk,
            // majd enumerateDevices, v√©g√ºl ind√≠t√°s.
            try {
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    console.error('[CAM] mediaDevices/getUserMedia not available. Use HTTPS or localhost.');
                    statusBadge.innerText = 'KAMERA NEM EL√âRHET≈ê';
                    statusBadge.style.color = 'red';
                    return;
                }

                // Enged√©lyk√©r√©s (labels + videoinput lista csak ez ut√°n megb√≠zhat√≥)
                let tmpStream = null;
                try {
                    tmpStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
                } catch (e) {
                    console.error('[CAM] Permission/getUserMedia failed:', e);
                    statusBadge.innerText = 'KAMERA ENGED√âLY KELL';
                    statusBadge.style.color = 'red';
                    return;
                } finally {
                    if (tmpStream) tmpStream.getTracks().forEach(t => t.stop());
                }

                const d = await navigator.mediaDevices.enumerateDevices();
                const s = document.getElementById('camSelect');
                s.innerHTML = '';

                const cams = d.filter(x => x.kind === 'videoinput');
                if (cams.length === 0) {
                    console.error('[CAM] No videoinput devices found.');
                    s.innerHTML = '<option value="">Nincs kamera</option>';
                    statusBadge.innerText = 'NINCS KAMERA';
                    statusBadge.style.color = 'red';
                    return;
                }

                cams.forEach((x, idx) => {
                    const o = document.createElement('option');
                    o.value = x.deviceId;
                    o.text = x.label || `Kamera ${idx + 1}`;
                    s.appendChild(o);
                });

                // Csak kamera m√≥dban ind√≠tunk
                if (currentMode === 'cam') await startCamera();

            } catch (e) {
                console.error('[CAM] loadCameras error:', e);
                statusBadge.innerText = 'KAMERA HIBA';
                statusBadge.style.color = 'red';
            }
        }

        async function startCamera() {
            if (currentMode !== 'cam') return;

            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                console.error('[CAM] mediaDevices/getUserMedia not available. Use HTTPS or localhost.');
                statusBadge.innerText = 'KAMERA NEM EL√âRHET≈ê';
                statusBadge.style.color = 'red';
                return;
            }

            const id = document.getElementById('camSelect').value;

            // El≈ëz≈ë stream le√°ll√≠t√°sa (k√ºl√∂nben Safari/Chrome n√©ha nem v√°lt kamer√°t rendesen)
            try {
                if (stream) stream.getTracks().forEach(t => t.stop());
            } catch (_) { }
            stream = null;

            try {
                const constraints = {
                    video: {
                        width: { ideal: 1280 },
                        height: { ideal: 720 },
                        ...(id ? { deviceId: { exact: id } } : {})
                    },
                    audio: false
                };

                stream = await navigator.mediaDevices.getUserMedia(constraints);
                liveVideo.srcObject = stream;

                // iOS/Safari: n√©ha kell explicit play
                try { await liveVideo.play(); } catch (_) { }

                // Canvas el≈ën√©zet inicializ√°l√°s
                canvas.style.display = 'block';
                liveVideo.style.display = 'none';

                // Amint megvan a vide√≥ metadata, √∫jrasz√°moljuk a rotate+scale transzformot
                const onMeta = () => {
                    liveVideo.removeEventListener('loadedmetadata', onMeta);
                    applyPreviewAspect();
                    syncPreviewCanvasToMode(liveVideo);
                    applyLiveVideoTransform();
                    drawLivePreviewLoop();
                };
                liveVideo.addEventListener('loadedmetadata', onMeta);

                applyPreviewAspect();
                syncPreviewCanvasToMode(liveVideo);
                applyLiveVideoTransform();
                drawLivePreviewLoop();

                statusBadge.innerText = 'K√âSZENL√âT';
                statusBadge.style.color = '#03dac6';

            } catch (e) {
                console.error('[CAM] startCamera getUserMedia failed:', e);
                statusBadge.innerText = 'KAMERA HIBA';
                statusBadge.style.color = 'red';
            }
        }

        // --- 3. EFFEKTEK ---
        function fmtNum(x, d = 2) {
            const n = Number(x);
            if (!isFinite(n)) return '0';
            return n.toFixed(d).replace(/\.00$/, '.0').replace(/\.(\d)0$/, '.$1');
        }

        function updateEffectUI() {
            const tS = document.getElementById('effTimeSlider');
            const sS = document.getElementById('effSpeedSlider');
            const tV = document.getElementById('effTimeVal');
            const sV = document.getElementById('effSpeedVal');
            if (tS && tV) tV.innerText = `${fmtNum(tS.value, 1)} s`;
            if (sS && sV) sV.innerText = `${fmtNum(sS.value, 2)}√ó`;
            updateSpeedPresetButtons(parseFloat(sS ? sS.value : '1'));

            // Automatikus friss√≠t√©s: ha van kijel√∂lt szakasz, a cs√∫szka/preset mozgat√°s azonnal √°t√≠rja.
            scheduleAutoApplyToSelected();
        }

        function updateSpeedPresetButtons(v) {
            const b05 = document.getElementById('btnSpeed05');
            const b10 = document.getElementById('btnSpeed10');
            const b20 = document.getElementById('btnSpeed20');
            const eq = (a, b) => Math.abs(a - b) < 0.001;
            if (b05) b05.classList.toggle('active', eq(v, 0.5));
            if (b10) b10.classList.toggle('active', eq(v, 1.0));
            if (b20) b20.classList.toggle('active', eq(v, 2.0));
        }

        // --- AUTO APPLY (kijel√∂lt szakasz azonnali friss√≠t√©se cs√∫szka/preset mozgat√°skor) ---
        let _autoApplyTimer = 0;

        function scheduleAutoApplyToSelected() {
            if (selectedEffectIndex < 0 || selectedEffectIndex >= effects.length) return;
            if (_autoApplyTimer) clearTimeout(_autoApplyTimer);
            _autoApplyTimer = setTimeout(() => {
                _autoApplyTimer = 0;
                applyToSelected();
            }, 120);
        }

        function setSpeedPreset(v) {
            const sS = document.getElementById('effSpeedSlider');
            if (sS) sS.value = String(v);
            updateEffectUI();
            scheduleAutoApplyToSelected();
        }

        function selectEffect(idx) {
            if (!Array.isArray(effects) || effects.length === 0) {
                selectedEffectIndex = -1;
                return;
            }
            if (idx < 0 || idx >= effects.length) {
                selectedEffectIndex = -1;
                return;
            }
            selectedEffectIndex = idx;

            // cs√∫szk√°k felv√©tele a kijel√∂lt szakaszra
            const tS = document.getElementById('effTimeSlider');
            const sS = document.getElementById('effSpeedSlider');
            if (tS) tS.value = String(effects[idx].duration);
            if (sS) sS.value = String(effects[idx].speed);
            updateEffectUI();
            renderList();
            renderTimeline();
        }

        function applyToSelected() {
            if (selectedEffectIndex < 0 || selectedEffectIndex >= effects.length) return;
            const tS = document.getElementById('effTimeSlider');
            const sS = document.getElementById('effSpeedSlider');
            const dur = parseFloat(tS ? tS.value : '0');
            const spd = parseFloat(sS ? sS.value : '0');
            if (!isFinite(dur) || dur <= 0) return;
            if (!isFinite(spd) || spd <= 0) return;
            effects[selectedEffectIndex] = { duration: dur, speed: spd };
            renderList();
            renderTimeline();
        }

        function addEffect() {
            const tS = document.getElementById('effTimeSlider');
            const sS = document.getElementById('effSpeedSlider');
            const dur = parseFloat(tS ? tS.value : '2');
            const spd = parseFloat(sS ? sS.value : '1');
            if (!isFinite(dur) || dur <= 0) return;
            if (!isFinite(spd) || spd <= 0) return;
            effects.push({ duration: dur, speed: spd });
            renderList();
        }

        function deleteEffect(idx) {
            if (idx < 0 || idx >= effects.length) return;
            effects.splice(idx, 1);
            if (selectedEffectIndex === idx) selectedEffectIndex = -1;
            else if (selectedEffectIndex > idx) selectedEffectIndex -= 1;
            renderList();
        }

        function clearEffects() {
            effects = [];
            selectedEffectIndex = -1;
            renderList();
        }

        function renderTimeline() {
            const tl = document.getElementById('effectsTimeline');
            if (!tl) return;

            if (!Array.isArray(effects) || effects.length === 0) {
                tl.innerHTML = '<div style="color:#666; font-size:11px; display:flex; align-items:center; justify-content:center; width:100%;">Nincs szakasz ‚Äì alap 1√ó</div>';
                return;
            }

            const total = effects.reduce((a, b) => a + (Number(b.duration) || 0), 0) || 1;

            tl.innerHTML = effects.map((e, i) => {
                const dur = Number(e.duration) || 0;
                const spd = Number(e.speed) || 1;
                const cls = (spd < 0.99) ? 'slow' : (spd > 1.01 ? 'fast' : 'norm');
                const sel = (i === selectedEffectIndex) ? 'selected' : '';

                // flex ar√°ny: id≈ëtartam alapj√°n (min√©l hosszabb, ann√°l sz√©lesebb szegmens)
                const flex = Math.max(0.2, dur);
                const label = `${fmtNum(dur, 1)}s ¬∑ ${fmtNum(spd, 2)}√ó`;

                return `<div class="eff-seg ${cls} ${sel}" style="flex:${flex} 1 0%;" title="${label}" onclick="selectEffect(${i})">${fmtNum(spd, 2)}√ó</div>`;
            }).join('');
        }

        function renderList() {
            const listEl = document.getElementById('effectsList');
            const sumEl = document.getElementById('effectsSummary');
            if (!listEl) return;

            renderTimeline();

            listEl.innerHTML = effects.map((e, i) => {
                const d = fmtNum(e.duration, 1);
                const s = fmtNum(e.speed, 2);
                const sel = (i === selectedEffectIndex);
                return `
                    <div class="effect-item selectable ${sel ? 'selected' : ''}" onclick="selectEffect(${i})">
                        <div style="display:flex; gap:8px; align-items:center; min-width:0;">
                            <div style="font-weight:800; color:#03dac6;">#${i + 1}</div>
                            <div style="white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">${d}s ‚Üí ${s}√ó</div>
                        </div>
                        <button class="eff-del" type="button" onclick="event.stopPropagation(); deleteEffect(${i})">T√∂rl√©s</button>
                    </div>
                `;
            }).join('');

            const total = effects.reduce((a, b) => a + (Number(b.duration) || 0), 0);
            if (sumEl) {
                if (effects.length === 0) {
                    sumEl.innerText = 'Nincs szakaszlista: alap√©rtelmezett 1√ó lej√°tsz√°s.';
                } else {
                    sumEl.innerText = `Szakaszok: ${effects.length} db ‚Ä¢ √ñssz-id≈ë: ${fmtNum(total, 1)} s (a feldolgoz√°s ideje)`;
                }
            }
        }

        // --- OVERLAY LOADER ---

        function computeAlphaBBoxFromImage(imgEl) {
            try {
                const w = imgEl.naturalWidth || 0;
                const h = imgEl.naturalHeight || 0;
                if (w <= 0 || h <= 0) return null;

                const tmp = document.createElement('canvas');
                tmp.width = w;
                tmp.height = h;
                const tctx = tmp.getContext('2d', { willReadFrequently: true });
                tctx.clearRect(0, 0, w, h);
                tctx.drawImage(imgEl, 0, 0);

                const data = tctx.getImageData(0, 0, w, h).data;
                let minX = w, minY = h, maxX = -1, maxY = -1;

                // Alpha csatorna: data[i+3]
                for (let y = 0; y < h; y++) {
                    const row = y * w * 4;
                    for (let x = 0; x < w; x++) {
                        const a = data[row + x * 4 + 3];
                        if (a > 0) {
                            if (x < minX) minX = x;
                            if (y < minY) minY = y;
                            if (x > maxX) maxX = x;
                            if (y > maxY) maxY = y;
                        }
                    }
                }

                if (maxX < minX || maxY < minY) return null;

                // +1 mert maxX/maxY pixel is kell
                const sx = minX;
                const sy = minY;
                const sw = (maxX - minX + 1);
                const sh = (maxY - minY + 1);

                // Ha gyakorlatilag teljes k√©p, nem cropolunk
                if (sx === 0 && sy === 0 && sw === w && sh === h) return null;

                return { sx, sy, sw, sh, w, h };
            } catch (e) {
                console.warn('[OVERLAY] bbox compute failed:', e);
                return null;
            }
        }
        function loadOverlay(i) {
            overlayReady = false;
            overlayCrop = null;
            overlayCroppedOnce = false;

            if (!i || !i.files || !i.files[0]) {
                try {
                    overlayImg.removeAttribute('src');
                } catch (_) { }
                overlayImg.style.display = 'none';
                return;
            }

            const file = i.files[0];

            // Csak PNG-t enged√ºnk (k√ºl√∂nben Safari/Chrome furcs√°n viselkedhet)
            const nameOk = (file.name || '').toLowerCase().endsWith('.png');
            const typeOk = (file.type || '').toLowerCase().includes('png');
            if (!nameOk && !typeOk) {
                statusBadge.innerText = 'OVERLAY NEM PNG';
                statusBadge.style.color = 'red';
                try {
                    overlayImg.removeAttribute('src');
                } catch (_) { }
                overlayImg.style.display = 'none';
                return;
            }

            // √âl≈ë el≈ën√©zet: a vide√≥/canvas f√∂l√© tessz√ºk az IMG-t
            overlayImg.style.display = 'block';
            overlayImg.style.position = 'absolute';
            overlayImg.style.left = '0';
            overlayImg.style.top = '0';
            overlayImg.style.width = '100%';
            overlayImg.style.height = '100%';
            // Illeszt√©s a UI szerint
            if (overlayFitMode === 'stretch') overlayImg.style.objectFit = 'fill';
            else if (overlayFitMode === 'contain') overlayImg.style.objectFit = 'contain';
            else overlayImg.style.objectFit = 'cover';
            overlayImg.style.pointerEvents = 'none';
            overlayImg.style.zIndex = '4'; // statusBadge zIndex=5

            overlayImg.onload = () => {
                overlayReady = true;

                // Alpha bbox crop: lev√°gjuk a teljesen √°tl√°tsz√≥ peremet, hogy a keret kifusson a sz√©lekig
                overlayCrop = computeAlphaBBoxFromImage(overlayImg);

                // IMPORTANT: a preview-ben (IMG overlay) is l√°tsz√≥djon a crop.
                // Ehhez egyszer (csak egyszer!) fizikailag √∫j PNG-t gener√°lunk a lev√°gott tartalomb√≥l,
                // √©s visszat√∂ltj√ºk az overlayImg-be. √çgy elt≈±nik a k√ºls≈ë √°tl√°tsz√≥ perem miatti fekete s√°v.
                if (overlayCrop && !overlayCroppedOnce) {
                    try {
                        const tmp = document.createElement('canvas');
                        tmp.width = overlayCrop.sw;
                        tmp.height = overlayCrop.sh;
                        const tctx = tmp.getContext('2d');
                        tctx.clearRect(0, 0, tmp.width, tmp.height);
                        tctx.drawImage(
                            overlayImg,
                            overlayCrop.sx, overlayCrop.sy, overlayCrop.sw, overlayCrop.sh,
                            0, 0, overlayCrop.sw, overlayCrop.sh
                        );

                        // Jel√∂lj√ºk, hogy ez m√°r a "croppolt" verzi√≥, hogy ne legyen v√©gtelen onload ciklus
                        overlayCroppedOnce = true;

                        // A tov√°bbi rajzol√°shoz m√°r nincs sz√ºks√©g forr√°s-crop adatra a preview-hoz,
                        // de a canvas renderben m√©g haszn√°lhat√≥ lenne. Mivel itt fizikailag lev√°gtuk a k√©pet,
                        // lenull√°zzuk, √≠gy a renderben sima drawImage is teljesen kifut.
                        overlayCrop = null;

                        // √öj PNG bet√∂lt√©se (√∫jra fog futni az onload egyszer)
                        overlayImg.src = tmp.toDataURL('image/png');
                        return;
                    } catch (e) {
                        console.warn('[OVERLAY] preview crop build failed:', e);
                        // ha a crop gener√°l√°s elhasal, marad a kor√°bbi logika
                    }
                }

                if (overlayCrop) {
                    console.log('[OVERLAY] alpha-crop', overlayCrop);
                }

                console.log('[OVERLAY] loaded', overlayImg.naturalWidth, overlayImg.naturalHeight);
                statusBadge.innerText = 'OVERLAY OK';
                statusBadge.style.color = '#03dac6';
            };

            overlayImg.onerror = (e) => {
                overlayReady = false;
                console.error('[OVERLAY] load error', e);
                statusBadge.innerText = 'OVERLAY HIBA';
                statusBadge.style.color = 'red';
            };

            const r = new FileReader();
            r.onload = (e) => {
                overlayImg.src = e.target.result;
            };
            r.onerror = (e) => {
                overlayReady = false;
                console.error('[OVERLAY] FileReader error', e);
                statusBadge.innerText = 'OVERLAY OLVAS√ÅS HIBA';
                statusBadge.style.color = 'red';
            };
            r.readAsDataURL(file);
        }

        // --- 4. R√ñGZ√çT√âS (WEBCAM M√ìD) ---
        function initiateCamSequence() {
            if (!stream) {
                console.warn('[CAM] No active stream. Trying to start camera...');
                statusBadge.innerText = 'KAMERA IND√çT√ÅS...';
                statusBadge.style.color = 'yellow';
                loadCameras();
                return;
            }
            document.getElementById('startBtn').disabled = true;
            statusBadge.innerText = "FELV√âTEL..."; statusBadge.style.color = "red";
            chunks = [];
            const pick1 = pickRecorderMime();
            try {
                mediaRecorder = new MediaRecorder(stream, { mimeType: pick1.mime, videoBitsPerSecond: 5000000 });
            } catch (e) {
                console.error('[REC] MediaRecorder create failed:', e);
                statusBadge.innerText = 'R√ñGZ√çT√âS HIBA';
                statusBadge.style.color = 'red';
                processText.innerText = 'A b√∂ng√©sz≈ë nem tud r√∂gz√≠teni (MediaRecorder). Safari-ban ez gyakori. Pr√≥b√°ld Chrome-ban, vagy Safari Develop ‚Üí Experimental Features alatt MediaRecorder/WebRTC opci√≥kat enged√©lyezni.';
                document.getElementById('startBtn').disabled = false;
                return;
            }
            mediaRecorder.ondataavailable = e => { if (e.data.size > 0) chunks.push(e.data) };
            mediaRecorder.onstop = () => {
                const pick2 = pickRecorderMime();
                rawVideoBlob = new Blob(chunks, { type: pick2.mime });
                rawPlayback.src = URL.createObjectURL(rawVideoBlob);
                startProcessingLoop();
            };
            mediaRecorder.start();
            const dur = parseInt(document.getElementById('recDuration').value) || 4;
            setTimeout(() => mediaRecorder.stop(), dur * 1000);
        }

        // --- 5. F≈ê FELDOLGOZ√ì LOOP (K√ñZ√ñS MINDK√âT M√ìDH√ìZ) ---
        async function startProcessingLoop() {
            isProcessing = true;
            statusBadge.innerText = "FELDOLGOZ√ÅS..."; statusBadge.style.color = "yellow";
            progressBarContainer.style.display = 'block';
            // Kimenet doboz elrejt√©se feldolgoz√°s alatt
            if (lastOutputBox) lastOutputBox.style.display = 'none';

            liveVideo.style.display = 'none';
            canvas.style.display = 'block';

            // V√°rjuk meg a forr√°s vide√≥ metaadat√°t, hogy tudjuk a k√©par√°nyt
            try {
                if (rawPlayback.readyState < 1) {
                    await new Promise((res) => {
                        const onMeta = () => { rawPlayback.removeEventListener('loadedmetadata', onMeta); res(); };
                        rawPlayback.addEventListener('loadedmetadata', onMeta);
                    });
                }
            } catch (_) { }

            const srcW = rawPlayback.videoWidth || 1280;
            const srcH = rawPlayback.videoHeight || 720;
            const chosen = chooseCanvasSizeByMode(srcW, srcH);

            // Canvas fix m√©ret be√°ll√≠t√°s (a mentett vide√≥ k√©par√°nya IS EZ LESZ)
            canvas.width = chosen.w;
            canvas.height = chosen.h;
            setVideoContainerAspectFromCanvas();

            // Zene
            const m = document.getElementById('musicFile');
            let actx, dest, src, hasA = false;
            if (m.files[0]) {
                hasA = true; actx = new (window.AudioContext || window.webkitAudioContext)();
                const b = await m.files[0].arrayBuffer();
                const d = await actx.decodeAudioData(b);
                dest = actx.createMediaStreamDestination();
                src = actx.createBufferSource(); src.buffer = d; src.loop = true; src.connect(dest);
            }

            const cStream = canvas.captureStream(30);
            if (hasA) cStream.addTrack(dest.stream.getAudioTracks()[0]);

            const pick3 = pickRecorderMime();
            let rec;
            try {
                rec = new MediaRecorder(cStream, { mimeType: pick3.mime, videoBitsPerSecond: 5000000 });
            } catch (e) {
                console.error('[REC] MediaRecorder(captureStream) create failed:', e);
                statusBadge.innerText = 'RENDER HIBA';
                statusBadge.style.color = 'red';
                progressBarContainer.style.display = 'none';
                processText.innerText = 'A b√∂ng√©sz≈ë nem tud canvas streamet r√∂gz√≠teni. Safari-ban ez verzi√≥f√ºgg≈ë. Haszn√°lj Chrome-ot a biztos m≈±k√∂d√©shez.';
                resetUI();
                if (actx) actx.close();
                return;
            }
            const fChunks = [];
            rec.ondataavailable = e => { if (e.data.size > 0) fChunks.push(e.data) };
            rec.onstop = () => {
                const pick4 = pickRecorderMime();
                const outBlob = new Blob(fChunks, { type: pick4.mime });
                const url = URL.createObjectURL(outBlob);

                // Mutassuk meg az oldalon is (mert a macOS sokszor nem nyitja meg a .webm-et)
                setLastOutput(url, pick4.mime, pick4.ext, outBlob.size);

                // Azonnali let√∂lt√©s (marad, de m√°r a v√°lasztott kiterjeszt√©ssel)
                const a = document.createElement('a');
                const now = new Date();
                a.href = url;
                a.download = `360_Video_${now.getHours()}${now.getMinutes()}${now.getSeconds()}.${pick4.ext}`;
                a.click();

                sendToProjector(url);
                resetUI();
                if (actx) actx.close();
            };

            rec.start();
            if (hasA) src.start(0);

            await rawPlayback.play();
            let plan = effects.length > 0 ? effects : [{ duration: 100, speed: 1 }];
            if (document.getElementById('boomerangMode').checked) plan = [...plan, ...plan];

            let tDur = 0; plan.forEach(p => tDur += p.duration);
            let el = 0;

            for (const seg of plan) {
                rawPlayback.playbackRate = seg.speed;
                const s = Date.now();
                const d = seg.duration * 1000;
                while (Date.now() - s < d) {
                    drawVideoCoverRotated(ctx, rawPlayback, canvas.width, canvas.height, getEffectiveRotateDeg(rawPlayback));
                    // Overlay: stabilan csak akkor rajzoljuk, ha bet√∂lt√∂tt; fallback naturalWidth alapj√°n
                    if (overlayReady || (overlayImg && overlayImg.naturalWidth > 0 && overlayImg.naturalHeight > 0)) {
                        try {
                            if (overlayFitMode === 'stretch') {
                                // Pont a sz√©lekhez: torz√≠that (de ez a c√©l)
                                ctx.drawImage(overlayImg, 0, 0, canvas.width, canvas.height);
                            } else {
                                // contain/cover: ar√°nyt tartunk, √©s k√∂z√©pre tessz√ºk
                                const iw = overlayImg.naturalWidth;
                                const ih = overlayImg.naturalHeight;
                                const dstW = canvas.width;
                                const dstH = canvas.height;
                                const iAsp = iw / ih;
                                const dAsp = dstW / dstH;

                                let dw, dh;
                                if (overlayFitMode === 'contain') {
                                    if (iAsp > dAsp) { dw = dstW; dh = Math.round(dstW / iAsp); }
                                    else { dh = dstH; dw = Math.round(dstH * iAsp); }
                                } else {
                                    // cover
                                    if (iAsp > dAsp) { dh = dstH; dw = Math.round(dstH * iAsp); }
                                    else { dw = dstW; dh = Math.round(dstW / iAsp); }
                                }
                                const dx = Math.round((dstW - dw) / 2);
                                const dy = Math.round((dstH - dh) / 2);
                                ctx.drawImage(overlayImg, dx, dy, dw, dh);
                            }
                        } catch (e) {
                            console.warn('[OVERLAY] drawImage failed:', e);
                        }
                    }

                    el += 0.033;
                    const p = Math.min((el / tDur) * 100, 100);
                    progressBar.style.width = p + "%";
                    processText.innerText = Math.round(p) + "%";

                    await new Promise(r => setTimeout(r, 33));
                    if (rawPlayback.ended) {
                        if (document.getElementById('boomerangMode').checked) { rawPlayback.currentTime = 0; await rawPlayback.play(); }
                        else break;
                    }
                }
            }
            rec.stop();
            rawPlayback.pause();
        }

        function resetUI() {
            isProcessing = false;
            progressBarContainer.style.display = 'none'; progressBar.style.width = "0%"; processText.innerText = "";
            document.getElementById('startBtn').disabled = false;
            statusBadge.innerText = "K√âSZENL√âT"; statusBadge.style.color = "#03dac6";
            if (currentMode === 'cam') {
                // Kamer√°n a preview maradjon a canvas-on
                liveVideo.style.display = 'none';
                canvas.style.display = 'block';
                syncPreviewCanvasToMode(liveVideo);
                drawLivePreviewLoop();
            }
            else { canvas.style.display = 'block'; } // F√°jl m√≥dban maradjon a canvas a legutols√≥ k√©ppel

            // A kimenet doboz maradhat l√°that√≥ a v√©g√©n, de felv√©telkor/feldolgoz√°skor elrejtj√ºk.
        }

        // Kamer√°k bet√∂lt√©se csak user gesture ut√°n (pl. m√≥dv√°lt√°s / gombnyom√°s), k√ºl√∂nben a b√∂ng√©sz≈ë blokkolhatja.
        applyOutputAspectFromUI();
        document.body.setAttribute('data-aspect', outputAspectMode);
        applyOverlayFitFromUI();
        applySourceRotateFromUI();
        applyLastOutputAspectFromMode();
        syncLastOutputWidth();
        window.addEventListener('resize', () => {
            applyPreviewAspect();
            if (currentMode === 'cam') {
                syncPreviewCanvasToMode(liveVideo);
            }
            requestAnimationFrame(() => applyLiveVideoTransform());
            setTimeout(applyLiveVideoTransform, 0);
            setTimeout(applyLiveVideoTransform, 50);
            syncLastOutputWidth();
        });
        effects.push({ duration: 2, speed: 0.5 });
        renderList();

        // Effektek UI init + √©l≈ë friss√≠t√©s
        (function initEffectsUI() {
            const tS = document.getElementById('effTimeSlider');
            const sS = document.getElementById('effSpeedSlider');
            if (tS) tS.addEventListener('input', updateEffectUI);
            if (sS) sS.addEventListener('input', updateEffectUI);
            updateEffectUI();
            renderTimeline();
        })();

        window.addEventListener('beforeunload', () => {
            stopLivePreviewLoop();
            try { if (stream) stream.getTracks().forEach(t => t.stop()); } catch (_) { }
        });
    </script>
</body>

</html>
