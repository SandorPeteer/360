<!DOCTYPE html>
<html lang="hu">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>360 selfie ‚Ä¢ v1.5.1 ‚Ä¢ S.P.</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&display=swap');

        :root {
            --bg-0: #0a1016;
            --bg-1: #0e1620;
            --bg-2: #111b27;
            --panel: #0f1822;
            --panel-2: #0b141e;
            --border: #1e2a3a;
            --control-bg: #121c27;
            --control-bg-hover: #162131;
            --control-border: #253244;
            --control-border-strong: #2b3a50;
            --control-radius: 8px;
            --control-radius-sm: 6px;
            --control-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.02);
            --control-height: 26px;
            --control-padding: 3px 8px;
            --control-font: 11px;
            --text: #e8f0f6;
            --muted: #95a3b3;
            --accent: #20d3c1;
            --accent-2: #51f3db;
            --danger: #ff5c7c;
            --shadow: rgba(0, 0, 0, 0.45);
            --ui-scale: 1;
        }

        /* --- DIZ√ÅJN --- */
        html, body {
            margin: 0;
            padding: 0;
            background:
                radial-gradient(900px 500px at 18% -10%, rgba(35, 215, 181, 0.12), transparent 60%),
                radial-gradient(800px 420px at 85% 20%, rgba(94, 234, 212, 0.08), transparent 55%),
                var(--bg-0);
            color: var(--text);
            font-family: 'Space Grotesk', 'Segoe UI', sans-serif;
            height: 100dvh;
            width: 100%;
            min-width: 100%;
            display: flex;
            overflow-x: hidden; /* v√≠zszintes √∫szk√°l√°s tilt√°sa */
            overflow-y: hidden;
            padding-bottom: env(safe-area-inset-bottom);
            overscroll-behavior: none;
            touch-action: pan-y;
            flex: 1 1 auto;
        }

        .container {
            display: flex;
            width: 100%;
            height: 100dvh;
            min-height: 0;
            overflow-x: hidden;
            flex: 1 1 auto;
            align-self: stretch;
        }

        .panel {
            padding: 8px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            gap: 5px;
            overflow-y: auto;
            overflow-x: hidden;
            min-height: 0; /* fontos, hogy mobilon g√∂rgethet≈ë maradjon */
            -webkit-overflow-scrolling: touch;
            background: var(--panel);
            min-width: 0;
        }

        .left-panel {
            width: 28%;
            background: linear-gradient(180deg, var(--panel), var(--panel-2));
            border-right: 1px solid var(--border);
            z-index: 2;
            box-shadow: 5px 0 18px var(--shadow);
            padding-bottom: calc(10px + env(safe-area-inset-bottom));
        }

        .center-panel {
            width: 44%;
            background: var(--bg-1);
            align-items: center;
            justify-content: center;
            position: relative;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            padding-bottom: 10px;
        }

        .right-panel {
            width: 28%;
            background: linear-gradient(180deg, var(--panel), var(--panel-2));
            border-left: 1px solid var(--border);
        }

        .app-header {
            font-size: 17px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 2.5px;
            margin-bottom: 8px;
            text-align: center;
            color: var(--text);
            text-shadow: 0 8px 22px rgba(0, 0, 0, 0.35);
        }

        h3 {
            margin: 0 0 4px 0;
            color: var(--accent);
            border-bottom: 1px solid var(--border);
            padding-bottom: 4px;
            text-transform: uppercase;
            font-size: 11px;
            letter-spacing: 1px;
        }

        label {
            font-size: 10px;
            color: var(--muted);
            text-transform: uppercase;
            margin-top: 2px;
            display: block;
            font-weight: 600;
        }

        .field-stack {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .checkbox-label {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            color: var(--muted);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.6px;
            font-size: 10px;
        }

        .checkbox-label input[type="checkbox"] {
            width: auto;
            min-height: auto;
            margin: 0;
        }

        .inline-row {
            display: flex;
            gap: 6px;
            align-items: center;
        }

        .inline-row input[type="file"] {
            flex: 1 1 auto;
        }

        .btn-clear {
            width: auto;
            padding: 5px 8px;
            background: transparent;
            border: 1px solid var(--border);
            color: var(--muted);
            border-radius: var(--control-radius-sm);
            cursor: pointer;
            font-weight: 700;
        }

        .date-offset-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
        }

        .date-offset-item {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .date-offset-head {
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-size: 9px;
            color: var(--muted);
            text-transform: uppercase;
            letter-spacing: 0.6px;
        }

        input,
        select {
            width: 100%;
            padding: var(--control-padding);
            background: var(--control-bg);
            border: 1px solid var(--control-border);
            color: var(--text);
            border-radius: var(--control-radius);
            box-sizing: border-box;
            margin-bottom: 3px;
            font-size: var(--control-font);
            font-family: inherit;
            min-height: var(--control-height);
            height: var(--control-height);
            box-shadow: var(--control-shadow);
            transition: border-color 0.15s ease, background 0.15s ease, transform 0.05s ease, box-shadow 0.15s ease;

            /* Android/Samsung dark mode fix */
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            color-scheme: dark;
        }

        /* Select ny√≠l (Android custom) */
        select {
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="12" height="8" viewBox="0 0 12 8"><path fill="%2395a3b3" d="M1 1l5 5 5-5"/></svg>');
            background-repeat: no-repeat;
            background-position: right 8px center;
            background-size: 10px;
            padding-right: 24px;
        }

        /* Select option elemek (Android dropdown fix) */
        select option {
            background: var(--control-bg);
            color: var(--text);
            padding: 8px;
            font-size: var(--control-font);
        }

        button {
            width: 100%;
            padding: var(--control-padding);
            background: var(--control-bg);
            border: 1px solid var(--control-border);
            color: var(--text);
            border-radius: var(--control-radius);
            box-sizing: border-box;
            margin-bottom: 3px;
            font-size: var(--control-font);
            font-family: inherit;
            min-height: var(--control-height);
            box-shadow: var(--control-shadow);
            transition: border-color 0.15s ease, background 0.15s ease, transform 0.05s ease, box-shadow 0.15s ease;
        }

        input[type="number"] {
            line-height: 1;
            appearance: textfield;
            -moz-appearance: textfield;
        }

        input[type="number"]::-webkit-outer-spin-button,
        input[type="number"]::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        input:focus,
        select:focus,
        button:focus {
            outline: none;
            border-color: rgba(35, 215, 181, 0.6);
            box-shadow: 0 0 0 2px rgba(35, 215, 181, 0.12);
        }

        button:hover {
            background: var(--control-bg-hover);
        }

        button:active {
            transform: translateY(1px);
        }

        /* A range (cs√∫szka) input ne √∂r√∂k√∂lje az √°ltal√°nos paddinget */
        input[type="range"] {
            padding: 0 !important;
            height: 18px;
            border-radius: 999px;
            background: transparent;
            border: none;
            box-sizing: border-box;
            appearance: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-runnable-track {
            height: 6px;
            background: #0f1722;
            border-radius: 999px;
            border: 1px solid var(--control-border);
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--accent);
            border: 2px solid #0b121a;
            margin-top: -6px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.45);
        }

        input[type="range"]::-moz-range-track {
            height: 6px;
            background: #0f1722;
            border-radius: 999px;
            border: 1px solid var(--control-border);
        }

        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--accent);
            border: 2px solid #0b121a;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.45);
        }

        /* M√ìDV√ÅLT√ì */
        .mode-switch {
            display: flex;
            gap: 6px;
            margin-bottom: 6px;
            background: #121926;
            padding: 3px;
            border-radius: var(--control-radius);
            border: 1px solid var(--control-border);
        }

        .mode-btn {
            flex: 1;
            border: none;
            background: transparent;
            color: var(--muted);
            cursor: pointer;
            padding: 6px;
            font-weight: 700;
        }

        .mode-btn.active {
            background: linear-gradient(135deg, var(--accent), #18b79a);
            color: #051418;
            border-radius: var(--control-radius-sm);
        }

        /* H√öZD IDE */
        #dropZone {
            border: 2px dashed #2c394a;
            background: #0f141d;
            color: var(--muted);
            height: 150px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            cursor: pointer;
            transition: 0.2s;
            margin-top: 10px;
        }

        #dropZone:hover {
            border-color: var(--accent);
            background: #141c26;
            color: var(--text);
        }

        #dropZone.dragover {
            border-color: var(--accent);
            background: #1a2431;
        }

        /* VIDE√ì */
        #videoContainer {
            position: relative;
            width: 100%;
            height: auto;
            aspect-ratio: 16 / 9;
            /* alap: fekv≈ë kont√©ner */
            max-height: 55dvh;
            background: #0a0f14;
            border: none;
            box-shadow: inset 0 0 0 2px var(--border);
            overflow: hidden;
            border-radius: 12px;
            will-change: transform;
            margin: 0 auto;
        }

        #videoContainer video,
        #videoContainer canvas,
        #videoContainer img {
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: #000;
        }

        /* A PNG alpha legyen √°tl√°tsz√≥ a vide√≥/canvas felett (ne legyen fekete h√°tt√©r) */
        #overlayImg {
            background: transparent !important;
        }

        #videoContainer canvas,
        #videoContainer img {
            object-fit: cover;
        }

        #videoContainer video {
            object-fit: cover;
        }

        #statusBadge {
            position: absolute;
            top: 15px;
            right: 15px;
            padding: 6px 12px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 999px;
            font-size: 11px;
            color: var(--accent);
            z-index: 5;
            border: 1px solid var(--border);
            text-transform: uppercase;
            font-weight: bold;
        }

        #progressBarContainer {
            width: 100%;
            height: 4px;
            background: #101720;
            margin-top: 15px;
            border-radius: 2px;
            display: none;
            overflow: hidden;
        }

        #progressBar {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, var(--accent), var(--accent-2));
            transition: width 0.2s;
        }

        .btn-start {
            background: linear-gradient(135deg, var(--accent), #149e86);
            color: #fff;
            height: 44px;
            font-size: 14px;
            border: none;
            margin-top: 10px;
            font-weight: bold;
            cursor: pointer;
            border-radius: var(--control-radius);
        }

        .btn-start:hover {
            background: linear-gradient(135deg, #ff5c7c, #ff2d55);
        }

        .btn-projector {
            background: var(--control-bg);
            color: #fff;
            border: 1px solid var(--control-border);
            cursor: pointer;
            font-weight: 700;
        }

        .scroll-area {
            max-height: 150px;
            overflow-y: auto;
            overflow-x: hidden;
            border: 1px solid var(--control-border);
            background: #0c121a;
            padding: 4px;
            border-radius: var(--control-radius);
        }

        #effectsList.scroll-area {
            height: clamp(120px, 18dvh, 200px);
            max-height: clamp(120px, 18dvh, 200px);
            min-height: 120px;
            display: block;
        }

        .effect-item {
            font-size: 11px;
            padding: 5px 6px;
            border-bottom: 1px solid #1b2430;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
        }

        /* EFFEKTEK */
        .eff-compact {
            display: flex;
            flex-direction: column;
            gap: 8px;
            width: 100%;
        }

        .eff-toprow {
            display: grid;
            grid-template-columns: clamp(72px, 10vw, 92px) minmax(0, 1fr) clamp(56px, 10vw, 84px);
            grid-template-areas:
                "tlabel tslider tval"
                "slabel sslider sval";
            column-gap: 12px;
            row-gap: 10px;
            align-items: center;
            width: 100%;
            max-width: 100%;
            overflow: hidden;
        }

        .eff-label {
            font-size: 10px;
            color: var(--muted);
            text-transform: uppercase;
            font-weight: 700;
            margin: 0;
            white-space: nowrap;
            letter-spacing: 0.8px;
            line-height: 1;
        }

        .eff-value {
            font-size: 11px;
            color: var(--accent);
            font-weight: 800;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            line-height: 1;
            font-size: clamp(11px, 1.1vw, 12px);
            justify-self: end;
            text-align: right;
            min-width: 0;
        }

        .eff-slider {
            width: 100%; max-width: 100%;
            margin: 0;
            padding: 0;
            height: 18px;
            min-width: 0;
            max-width: 100%;
            box-sizing: border-box;
        }

        .eff-divider {
            width: 1px;
            height: 18px;
            background: #263244;
            justify-self: center;
            border-radius: 1px;
            display: none; /* alapb√≥l rejtve: iPad-en ne jelenjen meg √°rva cs√≠k */
        }

        /* grid-area k√∂t√©s a k√©t soros eff-toprow-hoz */
        .eff-time-label  { grid-area: tlabel; }
        .eff-time-slider { grid-area: tslider; }
        .eff-time-value  { grid-area: tval; }
        .eff-speed-label { grid-area: slabel; }
        .eff-speed-slider{ grid-area: sslider; }
        .eff-speed-value { grid-area: sval; }

        .eff-bottomrow {
            display: flex;
            justify-content: space-between;
            gap: 10px;
            flex-wrap: wrap;
            width: 100%;
        }

        .eff-preset {
            display: flex;
            gap: 6px;
            align-items: center;
            flex-wrap: wrap;
        }

        .eff-preset button {
            width: auto;
            padding: 5px 8px;
            background: var(--control-bg);
            border: 1px solid var(--control-border);
            border-radius: var(--control-radius-sm);
            cursor: pointer;
            font-weight: 800;
            color: var(--text);
            font-size: 10.5px;
            line-height: 1;
        }

        .eff-preset button.active {
            background: var(--accent);
            color: #071216;
            border: none;
        }

        .eff-actions {
            display: flex;
            gap: 6px;
            align-items: center;
            flex-wrap: wrap;
        }

        .eff-actions button {
            width: auto;
            padding: 6px 10px;
            font-size: 10.5px;
            margin: 0;
            white-space: nowrap;
            border-radius: var(--control-radius-sm);
        }

        .signal-info {
            border: 1px solid var(--border);
            background: #0f141d;
            border-radius: 8px;
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 6px;
            font-size: 11px;
        }

        .signal-head {
            color: var(--accent);
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.8px;
        }

        .signal-row {
            display: flex;
            justify-content: space-between;
            gap: 8px;
            color: var(--muted);
        }

        .signal-row span:last-child {
            color: var(--text);
            font-weight: 600;
        }

        .fold {
            border: 1px solid var(--border);
            background: #0f141d;
            border-radius: 8px;
            padding: 6px 8px;
        }

        .fold summary {
            list-style: none;
            cursor: pointer;
            font-size: 11px;
            text-transform: uppercase;
            color: var(--muted);
            font-weight: 700;
            letter-spacing: 0.7px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .fold summary::-webkit-details-marker {
            display: none;
        }

        .fold .fold-body {
            margin-top: 6px;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .ramp-presets {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            margin-top: 4px;
        }

        .ramp-presets button {
            width: auto;
            padding: 5px 8px;
            font-size: 10.5px;
            border-radius: var(--control-radius-sm);
            background: var(--control-bg);
            border: 1px solid var(--control-border);
            color: var(--text);
            font-weight: 700;
            cursor: pointer;
        }

        .ramp-presets button.active {
            background: var(--accent);
            color: #071216;
            border: none;
        }

        /* Sz≈±kebb n√©zet: a k√©t sor marad, csak a fels≈ë grid t√∂rik */
        @media (max-width: 1100px) {
            .eff-toprow {
                column-gap: 10px;
                row-gap: 10px;
            }
        }

        /* Telefon / keskeny panel: minden egym√°s al√°, c√≠mke + √©rt√©k egy sorban */
        @media (max-width: 700px) {
            .eff-toprow {
                grid-template-columns: 1fr;
                grid-template-areas:
                    "tlabel"
                    "tslider"
                    "tval"
                    "slabel"
                    "sslider"
                    "sval";
            }

            .eff-divider {
                display: none;
            }
        }
        @media (min-width: 2000px) {
            .eff-toprow {
                grid-template-columns:
                    clamp(72px, 8vw, 92px) minmax(0, 1fr) clamp(56px, 8vw, 84px)
                    12px
                    clamp(72px, 8vw, 92px) minmax(0, 1fr) clamp(56px, 8vw, 84px);
                grid-template-areas: "tlabel tslider tval divider slabel sslider sval";
            }
            .eff-divider {
                display: block;
                grid-area: divider;
            }
        }

        /* Extra sz≈±k: kisebb gap √©s bet≈± */
        @media (max-width: 420px) {
            .eff-compact {
                gap: 8px;
            }
            .eff-toprow {
                row-gap: 8px;
            }
            .eff-label {
                font-size: 10px;
            }
        }

        /* Mobil / tablet (iPad/iPhone): panelek egym√°s alatt √°ll√≥ m√≥dban */
        @media (max-width: 1024px) and (orientation: portrait) {
            :root {
                --ui-scale: 1;
            }

            body {
                overflow-y: auto;
                overflow-x: hidden;
            }

            .container {
                display: grid;
                grid-template-columns: 1fr 1fr;
                grid-template-rows: auto 1fr;
                gap: 12px;
                padding: 10px;
                height: auto;
                min-height: 100dvh;
                transform: none;
                width: 100%;
            }

            .left-panel,
            .center-panel,
            .right-panel {
                width: 100%;
            }

            /* Vide√≥ el≈ën√©zet fel√ºl, majd Branding/M√©dia, majd Effektek */
            .center-panel {
                order: 0;
                grid-column: 1 / -1;
                align-items: stretch;
            }
            .left-panel {
                order: 1;
                grid-column: 1;
            }
            .right-panel {
                order: 2;
                grid-column: 2;
            }

            /* iOS/Safari flex+scroll stabiliz√°l√°s */
            .panel {
                min-height: 0;
                padding: 14px;
                gap: 10px;
            }

            /* Effektek: iPad √°ll√≥ m√≥dban ne l√≥gjon ki semmi, √©s legyen mindig l√°that√≥ az id≈ës√°v */
            .eff-divider { display: none; }

            .eff-bottomrow {
                flex-wrap: nowrap;
                align-items: center;
                justify-content: space-between;
                gap: 8px;
            }
            .eff-preset,
            .eff-actions {
                flex-wrap: nowrap;
                gap: 6px;
            }
            .eff-actions button,
            .eff-preset button {
                padding: 7px 9px;
                font-size: 12px;
            }

            #effectsTimeline {
                min-height: 34px;
                height: 34px;
                flex: 0 0 auto;
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }

            #effectsList.scroll-area {
                max-height: 32dvh;
                min-height: 140px;
                overflow-y: auto;
                height: 32dvh;
            }
        }

        /* iPad / tablet fekv≈ë: 2 oszlopos grid, el≈ën√©zet bal fent, branding alatta, vez√©rl≈ëk jobbra */
        @media (max-width: 1366px) and (orientation: landscape) {
            body {
                overflow-y: auto;
                overflow-x: hidden;
            }

            .container {
                display: grid;
                grid-template-columns: minmax(0, 1fr) 360px;
                grid-template-rows: auto 1fr;
                gap: 12px;
                padding: 10px;
                height: auto;
                min-height: 100dvh;
            }

            .center-panel {
                grid-column: 1;
                grid-row: 1;
                align-items: stretch;
                width: auto;
            }

            .left-panel {
                grid-column: 1;
                grid-row: 2;
                width: auto;
            }

            .right-panel {
                grid-column: 2;
                grid-row: 1 / span 2;
                width: auto;
            }

            .panel {
                padding: 14px;
                gap: 10px;
            }

            .app-header {
                font-size: 20px;
                margin-bottom: 14px;
            }

            .btn-start {
                height: 54px;
                font-size: 17px;
            }

            /* Effektek: a f√ºgg≈ëleges elv√°laszt√≥ ne jelenjen meg ezen a m√©reten (cs√≠k bug) */
            .eff-divider { display: none; }

            /* iPad-on a hossz√∫ list√°k legyenek g√∂rgethet≈ëk a panelen bel√ºl */
            #effectsTimeline {
                min-height: 34px;
                height: 34px;
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }

            #effectsList.scroll-area {
                max-height: 28dvh;
                min-height: 140px;
                overflow-y: auto;
                height: 28dvh;
            }

            /* Gombok egy sorban maradjanak */
            .eff-bottomrow {
                flex-wrap: nowrap;
                align-items: center;
                justify-content: space-between;
                gap: 8px;
            }
            .eff-preset,
            .eff-actions {
                flex-wrap: nowrap;
                gap: 6px;
            }
        }

        @media (max-height: 800px) {
            #effectsList.scroll-area {
                height: clamp(110px, 16dvh, 170px);
                max-height: clamp(110px, 16dvh, 170px);
                min-height: 110px;
            }
        }

        @media (max-height: 900px) {
            
        }

        /* iPad Safari √°ll√≥ m√≥d / r√∂vid viewport: alacsony magass√°gn√°l egym√°s al√° rendez√©s */
        @media (max-width: 1024px) and (max-height: 720px) {
            :root {
                --ui-scale: 1;
            }

            body {
                overflow-y: auto;
                overflow-x: hidden;
            }

            .container {
                display: grid;
                grid-template-columns: 1fr;
                grid-template-rows: auto auto auto;
                gap: 10px;
                padding: 10px;
                height: auto;
                min-height: 100dvh;
                transform: none;
                width: 100%;
            }

            .center-panel,
            .left-panel,
            .right-panel {
                width: 100%;
            }

            .center-panel { order: 0; }
            .right-panel { order: 1; }
            .left-panel { order: 2; }

            .panel {
                padding: 12px;
                gap: 8px;
            }

            .app-header {
                font-size: 18px;
                margin-bottom: 10px;
            }

            #videoContainer {
                max-height: 32dvh;
            }

            #effectsList.scroll-area {
                max-height: 28dvh;
                height: 28dvh;
            }
        }

        /* Telefon fekv≈ë: 3 oszlop, mindh√°rom panel g√∂rgethet≈ë, gomb ragad */
        @media (max-width: 900px) and (orientation: landscape) {
            body {
                overflow: hidden;
            }

            .container {
                display: flex;
                flex-direction: row;
                height: 100dvh;
                gap: 8px;
                padding: 8px;
            }

            .left-panel,
            .center-panel,
            .right-panel {
                height: 100%;
                width: 33.33%;
            }

            .panel {
                padding: 10px;
                gap: 8px;
                overflow-y: auto;
            }

            .app-header {
                font-size: 16px;
                margin-bottom: 8px;
            }

            #videoContainer {
                max-height: 48dvh;
            }

            input,
            select,
            button {
                padding: 7px;
                font-size: 12px;
            }

            .btn-start {
                height: 46px;
                font-size: 15px;
                position: sticky;
                bottom: 8px;
                z-index: 3;
            }
        }

        /* Kisebb mobilon m√©g kompaktabb */
        @media (max-width: 700px) {
            .container {
                grid-template-columns: 1fr;
                grid-template-rows: auto auto auto;
                gap: 10px;
            }

            .center-panel,
            .left-panel,
            .right-panel {
                grid-column: 1;
            }

            .panel {
                padding: 12px;
                gap: 8px;
            }

            .app-header {
                font-size: 18px;
                margin-bottom: 10px;
            }

            h3 {
                font-size: 11px;
            }

            label {
                font-size: 10px;
            }

            input,
            select,
            button {
                padding: 7px 9px;
                font-size: 11.5px;
            }

            .btn-start {
                height: 46px;
                font-size: 15px;
            }

            #videoContainer {
                max-height: 30dvh;
                border-radius: 10px;
            }

            #effectsList.scroll-area {
                max-height: 28dvh;
                height: 28dvh;
            }
        }
        /* Effektek id≈ës√°v ‚Äì gyors √°tl√°t√°s */
        #effectsTimeline {
            height: 34px;
            display: flex;
            width: 100%;
            min-width: 0;
            -webkit-overflow-scrolling: touch;
            border: 1px solid var(--border);
            border-radius: 8px;
            background: #0c121a;
            margin-top: 10px;
        }

        .eff-seg {
            display: flex;
            flex: 0 0 auto;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            letter-spacing: 0.3px;
            cursor: pointer;
            user-select: none;
            border-right: 1px solid #1b2430;
            color: #ddd;
            padding: 0 6px;
            min-width: 18px;
        }

        .eff-seg:last-child {
            border-right: none;
        }

        .eff-seg.slow {
            background: rgba(35, 215, 181, 0.18);
        }

        .eff-seg.norm {
            background: rgba(255, 255, 255, 0.06);
        }

        .eff-seg.fast {
            background: rgba(94, 234, 212, 0.18);
        }

        .eff-seg.selected {
            outline: 2px solid var(--accent);
            outline-offset: -2px;
        }

        /* Kijel√∂lhet≈ë lista sor */
        .effect-item.selectable {
            cursor: pointer;
        }

        .effect-item.selectable.selected {
            background: rgba(35, 215, 181, 0.10);
        }

        .eff-del {
            width: auto;
            padding: 6px 8px;
            background: transparent;
            border: 1px solid var(--border);
            color: var(--muted);
            border-radius: 6px;
            cursor: pointer;
            font-size: 11px;
        }

        #effectsSummary {
            font-size: 11px;
            color: var(--muted);
            margin-top: 6px;
            line-height: 1.25;
        }

        /* Utols√≥ kimenet (k√©sz vide√≥) ‚Äì ne nyomja √∂ssze az el≈ën√©zetet, ne legyen t√∫l nagy √°ll√≥ m√≥dban */
        #lastOutput {
            width: 100%;
            max-width: 100%;
            margin-left: auto;
            margin-right: auto;
            align-self: center;
            /* NE stretch: ne h√∫zza sz√©t a dobozt */
        }

        /* A be√©p√≠tett vide√≥-el≈ën√©zet sok b√∂ng√©sz≈ëben (k√ºl√∂n√∂sen √°ll√≥ m√≥dban) sz√©tveri a layoutot.
           A vide√≥ √≠gy is automatikusan let√∂lt≈ëdik, a gombok megmaradnak. */
        #lastOutputVideo {
            display: none;
        }

        #lastOutput video {
            max-height: 34dvh;
        }

        /* √Åll√≥ m√≥dban a player t√∫l magas lenne (9:16) ‚Äì korl√°tozzuk */
        body[data-aspect="portrait"] #lastOutput video {
            max-height: 28dvh;
        }

        /* Ha sz≈±k a viewport, m√©g agressz√≠vebb limit */
        @media (max-height: 800px) {
            #lastOutput video {
                max-height: 28dvh;
            }

            body[data-aspect="portrait"] #lastOutput video {
                max-height: 24dvh;
            }
        }

        /* √Åll√≥ m√≥dban a videoContainer sokkal kisebb helyet foglaljon */
    </style>
</head>

<body>

    <div class="container">
        <!-- BAL PANEL -->
        <div class="panel left-panel">
            <h3>1. Branding & Kijelz≈ë</h3>
            <label>Esem√©ny Neve</label>
            <input type="text" id="brandTitleInput" placeholder="Pl: Moln√°r Esk√ºv≈ë" oninput="updateBranding()">
            <label>Log√≥ (PNG)</label>
            <input type="file" id="logoInput" accept="image/png" onchange="updateLogo()">
            <button class="btn-projector" onclick="openProjectorWindow()">üñ•Ô∏è Kivet√≠t≈ë Nyit√°sa</button>

            <hr style="border-color:#333; width:100%; margin:10px 0;">

            <h3>2. M√©dia elemek</h3>
            <label>Overlay Keret</label>
            <div class="inline-row">
                <input type="file" id="overlayFile" accept="image/png" onchange="loadOverlay(this)">
                <button class="btn-clear" type="button" onclick="clearOverlay()">X</button>
            </div>
            <label>Zene (.mp3)</label>
            <input type="file" id="musicFile" accept="audio/*,.mp3,.m4a,.aac,.wav,.ogg">
            <label style="margin-top:10px; display:flex; align-items:center;">
                <input type="checkbox" id="dateOverlay" style="width:auto; margin-right:8px;"> D√°tum overlay
            </label>
            <label>D√°tum poz√≠ci√≥</label>
            <select id="dateOverlayPos" onchange="updateDateOverlayPreview()">
                <option value="br" selected>Jobb als√≥</option>
                <option value="bl">Bal als√≥</option>
                <option value="tr">Jobb fels≈ë</option>
                <option value="tl">Bal fels≈ë</option>
            </select>
            <div class="date-offset-row">
                <div class="date-offset-item">
                    <div class="date-offset-head">
                        <span>X offset</span>
                        <span id="dateOverlayOffsetXVal">18</span>
                    </div>
                    <input type="range" id="dateOverlayOffsetX" min="0" max="240" step="2" value="18" oninput="updateDateOverlayPreview()">
                </div>
                <div class="date-offset-item">
                    <div class="date-offset-head">
                        <span>Y offset</span>
                        <span id="dateOverlayOffsetYVal">18</span>
                    </div>
                    <input type="range" id="dateOverlayOffsetY" min="0" max="240" step="2" value="18" oninput="updateDateOverlayPreview()">
                </div>
            </div>
        </div>

        <!-- K√ñZ√âP PANEL -->
        <div class="panel center-panel">
            <div class="app-header">360 selfie - KANDO BOOTH</div>

            <div id="videoContainer">
                <!-- √âl≈ëk√©p (csak webkamera m√≥dban) -->
                <video id="liveVideo" autoplay muted playsinline></video>
                <!-- Lej√°tsz√°s (F√°jl m√≥dban √©s renderel√©skor) -->
                <video id="rawPlayback" style="display:none;" muted playsinline></video>
                <canvas id="renderCanvas" width="1280" height="720" style="display:none;"></canvas>
                <img id="overlayImg" style="display:none;">
                <div id="statusBadge">K√âSZENL√âT</div>

            </div>

            <div id="lastOutput" style="display:none; margin-top:12px; align-self:center;">
                <div
                    style="background:rgba(0,0,0,0.75); border:1px solid #333; border-radius:10px; padding:10px; display:flex; flex-direction:column; gap:10px; align-items:stretch;">
                    <video id="lastOutputVideo" controls playsinline muted
                        style="width:100%; height:auto; aspect-ratio:16/9; object-fit:cover; border-radius:8px; border:1px solid #333;"></video>
                    <div style="flex:1; min-width:0;">
                        <div
                            style="font-size:12px; color:#03dac6; font-weight:800; letter-spacing:1px; text-transform:uppercase;">
                            Utols√≥ vide√≥</div>
                        <div id="lastOutputInfo" style="font-size:11px; color:#aaa; margin-top:4px;">Megtekinthet≈ë
                            itt is, ha a rendszer nem nyitja meg.</div>
                        <div style="display:flex; gap:8px; margin-top:8px; flex-wrap:wrap;">
                            <button id="btnOpenLast"
                                style="width:auto; padding:8px 10px; background:#252525; border:1px solid #333; border-radius:6px; cursor:pointer;">Megnyit√°s
                                √∫j lapon</button>
                            <button id="btnDownloadLast"
                                style="width:auto; padding:8px 10px; background:#03dac6; color:#000; border:none; border-radius:6px; cursor:pointer; font-weight:800;">Let√∂lt√©s</button>
                            <button id="btnHideLast"
                                style="width:auto; padding:8px 10px; background:transparent; border:1px solid #333; color:#aaa; border-radius:6px; cursor:pointer;">Elrejt</button>
                        </div>
                        <div style="font-size:10px; color:#666; margin-top:6px;">MP4-hez szerveres konvert (FFmpeg)
                            aj√°nlott; b√∂ng√©sz≈ëben nem garant√°lt a k√∂zvetlen MP4 r√∂gz√≠t√©s.</div>
                    </div>
                </div>
            </div>

            <div id="progressBarContainer">
                <div id="progressBar"></div>
            </div>
            <p id="processText" style="color:#aaa; font-size:11px; margin-top:5px; text-align:center; height:15px;"></p>
        </div>

        <!-- JOBB PANEL -->
        <div class="panel right-panel">
            <h3>3. M≈±k√∂d√©si M√≥d</h3>
            <div class="mode-switch">
                <button class="mode-btn active" id="btnModeCam" onclick="setMode('cam')">Kamera ind√≠t√°s</button>
                <button class="mode-btn" id="btnModeFile" onclick="setMode('file')">F√°jl Import</button>
            </div>

            <div id="camControls">
                <label>Kamera Forr√°s</label>
                <select id="camSelect" onchange="startCamera()">
                    <option>Bet√∂lt√©s...</option>
                </select>

                <div id="orientationModeContainer">
                    <!-- Desktop: manu√°lis v√°laszt√≥, Mobil/Tablet: auto info -->
                </div>

                <div style="padding: 8px; background: rgba(32, 211, 193, 0.1); border: 1px solid rgba(32, 211, 193, 0.3); border-radius: 6px; font-size: 10px; color: var(--accent-2); margin: 4px 0;">
                    ‚ÑπÔ∏è A kamera nat√≠v felbont√°sa, k√©par√°nya √©s FPS √©rt√©ke ker√ºl haszn√°latra a legjobb min≈ës√©g √©rdek√©ben
                </div>

                <label>Overlay illeszt√©s</label>
                <select id="overlayFit" onchange="applyOverlayFitFromUI()">
                    <option value="stretch" selected>Sz√©lekhez h√∫z (stretch)</option>
                    <option value="cover">Kit√∂lt (crop) (cover)</option>
                    <option value="contain">Teljes k√©p (contain)</option>
                </select>

                <label>Start k√©sleltet√©s (mp)</label>
                <input type="number" id="recordDelay" value="0" min="0" max="30" step="1" oninput="applyStartDelayFromUI()">

                <div class="field-stack">
                    <label class="checkbox-label">
                        <input type="checkbox" id="autoStopEnabled" onchange="applyAutoStopFromUI()" checked>
                        Auto stop (mp)
                    </label>
                    <input type="number" id="autoStopSec" value="10" min="5" max="120" step="1" oninput="applyAutoStopFromUI()">
                </div>

                <details class="fold" id="advancedCameraSettings">
                    <summary>Speci√°lis be√°ll√≠t√°sok</summary>
                    <div class="fold-body">
                        <label>Forr√°s forgat√°s</label>
                        <select id="sourceRotate" onchange="applySourceRotateFromUI()">
                            <option value="0" selected>0¬∞ (nincs)</option>
                            <option value="90">90¬∞ (√°ll√≥ ‚Äì balra)</option>
                            <option value="270">270¬∞ (√°ll√≥ ‚Äì jobbra)</option>
                        </select>

                        <label>Forr√°s v√°g√°s (%)</label>
                        <div class="date-offset-row">
                            <div class="date-offset-item">
                                <div class="date-offset-head">
                                    <span>Fel√ºl</span>
                                    <span id="sourceCropTopVal">0</span>
                                </div>
                                <input type="range" id="sourceCropTop" min="0" max="20" step="1" value="0" oninput="applySourceCropFromUI()">
                            </div>
                            <div class="date-offset-item">
                                <div class="date-offset-head">
                                    <span>Alul</span>
                                    <span id="sourceCropBottomVal">0</span>
                                </div>
                                <input type="range" id="sourceCropBottom" min="0" max="20" step="1" value="0" oninput="applySourceCropFromUI()">
                            </div>
                        </div>
                        <div class="date-offset-row">
                            <div class="date-offset-item">
                                <div class="date-offset-head">
                                    <span>Bal</span>
                                    <span id="sourceCropLeftVal">0</span>
                                </div>
                                <input type="range" id="sourceCropLeft" min="0" max="20" step="1" value="0" oninput="applySourceCropFromUI()">
                            </div>
                            <div class="date-offset-item">
                                <div class="date-offset-head">
                                    <span>Jobb</span>
                                    <span id="sourceCropRightVal">0</span>
                                </div>
                                <input type="range" id="sourceCropRight" min="0" max="20" step="1" value="0" oninput="applySourceCropFromUI()">
                            </div>
                        </div>

                        <label>Kamera felbont√°s</label>
                        <select id="cameraResolution" onchange="applyCameraResolutionFromUI()">
                            <option value="1280x720">1280√ó720 (HD)</option>
                            <option value="1920x1080" selected>1920√ó1080 (Full HD)</option>
                            <option value="2560x1440">2560√ó1440 (QHD)</option>
                            <option value="3840x2160">3840√ó2160 (4K)</option>
                        </select>

                        <label>Kamera FPS</label>
                        <select id="cameraFps" onchange="applyCameraFpsFromUI()">
                            <option value="24">24 fps</option>
                            <option value="30">30 fps</option>
                            <option value="60" selected>60 fps</option>
                        </select>

                        <label>El≈ën√©zet FPS</label>
                        <select id="previewFps" onchange="applyPreviewFpsFromUI()">
                            <option value="20">20 fps</option>
                            <option value="24">24 fps</option>
                            <option value="30" selected>30 fps</option>
                        </select>

                        <label>Min≈ës√©g</label>
                        <select id="qualityPreset" onchange="applyQualityFromUI()">
                            <option value="low">Alacsony (2.5 Mbps ‚Ä¢ 24 fps)</option>
                            <option value="med">K√∂zepes (5 Mbps ‚Ä¢ 30 fps)</option>
                            <option value="high" selected>Magas (8 Mbps ‚Ä¢ 30 fps)</option>
                        </select>

                        <label style="display:flex; align-items:center; gap:8px;">
                            <input type="checkbox" id="useSourceResolution" style="width:auto;" onchange="applyUseSourceResolutionFromUI()" checked>
                            Eredeti felbont√°s (max)
                        </label>

                        <label>Prefer√°lt form√°tum</label>
                        <select id="formatPref" onchange="applyFormatFromUI()">
                            <option value="auto" selected>Auto (b√∂ng√©sz≈ë d√∂nt)</option>
                            <option value="mp4">MP4 (ha t√°mogatott)</option>
                            <option value="webm">WebM</option>
                        </select>
                    </div>
                </details>

                <div class="signal-info">
                    <div class="signal-head">Bej√∂v≈ë jel</div>
                    <div class="signal-row"><span>Forr√°s</span><span id="signalSourceLabel">-</span></div>
                    <div class="signal-row"><span>Felbont√°s</span><span id="signalRes">-</span></div>
                    <div class="signal-row"><span>FPS (m√©rt)</span><span id="signalFps">-</span></div>
                    <details class="fold">
                        <summary>R√©szletek</summary>
                        <div class="fold-body">
                            <label>Info m√≥d</label>
                            <select id="signalSource" onchange="applySignalSourceFromUI()">
                                <option value="auto" selected>Automatikus</option>
                                <option value="live">Kamera / √©l≈ë</option>
                                <option value="file">F√°jl / lej√°tsz√°s</option>
                            </select>
                            <div class="signal-row"><span>FPS (be√°ll√≠t√°s)</span><span id="signalFpsTarget">-</span></div>
                        </div>
                    </details>
                </div>

                <button id="startBtn" class="btn-start" onclick="initiateCamSequence()">FELV√âTEL START</button>
            </div>

            <div id="fileControls" style="display:none;">
                <p style="font-size:12px; color:#aaa;">H√∫zd ide a GoPro vide√≥t, vagy kattints a dobozra a tall√≥z√°shoz.
                </p>

                <div id="dropZone" onclick="document.getElementById('videoInput').click()">
                    <span style="font-size:24px;">üìÇ</span>
                    <br>Kattints vagy H√∫zd ide<br>a vide√≥t
                </div>
                <input type="file" id="videoInput" accept="video/*" style="display:none;"
                    onchange="handleFileSelect(this)">

                <button id="processFileBtn" class="btn-start" style="background:#3700b3;" disabled>FELDOLGOZ√ÅS
                    START</button>
            </div>

            <hr style="border-color:#333; width:100%; margin:15px 0;">

            <h3>4. Effektek</h3>
            <label style="margin-top:4px; display:flex; align-items:center;">
                <input type="checkbox" id="autoRampMode" style="width:auto; margin-right:8px;"> Auto ramp (A m√≥d)
            </label>
            <div class="ramp-presets" role="group" aria-label="Ramp preset">
                <button type="button" data-ramp-preset="balanced">Balanced</button>
                <button type="button" data-ramp-preset="smooth">Smooth</button>
                <button type="button" data-ramp-preset="punch">Punch</button>
                <button type="button" data-ramp-preset="slowmo">SlowMo</button>
            </div>

            <div class="eff-compact">
                <div class="eff-toprow">
                    <div class="eff-label eff-time-label">Szakasz</div>
                    <input class="eff-slider eff-time-slider" type="range" id="effTimeSlider" min="0.5" max="10" step="0.5" value="2">
                    <div class="eff-value eff-time-value" id="effTimeVal">2.0 s</div>

                    <div class="eff-divider" aria-hidden="true"></div>

                    <div class="eff-label eff-speed-label">Seb.</div>
                    <input class="eff-slider eff-speed-slider" type="range" id="effSpeedSlider" min="0.25" max="3" step="0.05"
                        value="0.5">
                    <div class="eff-value eff-speed-value" id="effSpeedVal">0.5√ó</div>
                </div>

                <div class="eff-bottomrow">
                    <div class="eff-preset" aria-label="Sebess√©g preset">
                        <button type="button" id="btnSpeed05" onclick="setSpeedPreset(0.5)">0.5√ó</button>
                        <button type="button" id="btnSpeed10" onclick="setSpeedPreset(1.0)">1√ó</button>
                        <button type="button" id="btnSpeed20" onclick="setSpeedPreset(2.0)">2√ó</button>
                    </div>

                    <div class="eff-actions">
                        <button type="button" onclick="addEffect()" style="background:#333;">+ Szakasz</button>
                        <button type="button" onclick="clearEffects()"
                            style="background:transparent; border:1px solid #333; color:#aaa;">T√∂rl√©s</button>
                    </div>
                </div>
            </div>

            <div id="effectsTimeline"
                title="Kattints egy szegmensre: kijel√∂l√©s. A 'Friss√≠t' gomb a kijel√∂lt szakaszt √°t√≠rja a cs√∫szk√°k alapj√°n.">
            </div>
            <div class="scroll-area" id="effectsList" style="margin-top:8px;"></div>
            <div id="effectsSummary"></div>

            <label style="margin-top:10px; display:flex; align-items:center;">
                <input type="checkbox" id="boomerangMode" style="width:auto; margin-right:8px;"> Boomerang
            </label>
            <label style="margin-top:6px; display:flex; align-items:center;">
                <input type="checkbox" id="pingPongMode" style="width:auto; margin-right:8px;"> Oda-vissza (reverse)
            </label>
        </div>
    </div>
    <script>
        // --- V√ÅLTOZ√ìK ---
        let currentMode = 'cam'; // 'cam' vagy 'file'
        let projectorWin = null;
        let stream = null;
        let mediaRecorder = null;
        let chunks = [];
        let effects = [];
        let selectedEffectIndex = -1;
        let isProcessing = false;
        let rawVideoBlob = null;
        let rawVideoUrl = null;
        let currentLogoData = null;
        let autoRampEnabled = false;
        let currentRampPresetKey = 'balanced';
        let qualityPreset = 'high';
        let renderFps = 30;
        let videoBitsPerSecond = 8000000;
        let preferredFormat = 'auto';
        let cameraFps = 60;
        let previewFps = 30;
        let cameraWidth = 1280;
        let cameraHeight = 720;
        let useSourceResolution = true;
        let autoMaxCameraApplied = false;
        let sourceCropPct = { top: 0, right: 0, bottom: 0, left: 0 };
        let isRecording = false;
        let pendingStartRecord = false;
        let pendingStartTimer = 0;
        let recordStartMs = 0;
        let recordedDurationSec = 0;
        let startDelaySec = 0;
        let autoStopEnabled = false;
        let autoStopSec = 10;
        let autoStopTimer = 0;
        let signalSourceMode = 'auto';
        let signalInfoTimer = 0;
        let signalFpsValue = 0;
        let signalFpsFrames = 0;
        let signalFpsLastTs = 0;
        let signalFpsRafId = 0;
        let signalFpsVideoEl = null;
        let autoRampUserTouched = false;

        // Overlay bet√∂lt√©s √°llapot (stabil rajzol√°s + hibakeres√©s)
        let overlayReady = false;

        // Overlay PNG √°tl√°tsz√≥ perem lev√°g√°s (alpha bbox) ‚Äì hogy a keret t√©nyleg kifusson a sz√©lekig
        // { sx, sy, sw, sh } forr√°s-kiv√°g√°s a PNG-b≈ël
        let overlayCrop = null;

        // V√©gtelen onload ciklus megel≈ëz√©se az overlay k√©pkiv√°g√°sn√°l
        let overlayCroppedOnce = false;

        // Overlay illeszt√©s
        let overlayFitMode = 'stretch'; // 'stretch' | 'cover' | 'contain'

        // Kimenet k√©par√°ny kezel√©s
        let outputAspectMode = 'landscape'; // 'landscape' | 'portrait'
        let isAutoOrientationEnabled = false; // Mobil/tablet: auto, Desktop: manu√°lis

        // Detekt√°ljuk, hogy mobil/tablet vagy desktop
        function isMobileOrTablet() {
            const ua = navigator.userAgent || '';
            const isMobile = /iPhone|iPad|iPod|Android|webOS|BlackBerry|IEMobile|Opera Mini/i.test(ua);
            const isTouch = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
            return isMobile || isTouch;
        }

        // Forr√°s forgat√°s (NDI/telefon √°ll√≥ m√≥dhoz)
        let sourceRotateDeg = 0; // 0 | 90 | 270

        // Automatikus orient√°ci√≥ friss√≠t√©s (mobil/tablet)
        function updateOrientationFromViewport() {
            if (!isAutoOrientationEnabled) return;

            const isViewportPortrait = window.matchMedia('(orientation: portrait)').matches;
            const newMode = isViewportPortrait ? 'portrait' : 'landscape';

            if (outputAspectMode !== newMode) {
                outputAspectMode = newMode;
                console.log(`[AUTO-ORIENTATION] V√°lt√°s: ${outputAspectMode}`);

                // Friss√≠ts√ºk az UI-t √©s a canvas-t
                applyPreviewAspect();
                if (currentMode === 'cam') {
                    syncPreviewCanvasToMode(liveVideo);
                }
                applyLiveVideoTransform();
                updateDateOverlayPreview();
            }
        }

        // Orient√°ci√≥ change listener
        function setupOrientationListener() {
            const orientationMQ = window.matchMedia('(orientation: portrait)');

            // Modern b√∂ng√©sz≈ëk
            if (orientationMQ.addEventListener) {
                orientationMQ.addEventListener('change', updateOrientationFromViewport);
            } else if (orientationMQ.addListener) {
                // R√©gi Safari
                orientationMQ.addListener(updateOrientationFromViewport);
            }

            // Fallback: window.orientationchange (iOS legacy)
            window.addEventListener('orientationchange', () => {
                setTimeout(updateOrientationFromViewport, 100);
            });

            // Fallback: window resize
            window.addEventListener('resize', () => {
                if (isAutoOrientationEnabled) {
                    setTimeout(updateOrientationFromViewport, 100);
                }
            });
        }

        // Forgat√°s: user be√°ll√≠t√°s VAGY automatikus orient√°ci√≥ swap
        function getEffectiveRotateDeg(videoEl) {
            // Explicit user be√°ll√≠t√°s (0, 90, vagy 270)
            const forced = sourceRotateDeg || 0;
            if (forced === 90 || forced === 270) return forced;

            // Automatikus forgat√°s ha az outputAspectMode swap-et okoz
            const v = videoEl || liveVideo || rawPlayback;
            const vw = (v && v.videoWidth) ? v.videoWidth : 0;
            const vh = (v && v.videoHeight) ? v.videoHeight : 0;

            if (vw > 0 && vh > 0) {
                const sourceIsPortrait = vh > vw;
                const wantPortrait = (outputAspectMode === 'portrait');

                // Ha swap kell, forgassuk 270¬∞-kal
                if (sourceIsPortrait !== wantPortrait) {
                    return 270;
                }
            }

            return 0;
        }

        
        // Helper: Max VH sz√°m√≠t√°s m√≥dhoz
        function getMaxVhForMode(portrait, viewportWidth, viewportHeight) {
            const isViewportPortrait = window.matchMedia('(orientation: portrait)').matches;

            if (portrait) {
                // √Åll√≥ kimenet (9:16)
                if (isViewportPortrait) {
                    // Viewport IS √°ll√≥, kimenet IS √°ll√≥ - t√∂k√©letes egyez√©s
                    if (viewportWidth <= 500) return 55;  // Kis mobil
                    if (viewportWidth <= 700) return 60;  // Nagyobb mobil
                    if (viewportWidth <= 1024) return 65; // Tablet
                    return 70;
                } else {
                    // Viewport fekv≈ë, DE kimenet √°ll√≥ - ritk√°bb eset
                    if (viewportWidth <= 900) return 40;
                    return 45;
                }
            } else {
                // Fekv≈ë kimenet (16:9)
                if (!isViewportPortrait) {
                    // Viewport IS fekv≈ë, kimenet IS fekv≈ë - t√∂k√©letes egyez√©s
                    if (viewportWidth <= 700) return 55;  // Kis mobil fekv≈ë
                    if (viewportWidth <= 900) return 60;  // Nagyobb mobil fekv≈ë
                    if (viewportWidth <= 1024) return 65; // Tablet fekv≈ë
                    return 70;
                } else {
                    // Viewport √°ll√≥, DE kimenet fekv≈ë - sz√©les s√°v kell
                    if (viewportWidth <= 500) return 35;  // Kis mobil
                    if (viewportWidth <= 700) return 40;  // Nagyobb mobil
                    if (viewportWidth <= 1024) return 45; // Tablet/iPad
                    return 55;
                }
            }
        }

        function applyPreviewAspect() {
            const vc = document.getElementById('videoContainer');
            if (!vc) return;

            const isViewportPortrait = window.matchMedia('(orientation: portrait)').matches;
            const viewportWidth = window.innerWidth || 0;
            const viewportHeight = window.innerHeight || 0;

            vc.style.transformOrigin = '50% 50%';
            vc.style.transform = 'none';

            // Haszn√°ljuk a canvas t√©nyleges ar√°ny√°t (ami a kamera nat√≠v ar√°nya)
            if (canvas && canvas.width && canvas.height) {
                const canvasAspect = canvas.width / canvas.height;
                const isCanvasPortrait = canvasAspect < 1;

                // Dinamikus maxVh √©rt√©k a kamera ar√°ny√°hoz
                const maxVh = getMaxVhForMode(isCanvasPortrait, viewportWidth, viewportHeight);

                vc.style.aspectRatio = `${canvas.width} / ${canvas.height}`;

                if (isCanvasPortrait) {
                    // √Åll√≥ kamera ar√°ny
                    vc.style.width = 'auto';
                    vc.style.height = `${maxVh}dvh`;
                    vc.style.maxHeight = `${maxVh}dvh`;
                    vc.style.maxWidth = '100%';
                } else {
                    // Fekv≈ë kamera ar√°ny
                    vc.style.width = '100%';
                    vc.style.height = 'auto';
                    vc.style.maxHeight = `${maxVh}dvh`;
                    vc.style.maxWidth = '100%';
                }
            }
            syncLastOutputWidth();
        }

        function applySourceRotateFromUI() {
            const sel = document.getElementById('sourceRotate');
            const v = sel ? parseInt(sel.value, 10) : 0;
            sourceRotateDeg = (v === 90 || v === 270) ? v : 0;

            // El≈ën√©zet keret + vide√≥ transzform friss√≠t√©se
            applyPreviewAspect();
            if (currentMode === 'cam') {
                syncPreviewCanvasToMode(liveVideo);
            }
            requestAnimationFrame(() => applyLiveVideoTransform());
            setTimeout(applyLiveVideoTransform, 0);
        }

        function applyLiveVideoTransform() {
            const vc = document.getElementById('videoContainer');
            if (!vc || !liveVideo) return;

            const eff = getEffectiveRotateDeg(liveVideo);
            const deg = ((eff % 360) + 360) % 360;

            // A liveVideo elemet nem CSS-sel m√©retezz√ºk/forgatjuk, mert abb√≥l j√∂n a zoom/kicsiny√≠t√©s.
            // A korrekt el≈ën√©zetet a canvas-ra rajzoljuk (drawLivePreviewLoop).
            liveVideo.style.transform = 'none';
            liveVideo.style.objectFit = 'cover';
            liveVideo.style.transformOrigin = '50% 50%';

            // A st√°tusz badge maradjon a kont√©nerben, nem forgatjuk.
            // A forgat√°s a canvas rajzol√°sn√°l t√∂rt√©nik.

            // Biztons√°g: ha valaki m√©gis bekapcsolja a liveVideo megjelen√≠t√©st, legal√°bb forogjon.
            if (liveVideo.style.display !== 'none' && deg !== 0) {
                liveVideo.style.transform = `rotate(${deg}deg)`;
            }
        }

        function pickSignalVideoEl() {
            if (signalSourceMode === 'live') return liveVideo;
            if (signalSourceMode === 'file') return rawPlayback;
            if (currentMode === 'cam' && liveVideo && liveVideo.srcObject) return liveVideo;
            if (rawPlayback && rawPlayback.src) return rawPlayback;
            return liveVideo || rawPlayback;
        }

        function stopSignalFpsMeter() {
            if (signalFpsVideoEl && typeof signalFpsVideoEl.cancelVideoFrameCallback === 'function' && signalFpsRafId) {
                try { signalFpsVideoEl.cancelVideoFrameCallback(signalFpsRafId); } catch (_) { }
            }
            signalFpsRafId = 0;
            signalFpsVideoEl = null;
            signalFpsFrames = 0;
            signalFpsLastTs = 0;
            signalFpsValue = 0;
        }

        function startSignalFpsMeter(el) {
            stopSignalFpsMeter();
            if (!el) return;
            signalFpsVideoEl = el;
            if (typeof el.requestVideoFrameCallback === 'function') {
                const onFrame = (now) => {
                    signalFpsFrames += 1;
                    if (!signalFpsLastTs) signalFpsLastTs = now;
                    const dt = now - signalFpsLastTs;
                    if (dt >= 1000) {
                        signalFpsValue = (signalFpsFrames * 1000) / dt;
                        signalFpsFrames = 0;
                        signalFpsLastTs = now;
                    }
                    signalFpsRafId = el.requestVideoFrameCallback(onFrame);
                };
                signalFpsRafId = el.requestVideoFrameCallback(onFrame);
            }
        }

        function updateSignalInfo(forceRestart) {
            const srcLabel = document.getElementById('signalSourceLabel');
            const resEl = document.getElementById('signalRes');
            const fpsEl = document.getElementById('signalFps');
            const fpsTargetEl = document.getElementById('signalFpsTarget');
            const el = pickSignalVideoEl();

            if (!el) return;
            if (forceRestart || signalFpsVideoEl !== el) startSignalFpsMeter(el);

            const hasStream = !!el.srcObject;
            const srcText = hasStream ? 'Kamera (MediaStream)' : (el.src ? 'F√°jl / stream' : 'Nincs jel');
            if (srcLabel) srcLabel.textContent = srcText;

            const w = el.videoWidth || 0;
            const h = el.videoHeight || 0;
            if (resEl) resEl.textContent = (w && h) ? `${w}√ó${h}` : '-';

            if (fpsEl) fpsEl.textContent = signalFpsValue ? `${signalFpsValue.toFixed(1)} fps` : '-';

            let targetFpsText = '-';
            if (hasStream) {
                const track = el.srcObject.getVideoTracks ? el.srcObject.getVideoTracks()[0] : null;
                const settings = track && track.getSettings ? track.getSettings() : null;
                if (settings && settings.frameRate) targetFpsText = `${settings.frameRate} fps`;
            } else if (el === rawPlayback) {
                targetFpsText = renderFps ? `${renderFps} fps` : '-';
            }
            if (fpsTargetEl) fpsTargetEl.textContent = targetFpsText;
        }

        // Orient√°ci√≥ UI inicializ√°l√°s (mobil=auto, desktop=manu√°lis)
        function initOrientationUI() {
            const container = document.getElementById('orientationModeContainer');
            if (!container) return;

            const isMobile = isMobileOrTablet();

            if (isMobile) {
                // MOBIL/TABLET: Automatikus orient√°ci√≥
                isAutoOrientationEnabled = true;
                container.innerHTML = `
                    <div style="padding: 8px; background: rgba(32, 211, 193, 0.15); border: 1px solid rgba(32, 211, 193, 0.4); border-radius: 6px; font-size: 10px; color: var(--accent-2); margin: 4px 0;">
                        üì± Automatikus orient√°ci√≥: forgasd a k√©sz√ºl√©ket!
                    </div>
                `;

                // Be√°ll√≠tjuk az aktu√°lis orient√°ci√≥t
                updateOrientationFromViewport();

                // Listener be√°ll√≠t√°sa
                setupOrientationListener();
            } else {
                // DESKTOP: Manu√°lis v√°laszt√≥ (NDI haszn√°lathoz)
                isAutoOrientationEnabled = false;
                container.innerHTML = `
                    <label>Kimenet k√©par√°ny (NDI)</label>
                    <select id="outputAspect" onchange="applyOutputAspectFromUI()">
                        <option value="landscape" selected>Fekv≈ë (landscape)</option>
                        <option value="portrait">√Åll√≥ (portrait)</option>
                    </select>
                `;
            }
        }

        function applyOutputAspectFromUI() {
            // Desktop: manu√°lis v√°laszt√≥ √©rt√©ke
            if (!isAutoOrientationEnabled) {
                const sel = document.getElementById('outputAspect');
                if (sel) {
                    outputAspectMode = sel.value;
                }
            }

            // El≈ën√©zet keret friss√≠t√©se
            applyPreviewAspect();

            // Utols√≥ kimenet el≈ën√©zet
            applyLastOutputAspectFromMode();

            // Ha kamer√°n vagyunk, igaz√≠tsuk az el≈ën√©zeti canvas m√©ret√©t
            if (currentMode === 'cam') {
                syncPreviewCanvasToMode(liveVideo);
            }

            // A vide√≥ transzform √∫jrasz√°mol√°sa
            requestAnimationFrame(() => applyLiveVideoTransform());
            setTimeout(applyLiveVideoTransform, 0);
            setTimeout(applyLiveVideoTransform, 50);
            updateDateOverlayPreview();
        }

        function applyOverlayFitFromUI() {
            const sel = document.getElementById('overlayFit');
            overlayFitMode = sel ? sel.value : 'stretch';
            // Az overlay illeszt√©s most m√°r csak a canvas rajzol√°sn√°l haszn√°l√≥dik (drawOverlayToCanvas)
        }

        function applySourceCropFromUI() {
            const top = document.getElementById('sourceCropTop');
            const right = document.getElementById('sourceCropRight');
            const bottom = document.getElementById('sourceCropBottom');
            const left = document.getElementById('sourceCropLeft');
            const t = top ? parseInt(top.value, 10) : 0;
            const r = right ? parseInt(right.value, 10) : 0;
            const b = bottom ? parseInt(bottom.value, 10) : 0;
            const l = left ? parseInt(left.value, 10) : 0;
            sourceCropPct = {
                top: isFinite(t) ? t : 0,
                right: isFinite(r) ? r : 0,
                bottom: isFinite(b) ? b : 0,
                left: isFinite(l) ? l : 0
            };
            const topVal = document.getElementById('sourceCropTopVal');
            const rightVal = document.getElementById('sourceCropRightVal');
            const bottomVal = document.getElementById('sourceCropBottomVal');
            const leftVal = document.getElementById('sourceCropLeftVal');
            if (topVal) topVal.textContent = String(sourceCropPct.top);
            if (rightVal) rightVal.textContent = String(sourceCropPct.right);
            if (bottomVal) bottomVal.textContent = String(sourceCropPct.bottom);
            if (leftVal) leftVal.textContent = String(sourceCropPct.left);
        }

        function getSourceCropPx(videoEl) {
            const vw = videoEl.videoWidth || 0;
            const vh = videoEl.videoHeight || 0;
            const t = Math.min(40, Math.max(0, sourceCropPct.top));
            const r = Math.min(40, Math.max(0, sourceCropPct.right));
            const b = Math.min(40, Math.max(0, sourceCropPct.bottom));
            const l = Math.min(40, Math.max(0, sourceCropPct.left));
            return {
                top: Math.round(vh * (t / 100)),
                right: Math.round(vw * (r / 100)),
                bottom: Math.round(vh * (b / 100)),
                left: Math.round(vw * (l / 100))
            };
        }

        function applyStartDelayFromUI() {
            const input = document.getElementById('recordDelay');
            const v = input ? parseFloat(input.value) : 0;
            startDelaySec = isFinite(v) && v >= 0 ? v : 0;
        }

        function applyAutoStopFromUI() {
            const chk = document.getElementById('autoStopEnabled');
            const sec = document.getElementById('autoStopSec');
            autoStopEnabled = !!(chk && chk.checked);
            const v = sec ? parseFloat(sec.value) : 10;
            autoStopSec = isFinite(v) && v > 0 ? v : 10;
            if (sec) sec.disabled = !autoStopEnabled;
        }

        function applyQualityFromUI() {
            const sel = document.getElementById('qualityPreset');
            qualityPreset = sel ? sel.value : 'high';

            if (qualityPreset === 'low') {
                renderFps = 24;
                videoBitsPerSecond = 2500000;
            } else if (qualityPreset === 'high') {
                renderFps = 30;
                videoBitsPerSecond = 8000000;
            } else {
                renderFps = 30;
                videoBitsPerSecond = 5000000;
            }
        }

        function applyCameraFpsFromUI() {
            const sel = document.getElementById('cameraFps');
            const v = sel ? parseInt(sel.value, 10) : 60;
            cameraFps = isFinite(v) ? v : 60;
            if (currentMode === 'cam' && stream) {
                startCamera();
            }
        }

        function applyCameraResolutionFromUI() {
            const sel = document.getElementById('cameraResolution');
            const val = sel ? String(sel.value || '1280x720') : '1280x720';
            const parts = val.split('x').map((n) => parseInt(n, 10));
            const w = parts[0] || 1280;
            const h = parts[1] || 720;
            cameraWidth = w;
            cameraHeight = h;
            if (currentMode === 'cam' && stream) {
                startCamera();
            }
        }

        function setSelectValueOrAdd(select, value, label) {
            if (!select) return;
            const str = String(value);
            const found = Array.from(select.options).some((opt) => opt.value === str);
            if (!found) {
                const opt = document.createElement('option');
                opt.value = str;
                opt.textContent = label || str;
                select.prepend(opt);
            }
            select.value = str;
        }

        function applyPreviewFpsFromUI() {
            const sel = document.getElementById('previewFps');
            const v = sel ? parseInt(sel.value, 10) : 30;
            previewFps = isFinite(v) ? v : 30;
        }

        function applyUseSourceResolutionFromUI() {
            const chk = document.getElementById('useSourceResolution');
            useSourceResolution = !!(chk && chk.checked);
            applyPreviewAspect();
            syncPreviewCanvasToMode(liveVideo);
            syncLastOutputWidth();
        }

        function applySignalSourceFromUI() {
            const sel = document.getElementById('signalSource');
            signalSourceMode = sel ? sel.value : 'auto';
            updateSignalInfo(true);
        }

        function applyFormatFromUI() {
            const sel = document.getElementById('formatPref');
            preferredFormat = sel ? sel.value : 'auto';
        }

        function setVideoContainerAspectFromCanvas() {
            const vc = document.getElementById('videoContainer');
            if (!vc) return;

            // A renderCanvas m√©rete dikt√°lja a kimeneti k√©par√°nyt (ez lesz a mentett vide√≥ is)
            if (canvas && canvas.width && canvas.height) {
                vc.style.aspectRatio = `${canvas.width} / ${canvas.height}`;
            } else {
                // tartal√©k
                applyPreviewAspect();
            }
        }

        function chooseCanvasSizeByMode(sourceW, sourceH) {
            // NAT√çV kamera felbont√°s haszn√°lata
            const sw = sourceW || 1280;
            const sh = sourceH || 720;

            // Hat√°rozd meg a kamera nat√≠v ar√°ny√°t
            const sourceIsPortrait = sh > sw;

            // Hat√°rozd meg a k√≠v√°nt kimenet ar√°ny√°t
            const wantPortrait = (outputAspectMode === 'portrait');

            // Ha a kamera ar√°nya NEM egyezik a k√≠v√°nt orient√°ci√≥val, SWAP!
            if (sourceIsPortrait !== wantPortrait) {
                // Felcser√©lj√ºk a sz√©less√©g/magass√°g √©rt√©keit
                return { w: sh, h: sw };
            }

            // Egy√©bk√©nt nat√≠v m√©ret
            return { w: sw, h: sh };
        }

        function drawVideoCoverToRect(ctx2, videoEl, dx, dy, dw, dh) {
            const vw = videoEl.videoWidth || dw;
            const vh = videoEl.videoHeight || dh;

            const crop = getSourceCropPx(videoEl);
            const cvw = Math.max(1, vw - crop.left - crop.right);
            const cvh = Math.max(1, vh - crop.top - crop.bottom);
            const srcAspect = cvw / cvh;
            const dstAspect = dw / dh;

            let sx = crop.left, sy = crop.top, sw = cvw, sh = cvh;

            if (srcAspect > dstAspect) {
                sh = cvh;
                sw = Math.round(cvh * dstAspect);
                sx = crop.left + Math.round((cvw - sw) / 2);
                sy = crop.top;
            } else {
                sw = cvw;
                sh = Math.round(cvw / dstAspect);
                sx = crop.left;
                sy = crop.top + Math.round((cvh - sh) / 2);
            }

            ctx2.drawImage(videoEl, sx, sy, sw, sh, dx, dy, dw, dh);
        }

        function drawVideoCover(ctx2, videoEl, dstW, dstH) {
            drawVideoCoverToRect(ctx2, videoEl, 0, 0, dstW, dstH);
        }

        function drawVideoCoverRotated(ctx2, videoEl, dstW, dstH, rotateDeg) {
            const deg = (rotateDeg % 360 + 360) % 360;
            if (deg === 0) {
                drawVideoCoverToRect(ctx2, videoEl, 0, 0, dstW, dstH);
                return;
            }

            const rad = (deg * Math.PI) / 180;

            ctx2.save();
            ctx2.translate(dstW / 2, dstH / 2);
            ctx2.rotate(rad);

            const swap = (deg === 90 || deg === 270);
            const rw = swap ? dstH : dstW;
            const rh = swap ? dstW : dstH;

            drawVideoCoverToRect(ctx2, videoEl, -rw / 2, -rh / 2, rw, rh);
            ctx2.restore();
        }

        async function waitForFirstFrame(videoEl, timeoutMs = 1500) {
            if (!videoEl) return;
            if (videoEl.readyState >= 2 && videoEl.videoWidth && videoEl.videoHeight) return;

            let done = false;
            const fallback = new Promise((res) => {
                setTimeout(() => {
                    if (!done) res();
                }, timeoutMs);
            });

            const byEvent = new Promise((res) => {
                const onReady = () => {
                    if (done) return;
                    done = true;
                    videoEl.removeEventListener('canplay', onReady);
                    videoEl.removeEventListener('playing', onReady);
                    res();
                };
                videoEl.addEventListener('canplay', onReady, { once: true });
                videoEl.addEventListener('playing', onReady, { once: true });
            });

            const byFrame = (typeof videoEl.requestVideoFrameCallback === 'function')
                ? new Promise((res) => {
                    videoEl.requestVideoFrameCallback(() => {
                        if (!done) {
                            done = true;
                            res();
                        }
                    });
                })
                : null;

            await Promise.race([fallback, byEvent, byFrame].filter(Boolean));
        }

        function seekToTime(videoEl, timeSec, timeoutMs = 600) {
            return new Promise((res) => {
                if (!videoEl) return res();
                const t = Math.max(0, timeSec || 0);
                if (Math.abs((videoEl.currentTime || 0) - t) < 0.01) return res();
                let done = false;
                const onSeeked = () => {
                    if (done) return;
                    done = true;
                    videoEl.removeEventListener('seeked', onSeeked);
                    res();
                };
                const timer = setTimeout(() => {
                    if (done) return;
                    done = true;
                    videoEl.removeEventListener('seeked', onSeeked);
                    res();
                }, timeoutMs);
                videoEl.addEventListener('seeked', onSeeked, { once: true });
                try { videoEl.currentTime = t; } catch (_) { clearTimeout(timer); res(); }
            });
        }

        async function safePlay(videoEl, timeoutMs = 1200) {
            if (!videoEl) return false;
            try {
                const p = videoEl.play();
                if (p && typeof p.then === 'function') {
                    const ok = await Promise.race([
                        p.then(() => true).catch(() => false),
                        new Promise((res) => setTimeout(() => res(false), timeoutMs))
                    ]);
                    return ok === true;
                } else {
                    await new Promise((res) => setTimeout(res, 0));
                    return true;
                }
            } catch (_) {
                return false;
            }
        }

        async function findTrimStartTime(videoEl, maxSec = 2, stepSec = 0.05) {
            if (!videoEl) return 0;
            const duration = isFinite(videoEl.duration) ? videoEl.duration : 0;
            if (duration <= 0) return 0;
            const limit = Math.min(maxSec, duration);
            const tmp = document.createElement('canvas');
            const tw = 64;
            const th = 36;
            tmp.width = tw;
            tmp.height = th;
            const tctx = tmp.getContext('2d');
            for (let t = 0; t <= limit + 0.0001; t += stepSec) {
                await seekToTime(videoEl, t);
                try {
                    tctx.drawImage(videoEl, 0, 0, tw, th);
                    const data = tctx.getImageData(0, 0, tw, th).data;
                    let sum = 0;
                    for (let i = 0; i < data.length; i += 4) {
                        sum += data[i] + data[i + 1] + data[i + 2];
                    }
                    const avg = sum / (data.length / 4);
                    if (avg > 12) return t;
                } catch (_) {
                    return 0;
                }
            }
            return 0;
        }

        function buildProjectorThumb() {
            try {
                return canvas.toDataURL('image/jpeg', 0.72);
            } catch (_) {
                return null;
            }
        }

        // R√∂gz√≠t≈ë kimenet form√°tum (pr√≥b√°lunk kompatibiliset v√°lasztani)
        let lastOutputUrl = null;
        let lastOutputExt = 'webm';
        let lastOutputMime = 'video/webm';

        // Elemek
        const liveVideo = document.getElementById('liveVideo');
        const rawPlayback = document.getElementById('rawPlayback');
        const canvas = document.getElementById('renderCanvas');
        const ctx = canvas.getContext('2d');
        const overlayImg = document.getElementById('overlayImg');
        const statusBadge = document.getElementById('statusBadge');
        const progressBar = document.getElementById('progressBar');
        const progressBarContainer = document.getElementById('progressBarContainer');
        const processText = document.getElementById('processText');

        // --- √âL≈ê EL≈êN√âZET CANVAS CIKLUS (kamera el≈ën√©zet a canvas-on) ---
        let livePreviewRAF = 0;
        let lastPreviewDrawMs = 0;

        function stopLivePreviewLoop() {
            if (livePreviewRAF) {
                cancelAnimationFrame(livePreviewRAF);
                livePreviewRAF = 0;
            }
        }

        function syncPreviewCanvasToMode(videoEl) {
            const v = videoEl || liveVideo;
            const vw = (v && v.videoWidth) ? v.videoWidth : 1280;
            const vh = (v && v.videoHeight) ? v.videoHeight : 720;
            const chosen = chooseCanvasSizeByMode(vw, vh);
            if (canvas.width !== chosen.w || canvas.height !== chosen.h) {
                canvas.width = chosen.w;
                canvas.height = chosen.h;
            }
            setVideoContainerAspectFromCanvas();
        }

        function drawLivePreviewOnce() {
            if (currentMode !== 'cam') return;
            if (isProcessing) return;
            if (!liveVideo || !liveVideo.srcObject) return;
            if (liveVideo.readyState < 2) return; // nincs k√©p m√©g

            // Az el≈ën√©zet mindig a canvas-on megy, √≠gy nem lesz se "√≥ri√°si zoom", se "b√©lyegk√©p".
            try {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawVideoCoverRotated(ctx, liveVideo, canvas.width, canvas.height, getEffectiveRotateDeg(liveVideo));
                // Overlay falt√≥l-falig a canvas m√©ret√©hez igazodva (mint a render loop-ban)
                drawOverlayToCanvas(ctx, canvas.width, canvas.height);
                if (isDateOverlayEnabled()) {
                    drawDateStamp(ctx, canvas.width, canvas.height);
                }
            } catch (e) {
                // ne √°lljon le a ciklus
                console.warn('[PREVIEW] draw failed:', e);
            }
        }

        function drawLivePreviewLoop() {
            stopLivePreviewLoop();
            const loop = () => {
                const now = performance.now();
                const frameMs = previewFps > 0 ? (1000 / previewFps) : 33;
                if (now - lastPreviewDrawMs >= frameMs) {
                    lastPreviewDrawMs = now;
                    drawLivePreviewOnce();
                }
                livePreviewRAF = requestAnimationFrame(loop);
            };
            livePreviewRAF = requestAnimationFrame(loop);
        }

        // Utols√≥ kimenet UI

        const lastOutputBox = document.getElementById('lastOutput');
        const lastOutputVideo = document.getElementById('lastOutputVideo');
        const lastOutputInfo = document.getElementById('lastOutputInfo');
        const btnOpenLast = document.getElementById('btnOpenLast');
        const btnDownloadLast = document.getElementById('btnDownloadLast');
        const btnHideLast = document.getElementById('btnHideLast');

        function applyLastOutputAspectFromMode() {
            if (!lastOutputVideo) return;

            // A vide√≥ saj√°t aspect ratio-j√°t haszn√°lja (nat√≠v kamera ar√°ny)
            // Nincs k√©nyszer√≠tett 9:16 vagy 16:9
            try {
                lastOutputVideo.style.aspectRatio = 'auto';
            } catch (_) {
                // Safari: nem baj
            }
        }

        function syncLastOutputWidth() {
            const vc = document.getElementById('videoContainer');
            const lo = document.getElementById('lastOutput');
            if (!vc || !lo) return;

            // A k√©sz vide√≥ + gombok doboza ugyanakkora sz√©less√©g≈± legyen, mint az el≈ën√©zet keret.
            // √çgy √°ll√≥ m√≥dban nem lesz ‚Äû≈±ber nagy‚Äù full panel sz√©less√©g≈±.
            const r = vc.getBoundingClientRect();
            const w = Math.max(0, Math.floor(r.width));
            if (w > 0) {
                lo.style.width = w + 'px';
                lo.style.maxWidth = w + 'px';
            } else {
                lo.style.width = '100%';
                lo.style.maxWidth = '100%';
            }
        }

        // MediaRecorder t√°mogatott mimeType kiv√°laszt√°sa (Mac-en a VP9 gyakran probl√©m√°s lej√°tsz√°sn√°l)
        function pickRecorderMime(pref) {
            const mp4 = [
                { mime: 'video/mp4;codecs=avc1.42E01E,mp4a.40.2', ext: 'mp4' },
                { mime: 'video/mp4;codecs=avc1.42E01E', ext: 'mp4' }
            ];
            const webm = [
                { mime: 'video/webm;codecs=vp8', ext: 'webm' },
                { mime: 'video/webm;codecs=vp9', ext: 'webm' },
                { mime: 'video/webm', ext: 'webm' }
            ];
            const candidates = (pref === 'mp4') ? [...mp4, ...webm]
                : (pref === 'webm') ? [...webm, ...mp4]
                : [...mp4, ...webm];

            if (!window.MediaRecorder || !MediaRecorder.isTypeSupported) {
                return { mime: 'video/webm', ext: 'webm' };
            }

            for (const c of candidates) {
                try {
                    if (MediaRecorder.isTypeSupported(c.mime)) return c;
                } catch (_) { }
            }
            return { mime: 'video/webm', ext: 'webm' };
        }

        function setLastOutput(url, mime, ext, bytes) {
            // R√©gi URL felszabad√≠t√°s
            try { if (lastOutputUrl) URL.revokeObjectURL(lastOutputUrl); } catch (_) { }

            lastOutputUrl = url;
            lastOutputMime = mime;
            lastOutputExt = ext;

            lastOutputVideo.src = url;
            lastOutputBox.style.display = 'block';
            // Az el≈ën√©zet lej√°tsz√≥ igazodjon a v√°lasztott kimeneti k√©par√°nyhoz
            applyLastOutputAspectFromMode();
            syncLastOutputWidth();

            const sizeMB = bytes ? (bytes / (1024 * 1024)).toFixed(1) : '?';
            lastOutputInfo.innerText = `Form√°tum: ${ext.toUpperCase()} (${mime}) ‚Ä¢ M√©ret: ${sizeMB} MB`;
        }

        btnOpenLast.onclick = () => {
            if (!lastOutputUrl) return;
            window.open(lastOutputUrl, '_blank');
        };
        btnDownloadLast.onclick = () => {
            if (!lastOutputUrl) return;
            const a = document.createElement('a');
            const now = new Date();
            a.href = lastOutputUrl;
            a.download = `360_Video_${now.getHours()}${now.getMinutes()}${now.getSeconds()}.${lastOutputExt}`;
            a.click();
        };
        btnHideLast.onclick = () => {
            lastOutputBox.style.display = 'none';
        };

        // Safari/MediaRecorder diagnosztika: ha nincs MediaRecorder, a feldolgoz√°s nem fog menni.
        (function bootChecks() {
            // A "Utols√≥ vide√≥" doboz csak a feldolgoz√°s v√©g√©n jelenik meg.
            try {
                if (lastOutputInfo) {
                    lastOutputInfo.innerText = 'A feldolgoz√°s v√©g√©n itt jelenik meg az utols√≥ vide√≥ (el≈ën√©zet + let√∂lt√©s).';
                }
            } catch (_) { }

            if (!window.MediaRecorder) {
                console.error('[REC] MediaRecorder NOT available in this browser.');
                statusBadge.innerText = 'SAFARI: NINCS FELV√âTEL';
                statusBadge.style.color = 'red';
                processText.innerText = 'Ez a Safari verzi√≥ nem t√°mogatja a MediaRecorder-t. Haszn√°lj Chrome-ot, vagy enged√©lyezd a Safari k√≠s√©rleti MediaRecorder/WebRTC opci√≥it.';
            }
        })();

        // --- 0. M√ìDV√ÅLT√ÅS ---
        function setMode(mode) {
            currentMode = mode;
            document.getElementById('btnModeCam').className = mode === 'cam' ? 'mode-btn active' : 'mode-btn';
            document.getElementById('btnModeFile').className = mode === 'file' ? 'mode-btn active' : 'mode-btn';

            document.getElementById('camControls').style.display = mode === 'cam' ? 'block' : 'none';
            document.getElementById('fileControls').style.display = mode === 'file' ? 'block' : 'none';

            if (mode === 'cam') {
                // Kamera m√≥dban a korrekt el≈ën√©zetet canvas-on mutatjuk (nem a video elemen),
                // √≠gy a portrait/rotate nem fog sz√©tesni.
                liveVideo.style.display = 'none';
                canvas.style.display = 'block';
                rawPlayback.style.display = 'none';
                // DropZone elrejt√©se kamera m√≥dban
                const dz = document.getElementById('dropZone');
                if (dz) dz.style.display = 'none';
                loadCameras();
            } else {
                stopLivePreviewLoop();
                liveVideo.style.display = 'none';
                rawPlayback.style.display = 'none'; // Csak feldolgoz√°skor l√°tszik
                if (stream) stream.getTracks().forEach(t => t.stop());

                // F√°jldoboz esem√©nyek
                const dz = document.getElementById('dropZone');
                // Biztosan l√°tsz√≥djon a drop zone f√°jl m√≥dban
                if (dz) dz.style.display = 'flex';
                dz.ondragover = (e) => { e.preventDefault(); dz.classList.add('dragover'); };
                dz.ondragleave = () => dz.classList.remove('dragover');
                dz.ondrop = (e) => {
                    e.preventDefault(); dz.classList.remove('dragover');
                    if (e.dataTransfer.files[0]) processImportedFile(e.dataTransfer.files[0]);
                };
            }
        }

        function handleFileSelect(input) {
            if (input.files[0]) processImportedFile(input.files[0]);
        }

        function setRawPlaybackSource(blob) {
            try { if (rawVideoUrl) URL.revokeObjectURL(rawVideoUrl); } catch (_) { }
            rawVideoUrl = URL.createObjectURL(blob);
            rawPlayback.src = rawVideoUrl;
        }

        async function processImportedFile(file) {
            statusBadge.innerText = "F√ÅJL BET√ñLTVE";
            statusBadge.style.color = "#fff";

            // Blob l√©trehoz√°sa a f√°jlb√≥l
            rawVideoBlob = file;
            setRawPlaybackSource(rawVideoBlob);

            // Azonnali ind√≠t√°s
            startProcessingLoop();
        }


        // --- 1. BRANDING & KIVET√çT≈ê ---
        function updateBranding() {
            const text = document.getElementById('brandTitleInput').value || "360 Booth";
            if (projectorWin && !projectorWin.closed) {
                projectorWin.postMessage({ type: 'updateBrand', title: text, logo: currentLogoData }, '*');
            }
        }
        function updateLogo() {
            const file = document.getElementById('logoInput').files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function (e) { currentLogoData = e.target.result; updateBranding(); }
                reader.readAsDataURL(file);
            }
        }
        function openProjectorWindow() {
            if (projectorWin && !projectorWin.closed) { projectorWin.focus(); return; }
            const displayHTML = `<!DOCTYPE html>
<html lang="hu">
<head>
  <meta charset="UTF-8">
  <title>360 Booth - Kivet√≠t≈ë</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@500;600;700&display=swap');
    :root{
      --bg-0:#0a0f14;--bg-1:#0f151d;--panel:#0f141d;--border:#1e2a38;--text:#e6edf3;--muted:#9aa4b2;--accent:#23d7b5;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:'Space Grotesk',sans-serif;
      color:var(--text);
      background:
        radial-gradient(900px 500px at 10% -10%, rgba(35,215,181,.12), transparent 60%),
        var(--bg-0);
      display:grid;
      grid-template-columns:minmax(0,1fr) 320px;
      height:100dvh;
      overflow:hidden;
    }
    #main{
      display:flex;flex-direction:column;align-items:center;justify-content:center;
      padding:28px;gap:18px;background:var(--bg-1);
    }
    #brand{display:flex;flex-direction:column;align-items:center;gap:10px}
    #title{font-size:28px;letter-spacing:4px;text-transform:uppercase;margin:0}
    #logo{max-height:84px;display:none}
    #dispWrap{
      width:min(92%,1200px);aspect-ratio:16/9;background:#090e13;
      border:1px solid var(--border);border-radius:14px;overflow:hidden;
      display:flex;align-items:center;justify-content:center;position:relative;
    }
    #disp{width:100%;height:100%;object-fit:cover;display:none}
    #wait{font-size:16px;color:var(--muted);text-align:center}
    #tap{
      position:absolute;inset:auto auto 18px 18px;
      background:rgba(15,20,29,.75);border:1px solid var(--border);
      color:var(--text);padding:8px 12px;border-radius:8px;display:none;
      font-size:12px;cursor:pointer;
    }
    #side{
      background:var(--panel);border-left:1px solid var(--border);
      padding:18px;display:flex;flex-direction:column;gap:12px;
    }
    .side-title{font-size:12px;letter-spacing:2px;text-transform:uppercase;color:var(--muted)}
    #gal{overflow-y:auto;display:grid;gap:10px}
    .g-item{
      border:1px solid var(--border);border-radius:10px;overflow:hidden;
      cursor:pointer;background:#0b1016;
    }
    .g-item video{width:100%;aspect-ratio:16/9;object-fit:cover;display:block}
    .g-thumb{width:100%;aspect-ratio:16/9;object-fit:cover;display:block}
  </style>
</head>
<body>
  <div id="main">
    <div id="brand">
      <h1 id="title">360 Booth</h1>
      <img id="logo" alt="Logo">
    </div>
    <div id="dispWrap">
      <video id="disp" muted playsinline></video>
      <div id="wait">V√°rakoz√°s...</div>
      <button id="tap" type="button">Kattints a lej√°tsz√°shoz</button>
    </div>
  </div>
  <div id="side">
    <div class="side-title">Gal√©ria</div>
    <div id="gal"></div>
  </div>
  <script>
    const disp = document.getElementById('disp');
    const wait = document.getElementById('wait');
    const tap = document.getElementById('tap');
    const gal = document.getElementById('gal');

    function playVideo(url) {
      disp.src = url;
      disp.muted = true;
      disp.playsInline = true;
      disp.autoplay = true;
      disp.loop = true;
      disp.controls = false;
      disp.style.display = 'block';
      wait.style.display = 'none';
      tap.style.display = 'none';
      const p = disp.play();
      if (p && typeof p.catch === 'function') {
        p.catch(() => {
          tap.style.display = 'block';
        });
      }
    }

    tap.addEventListener('click', () => {
      disp.play().then(() => { tap.style.display = 'none'; }).catch(() => {});
    });

    window.addEventListener('message', (e) => {
      const d = e.data || {};
      if (d.type === 'updateBrand') {
        document.getElementById('title').innerText = d.title || '360 Booth';
        if (d.logo) {
          document.getElementById('logo').src = d.logo;
          document.getElementById('logo').style.display = 'block';
        } else {
          document.getElementById('logo').style.display = 'none';
        }
      }
      if (d.type === 'newVideo') {
        playVideo(d.url);
        const g = document.createElement('div');
        g.className = 'g-item';
        const img = document.createElement('img');
        img.className = 'g-thumb';
        img.alt = 'Video thumbnail';
        if (d.thumb) img.src = d.thumb;
        g.appendChild(img);
        g.onclick = () => playVideo(d.url);
        gal.prepend(g);
      }
    });
  <\/script>
</body>
</html>`;
            projectorWin = window.open("", "ProjectorWindow", "width=1280,height=720,menubar=no,toolbar=no");
            projectorWin.document.write(displayHTML);
            projectorWin.document.close();
            setTimeout(() => updateBranding(), 500);
        }
        function sendToProjector(blobUrl, thumbUrl) {
            if (projectorWin && !projectorWin.closed) {
                projectorWin.postMessage({ type: 'newVideo', url: blobUrl, thumb: thumbUrl || null }, '*');
            }
        }

        // --- 2. KAMERA (Ha m√©gis kell) ---
        async function loadCameras() {
            // Kamera lista megb√≠zhat√≥ bet√∂lt√©se: el≈ëbb enged√©lyt k√©r√ºnk,
            // majd enumerateDevices, v√©g√ºl ind√≠t√°s.
            try {
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    console.error('[CAM] mediaDevices/getUserMedia not available. Use HTTPS or localhost.');
                    statusBadge.innerText = 'KAMERA NEM EL√âRHET≈ê';
                    statusBadge.style.color = 'red';
                    return;
                }

                // Enged√©lyk√©r√©s (labels + videoinput lista csak ez ut√°n megb√≠zhat√≥)
                let tmpStream = null;
                try {
                    tmpStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
                } catch (e) {
                    console.error('[CAM] Permission/getUserMedia failed:', e);
                    statusBadge.innerText = 'KAMERA ENGED√âLY KELL';
                    statusBadge.style.color = 'red';
                    return;
                } finally {
                    if (tmpStream) tmpStream.getTracks().forEach(t => t.stop());
                }

                const d = await navigator.mediaDevices.enumerateDevices();
                const s = document.getElementById('camSelect');
                s.innerHTML = '';

                const cams = d.filter(x => x.kind === 'videoinput');
                if (cams.length === 0) {
                    console.error('[CAM] No videoinput devices found.');
                    s.innerHTML = '<option value="">Nincs kamera</option>';
                    statusBadge.innerText = 'NINCS KAMERA';
                    statusBadge.style.color = 'red';
                    return;
                }

                cams.forEach((x, idx) => {
                    const o = document.createElement('option');
                    o.value = x.deviceId;
                    o.text = x.label || `Kamera ${idx + 1}`;
                    s.appendChild(o);
                });

                // Csak kamera m√≥dban ind√≠tunk
                if (currentMode === 'cam') await startCamera();

            } catch (e) {
                console.error('[CAM] loadCameras error:', e);
                statusBadge.innerText = 'KAMERA HIBA';
                statusBadge.style.color = 'red';
            }
        }

        async function startCamera() {
            if (currentMode !== 'cam') return;

            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                console.error('[CAM] mediaDevices/getUserMedia not available. Use HTTPS or localhost.');
                statusBadge.innerText = 'KAMERA NEM EL√âRHET≈ê';
                statusBadge.style.color = 'red';
                return;
            }

            const id = document.getElementById('camSelect').value;

            // El≈ëz≈ë stream le√°ll√≠t√°sa (k√ºl√∂nben Safari/Chrome n√©ha nem v√°lt kamer√°t rendesen)
            try {
                if (stream) stream.getTracks().forEach(t => t.stop());
            } catch (_) { }
            stream = null;

            try {
                // NAT√çV kamera be√°ll√≠t√°sok haszn√°lata - ne korl√°tozzuk!
                const constraints = {
                    video: {
                        // Ne korl√°tozzuk a felbont√°st √©s FPS-t, hadd v√°lassza a kamera a legjobbat
                        ...(id ? { deviceId: { exact: id } } : {})
                    },
                    audio: false
                };

                stream = await navigator.mediaDevices.getUserMedia(constraints);
                liveVideo.srcObject = stream;

                // iOS/Safari: n√©ha kell explicit play
                try { await liveVideo.play(); } catch (_) { }

                // Canvas el≈ën√©zet inicializ√°l√°s
                canvas.style.display = 'block';
                liveVideo.style.display = 'none';

                // Amint megvan a vide√≥ metadata, √∫jrasz√°moljuk a rotate+scale transzformot
                const onMeta = () => {
                    liveVideo.removeEventListener('loadedmetadata', onMeta);
                    applyPreviewAspect();
                    syncPreviewCanvasToMode(liveVideo);
                    applyLiveVideoTransform();
                    drawLivePreviewLoop();
                };
                liveVideo.addEventListener('loadedmetadata', onMeta);

                applyPreviewAspect();
                syncPreviewCanvasToMode(liveVideo);
                applyLiveVideoTransform();
                drawLivePreviewLoop();

                const track = stream.getVideoTracks ? stream.getVideoTracks()[0] : null;
                const settings = track && track.getSettings ? track.getSettings() : null;
                if (settings) {
                    // Detekt√°ljuk √©s mentj√ºk el a kamera NAT√çV be√°ll√≠t√°sait
                    if (settings.width && settings.height) {
                        cameraWidth = settings.width;
                        cameraHeight = settings.height;
                        setSelectValueOrAdd(document.getElementById('cameraResolution'), `${cameraWidth}x${cameraHeight}`, `${cameraWidth}x${cameraHeight} (nat√≠v)`);
                    }
                    if (settings.frameRate) {
                        cameraFps = Math.round(settings.frameRate);
                        setSelectValueOrAdd(document.getElementById('cameraFps'), String(cameraFps), `${cameraFps} fps (nat√≠v)`);
                    }
                }

                // Nat√≠v be√°ll√≠t√°sok haszn√°lata - nincs sz√ºks√©g √∫jraind√≠t√°sra
                autoMaxCameraApplied = true;

                statusBadge.innerText = 'K√âSZENL√âT';
                statusBadge.style.color = '#03dac6';
                if (pendingStartRecord) {
                    pendingStartRecord = false;
                    setTimeout(() => initiateCamSequence(), 0);
                }

            } catch (e) {
                console.error('[CAM] startCamera getUserMedia failed:', e);
                statusBadge.innerText = 'KAMERA HIBA';
                statusBadge.style.color = 'red';
            }
        }

        // --- 3. EFFEKTEK ---
        function fmtNum(x, d = 2) {
            const n = Number(x);
            if (!isFinite(n)) return '0';
            return n.toFixed(d).replace(/\.00$/, '.0').replace(/\.(\d)0$/, '.$1');
        }

        function updateEffectUI() {
            const tS = document.getElementById('effTimeSlider');
            const sS = document.getElementById('effSpeedSlider');
            const tV = document.getElementById('effTimeVal');
            const sV = document.getElementById('effSpeedVal');
            if (tS && tV) tV.innerText = `${fmtNum(tS.value, 1)} s`;
            if (sS && sV) sV.innerText = `${fmtNum(sS.value, 2)}√ó`;
            updateSpeedPresetButtons(parseFloat(sS ? sS.value : '1'));

            // Automatikus friss√≠t√©s: ha van kijel√∂lt szakasz, a cs√∫szka/preset mozgat√°s azonnal √°t√≠rja.
            scheduleAutoApplyToSelected();
        }

        function updateSpeedPresetButtons(v) {
            const b05 = document.getElementById('btnSpeed05');
            const b10 = document.getElementById('btnSpeed10');
            const b20 = document.getElementById('btnSpeed20');
            const eq = (a, b) => Math.abs(a - b) < 0.001;
            if (b05) b05.classList.toggle('active', eq(v, 0.5));
            if (b10) b10.classList.toggle('active', eq(v, 1.0));
            if (b20) b20.classList.toggle('active', eq(v, 2.0));
        }

        // --- AUTO ALKALMAZ√ÅS (kijel√∂lt szakasz azonnali friss√≠t√©se cs√∫szka/preset mozgat√°skor) ---
        let _autoApplyTimer = 0;

        function scheduleAutoApplyToSelected() {
            if (selectedEffectIndex < 0 || selectedEffectIndex >= effects.length) return;
            if (_autoApplyTimer) clearTimeout(_autoApplyTimer);
            _autoApplyTimer = setTimeout(() => {
                _autoApplyTimer = 0;
                applyToSelected();
            }, 120);
        }

        function setSpeedPreset(v) {
            const sS = document.getElementById('effSpeedSlider');
            if (sS) sS.value = String(v);
            updateEffectUI();
            scheduleAutoApplyToSelected();
        }

        function selectEffect(idx) {
            if (!Array.isArray(effects) || effects.length === 0) {
                selectedEffectIndex = -1;
                return;
            }
            if (idx < 0 || idx >= effects.length) {
                selectedEffectIndex = -1;
                return;
            }
            selectedEffectIndex = idx;

            // cs√∫szk√°k felv√©tele a kijel√∂lt szakaszra
            const tS = document.getElementById('effTimeSlider');
            const sS = document.getElementById('effSpeedSlider');
            if (tS) tS.value = String(effects[idx].duration);
            if (sS) sS.value = String(effects[idx].speed);
            updateEffectUI();
            renderList();
            renderTimeline();
        }

        function applyToSelected() {
            if (selectedEffectIndex < 0 || selectedEffectIndex >= effects.length) return;
            disableAutoRamp();
            const tS = document.getElementById('effTimeSlider');
            const sS = document.getElementById('effSpeedSlider');
            const dur = parseFloat(tS ? tS.value : '0');
            const spd = parseFloat(sS ? sS.value : '0');
            if (!isFinite(dur) || dur <= 0) return;
            if (!isFinite(spd) || spd <= 0) return;
            effects[selectedEffectIndex] = { duration: dur, speed: spd };
            renderList();
            renderTimeline();
        }

        function addEffect() {
            disableAutoRamp();
            const tS = document.getElementById('effTimeSlider');
            const sS = document.getElementById('effSpeedSlider');
            const dur = parseFloat(tS ? tS.value : '2');
            const spd = parseFloat(sS ? sS.value : '1');
            if (!isFinite(dur) || dur <= 0) return;
            if (!isFinite(spd) || spd <= 0) return;
            effects.push({ duration: dur, speed: spd });
            renderList();
        }

        function deleteEffect(idx) {
            if (idx < 0 || idx >= effects.length) return;
            effects.splice(idx, 1);
            if (selectedEffectIndex === idx) selectedEffectIndex = -1;
            else if (selectedEffectIndex > idx) selectedEffectIndex -= 1;
            renderList();
        }

        function clearEffects() {
            disableAutoRamp();
            effects = [];
            selectedEffectIndex = -1;
            renderList();
        }

        function setAutoRampEnabled(val) {
            autoRampEnabled = !!val;
            const chk = document.getElementById('autoRampMode');
            if (chk) chk.checked = autoRampEnabled;
            updateRampPresetButtons();
        }

        function syncAutoRampStateFromUI() {
            const chk = document.getElementById('autoRampMode');
            if (!chk) return;
            autoRampEnabled = !!chk.checked;
            updateRampPresetButtons();
        }

        function disableAutoRamp() {
            if (!autoRampEnabled) return;
            setAutoRampEnabled(false);
        }

        const rampPresets = {
            balanced: {
                ratios: [0.3, 0.4, 0.2, 0.1],
                speeds: [1.0, 0.5, 2.0, 1.0]
            },
            smooth: {
                ratios: [0.35, 0.3, 0.2, 0.15],
                speeds: [1.0, 0.8, 1.4, 1.0]
            },
            punch: {
                ratios: [0.2, 0.45, 0.2, 0.15],
                speeds: [1.0, 0.4, 2.2, 1.0]
            },
            slowmo: {
                ratios: [0.25, 0.5, 0.15, 0.1],
                speeds: [1.0, 0.35, 1.6, 1.0]
            }
        };

        function getActiveRampPreset() {
            return rampPresets[currentRampPresetKey] || rampPresets.balanced;
        }

        function updateRampPresetButtons() {
            const buttons = document.querySelectorAll('[data-ramp-preset]');
            buttons.forEach((btn) => {
                const key = btn.getAttribute('data-ramp-preset');
                const isActive = autoRampEnabled && key === currentRampPresetKey;
                btn.classList.toggle('active', isActive);
            });
        }

        function setRampPreset(key) {
            if (!rampPresets[key]) return;
            currentRampPresetKey = key;
            setAutoRampEnabled(true);
            applyAutoRampFromDuration();
        }

        function quantizeDurations(durs, total, step) {
            const out = durs.map(v => Math.max(step, v));
            const sum = out.reduce((a, b) => a + b, 0);
            const diff = total - sum;
            if (Math.abs(diff) < step) return out;
            const last = out.length - 1;
            out[last] = Math.max(step, out[last] + diff);
            return out;
        }

        function buildAutoRamp(totalSec) {
            const preset = getActiveRampPreset();
            const ratios = preset.ratios;
            const speeds = preset.speeds;
            const rawSource = ratios.map(r => totalSec * r);
            const sourceDurs = quantizeDurations(rawSource, totalSec, 0.01);
            return sourceDurs.map((src, i) => {
                const spd = speeds[i] || 1;
                const outDur = src / Math.max(0.05, spd);
                return { duration: +outDur.toFixed(3), speed: spd };
            });
        }

        function getSourceDurationSec(fallback) {
            if (autoStopEnabled && autoStopSec > 0) return autoStopSec;
            if (recordedDurationSec && recordedDurationSec > 0) return recordedDurationSec;
            if (isFinite(fallback) && fallback > 0) return fallback;
            return 4;
        }

        function getAutoRampDurationSec(fallback) {
            if (autoStopEnabled && autoStopSec > 0) return autoStopSec;
            if (recordedDurationSec && recordedDurationSec > 0) return recordedDurationSec;
            if (isFinite(fallback) && fallback > 0) return fallback;
            return 4;
        }

        function applyAutoRampFromDuration() {
            if (!autoRampEnabled) return;
            const fileDur = (rawPlayback && isFinite(rawPlayback.duration) && rawPlayback.duration > 0)
                ? rawPlayback.duration
                : undefined;
            const total = getSourceDurationSec(fileDur);
            effects = buildAutoRamp(total);
            selectedEffectIndex = -1;
            renderList();
            renderTimeline();
        }

        function renderTimeline() {
            const tl = document.getElementById('effectsTimeline');
            if (!tl) return;

            if (!Array.isArray(effects) || effects.length === 0) {
                tl.innerHTML = '<div style="color:#666; font-size:11px; display:flex; align-items:center; justify-content:center; width:100%;">Nincs szakasz ‚Äì alap 1√ó</div>';
                return;
            }

            const total = effects.reduce((a, b) => a + (Number(b.duration) || 0), 0) || 1;

            tl.innerHTML = effects.map((e, i) => {
                const dur = Number(e.duration) || 0;
                const spd = Number(e.speed) || 1;
                const cls = (spd < 0.99) ? 'slow' : (spd > 1.01 ? 'fast' : 'norm');
                const sel = (i === selectedEffectIndex) ? 'selected' : '';

                // flex ar√°ny: id≈ëtartam alapj√°n (min√©l hosszabb, ann√°l sz√©lesebb szegmens)
                const flex = Math.max(0.2, dur);
                const label = `${fmtNum(dur, 1)}s ¬∑ ${fmtNum(spd, 2)}√ó`;

                return `<div class="eff-seg ${cls} ${sel}" style="flex:${flex} 1 0%;" title="${label}" onclick="selectEffect(${i})">${fmtNum(spd, 2)}√ó</div>`;
            }).join('');
        }

        function renderList() {
            const listEl = document.getElementById('effectsList');
            const sumEl = document.getElementById('effectsSummary');
            if (!listEl) return;

            renderTimeline();

            listEl.innerHTML = effects.map((e, i) => {
                const d = fmtNum(e.duration, 1);
                const s = fmtNum(e.speed, 2);
                const sel = (i === selectedEffectIndex);
                return `
                    <div class="effect-item selectable ${sel ? 'selected' : ''}" onclick="selectEffect(${i})">
                        <div style="display:flex; gap:8px; align-items:center; min-width:0;">
                            <div style="font-weight:800; color:#03dac6;">#${i + 1}</div>
                            <div style="white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">${d}s ‚Üí ${s}√ó</div>
                        </div>
                        <button class="eff-del" type="button" onclick="event.stopPropagation(); deleteEffect(${i})">T√∂rl√©s</button>
                    </div>
                `;
            }).join('');

            const total = effects.reduce((a, b) => a + (Number(b.duration) || 0), 0);
            if (sumEl) {
                if (effects.length === 0) {
                    sumEl.innerText = 'Nincs szakaszlista: alap√©rtelmezett 1√ó lej√°tsz√°s.';
                } else {
                    sumEl.innerText = `Szakaszok: ${effects.length} db ‚Ä¢ √ñssz-id≈ë: ${fmtNum(total, 1)} s (a feldolgoz√°s ideje)`;
                }
            }
        }

        // --- OVERLAY BET√ñLT√âS ---

        function computeAlphaBBoxFromImage(imgEl) {
            try {
                const w = imgEl.naturalWidth || 0;
                const h = imgEl.naturalHeight || 0;
                if (w <= 0 || h <= 0) return null;

                const tmp = document.createElement('canvas');
                tmp.width = w;
                tmp.height = h;
                const tctx = tmp.getContext('2d', { willReadFrequently: true });
                tctx.clearRect(0, 0, w, h);
                tctx.drawImage(imgEl, 0, 0);

                const data = tctx.getImageData(0, 0, w, h).data;
                let minX = w, minY = h, maxX = -1, maxY = -1;

                // Alpha csatorna: data[i+3]
                for (let y = 0; y < h; y++) {
                    const row = y * w * 4;
                    for (let x = 0; x < w; x++) {
                        const a = data[row + x * 4 + 3];
                        if (a > 0) {
                            if (x < minX) minX = x;
                            if (y < minY) minY = y;
                            if (x > maxX) maxX = x;
                            if (y > maxY) maxY = y;
                        }
                    }
                }

                if (maxX < minX || maxY < minY) return null;

                // +1 mert maxX/maxY pixel is kell
                const sx = minX;
                const sy = minY;
                const sw = (maxX - minX + 1);
                const sh = (maxY - minY + 1);

                // Ha gyakorlatilag teljes k√©p, nem v√°gunk
                if (sx === 0 && sy === 0 && sw === w && sh === h) return null;

                return { sx, sy, sw, sh, w, h };
            } catch (e) {
                console.warn('[OVERLAY] bbox compute failed:', e);
                return null;
            }
        }
        function loadOverlay(i) {
            overlayReady = false;
            overlayCrop = null;
            overlayCroppedOnce = false;

            if (!i || !i.files || !i.files[0]) {
                try {
                    overlayImg.removeAttribute('src');
                } catch (_) { }
                overlayImg.style.display = 'none';
                return;
            }

            const file = i.files[0];

            // Csak PNG-t enged√ºnk (k√ºl√∂nben Safari/Chrome furcs√°n viselkedhet)
            const nameOk = (file.name || '').toLowerCase().endsWith('.png');
            const typeOk = (file.type || '').toLowerCase().includes('png');
            if (!nameOk && !typeOk) {
                statusBadge.innerText = 'OVERLAY NEM PNG';
                statusBadge.style.color = 'red';
                try {
                    overlayImg.removeAttribute('src');
                } catch (_) { }
                overlayImg.style.display = 'none';
                return;
            }

            // Az overlay CSAK canvas-on rajzol√≥dik, az IMG elem rejtve marad
            // (r√©gebben DOM overlay volt, de az nem tartotta az ar√°nyokat)
            overlayImg.style.display = 'none';
            overlayImg.style.pointerEvents = 'none';

            overlayImg.onload = () => {
                overlayReady = true;

                // Alpha bbox kiv√°g√°s: lev√°gjuk a teljesen √°tl√°tsz√≥ peremet, hogy a keret kifusson a sz√©lekig
                overlayCrop = computeAlphaBBoxFromImage(overlayImg);

                // Fontos: az el≈ën√©zetben (IMG overlay) is l√°tsz√≥djon a kiv√°g√°s.
                // Ehhez egyszer (csak egyszer!) fizikailag √∫j PNG-t gener√°lunk a lev√°gott tartalomb√≥l,
                // √©s visszat√∂ltj√ºk az overlayImg-be. √çgy elt≈±nik a k√ºls≈ë √°tl√°tsz√≥ perem miatti fekete s√°v.
                if (overlayCrop && !overlayCroppedOnce) {
                    try {
                        const tmp = document.createElement('canvas');
                        tmp.width = overlayCrop.sw;
                        tmp.height = overlayCrop.sh;
                        const tctx = tmp.getContext('2d');
                        tctx.clearRect(0, 0, tmp.width, tmp.height);
                        tctx.drawImage(
                            overlayImg,
                            overlayCrop.sx, overlayCrop.sy, overlayCrop.sw, overlayCrop.sh,
                            0, 0, overlayCrop.sw, overlayCrop.sh
                        );

                        // Jel√∂lj√ºk, hogy ez m√°r a "kiv√°gott" verzi√≥, hogy ne legyen v√©gtelen onload ciklus
                        overlayCroppedOnce = true;

                        // A tov√°bbi rajzol√°shoz m√°r nincs sz√ºks√©g forr√°s-kiv√°g√°s adatra az el≈ën√©zethez,
                        // de a canvas renderben m√©g haszn√°lhat√≥ lenne. Mivel itt fizikailag lev√°gtuk a k√©pet,
                        // lenull√°zzuk, √≠gy a renderben sima drawImage is teljesen kifut.
                        overlayCrop = null;

                        // √öj PNG bet√∂lt√©se (√∫jra fog futni az onload egyszer)
                        overlayImg.src = tmp.toDataURL('image/png');
                        return;
                    } catch (e) {
                        console.warn('[OVERLAY] preview crop build failed:', e);
                        // ha a kiv√°g√°s gener√°l√°s elhasal, marad a kor√°bbi logika
                    }
                }

                if (overlayCrop) {
                    console.log('[OVERLAY] alpha-crop', overlayCrop);
                }

                console.log('[OVERLAY] loaded', overlayImg.naturalWidth, overlayImg.naturalHeight);
                statusBadge.innerText = 'OVERLAY OK';
                statusBadge.style.color = '#03dac6';
            };

            overlayImg.onerror = (e) => {
                overlayReady = false;
                console.error('[OVERLAY] load error', e);
                statusBadge.innerText = 'OVERLAY HIBA';
                statusBadge.style.color = 'red';
            };

            const r = new FileReader();
            r.onload = (e) => {
                overlayImg.src = e.target.result;
            };
            r.onerror = (e) => {
                overlayReady = false;
                console.error('[OVERLAY] FileReader error', e);
                statusBadge.innerText = 'OVERLAY OLVAS√ÅS HIBA';
                statusBadge.style.color = 'red';
            };
            r.readAsDataURL(file);
        }

        function clearOverlay() {
            overlayReady = false;
            overlayCrop = null;
            overlayCroppedOnce = false;
            try { overlayImg.removeAttribute('src'); } catch (_) { }
            overlayImg.style.display = 'none';
            const input = document.getElementById('overlayFile');
            if (input) input.value = '';
            statusBadge.innerText = 'OVERLAY OFF';
            statusBadge.style.color = '#aaa';
        }

        function isDateOverlayEnabled() {
            const chk = document.getElementById('dateOverlay');
            return !!(chk && chk.checked);
        }

        function getDateOverlayPos() {
            const sel = document.getElementById('dateOverlayPos');
            return sel ? sel.value : 'br';
        }

        function getDateOverlayOffsets() {
            const ox = document.getElementById('dateOverlayOffsetX');
            const oy = document.getElementById('dateOverlayOffsetY');
            const x = ox ? parseInt(ox.value, 10) : 18;
            const y = oy ? parseInt(oy.value, 10) : 18;
            return { x: isFinite(x) ? x : 18, y: isFinite(y) ? y : 18 };
        }

        function updateDateOverlayPreview() {
            const xVal = document.getElementById('dateOverlayOffsetXVal');
            const yVal = document.getElementById('dateOverlayOffsetYVal');
            const off = getDateOverlayOffsets();
            if (xVal) xVal.textContent = String(off.x);
            if (yVal) yVal.textContent = String(off.y);
        }

        function formatDateStamp(d) {
            const y = d.getFullYear();
            const m = String(d.getMonth() + 1).padStart(2, '0');
            const day = String(d.getDate()).padStart(2, '0');
            return `${y}.${m}.${day}`;
        }

        function drawDateStamp(ctx2, w, h) {
            const text = formatDateStamp(new Date());
            const size = Math.max(18, Math.round(w * 0.02));
            const padX = Math.round(size * 0.6);
            const padY = Math.round(size * 0.45);
            ctx2.save();
            ctx2.font = `600 ${size}px "Space Grotesk", sans-serif`;
            const metrics = ctx2.measureText(text);
            const boxW = Math.ceil(metrics.width + padX * 2);
            const boxH = Math.ceil(size + padY * 2);
            const pos = getDateOverlayPos();
            const off = getDateOverlayOffsets();
            let x = w - boxW - Math.round(size * 0.8);
            let y = h - boxH - Math.round(size * 0.7);
            if (pos === 'bl') {
                x = off.x;
                y = h - boxH - off.y;
            } else if (pos === 'tr') {
                x = w - boxW - off.x;
                y = off.y;
            } else if (pos === 'tl') {
                x = off.x;
                y = off.y;
            } else {
                x = w - boxW - off.x;
                y = h - boxH - off.y;
            }
            const r = Math.max(6, Math.round(size * 0.35));
            ctx2.fillStyle = 'rgba(10, 15, 20, 0.65)';
            ctx2.strokeStyle = 'rgba(30, 42, 56, 0.9)';
            ctx2.lineWidth = 1;
            ctx2.beginPath();
            if (typeof ctx2.roundRect === 'function') {
                ctx2.roundRect(x, y, boxW, boxH, r);
            } else {
                const rr = Math.min(r, Math.floor(boxW / 2), Math.floor(boxH / 2));
                ctx2.moveTo(x + rr, y);
                ctx2.arcTo(x + boxW, y, x + boxW, y + boxH, rr);
                ctx2.arcTo(x + boxW, y + boxH, x, y + boxH, rr);
                ctx2.arcTo(x, y + boxH, x, y, rr);
                ctx2.arcTo(x, y, x + boxW, y, rr);
                ctx2.closePath();
            }
            ctx2.fill();
            ctx2.stroke();
            ctx2.fillStyle = '#e6edf3';
            ctx2.textBaseline = 'middle';
            ctx2.fillText(text, x + padX, y + boxH / 2);
            ctx2.restore();
        }

        // --- 4. R√ñGZ√çT√âS (WEBCAM M√ìD) ---
        async function startRecordingNow() {
            const btn = document.getElementById('startBtn');
            syncAutoRampStateFromUI();
            statusBadge.innerText = "FELV√âTEL..."; statusBadge.style.color = "red";
            chunks = [];
            const pick1 = pickRecorderMime(preferredFormat);
            try { await waitForFirstFrame(liveVideo, 2000); } catch (_) { }
            try {
                mediaRecorder = new MediaRecorder(stream, {
                    mimeType: pick1.mime,
                    videoBitsPerSecond,
                    videoKeyFrameInterval: 1000
                });
            } catch (e) {
                try {
                    mediaRecorder = new MediaRecorder(stream, { mimeType: pick1.mime, videoBitsPerSecond });
                } catch (err) {
                    console.error('[REC] MediaRecorder create failed:', err);
                    statusBadge.innerText = 'R√ñGZ√çT√âS HIBA';
                    statusBadge.style.color = 'red';
                    processText.innerText = 'A b√∂ng√©sz≈ë nem tud r√∂gz√≠teni (MediaRecorder). Safari-ban ez gyakori. Pr√≥b√°ld Chrome-ban, vagy Safari Develop ‚Üí Experimental Features alatt MediaRecorder/WebRTC opci√≥kat enged√©lyezni.';
                    if (btn) btn.textContent = 'FELV√âTEL START';
                    return;
                }
            }
            mediaRecorder.ondataavailable = e => { if (e.data.size > 0) chunks.push(e.data) };
            mediaRecorder.onstop = () => {
                recordedDurationSec = Math.max(0, (performance.now() - recordStartMs) / 1000);
                if (autoStopTimer) { clearTimeout(autoStopTimer); autoStopTimer = 0; }
                if (autoRampEnabled) applyAutoRampFromDuration();
                const pick2 = pickRecorderMime(preferredFormat);
                rawVideoBlob = new Blob(chunks, { type: pick2.mime });
                setRawPlaybackSource(rawVideoBlob);
                startProcessingLoop();
            };
            try { mediaRecorder.start(); } catch (_) { }
            isRecording = true;
            recordStartMs = performance.now();
            if (btn) btn.textContent = 'FELV√âTEL STOP';
            if (autoStopEnabled && autoStopSec > 0) {
                autoStopTimer = setTimeout(() => {
                    if (isRecording) initiateCamSequence();
                }, autoStopSec * 1000);
            }
        }

        function initiateCamSequence() {
            if (!stream) {
                console.warn('[CAM] No active stream. Trying to start camera...');
                statusBadge.innerText = 'KAMERA IND√çT√ÅS...';
                statusBadge.style.color = 'yellow';
                pendingStartRecord = true;
                loadCameras();
                return;
            }
            const btn = document.getElementById('startBtn');
            if (!isRecording && pendingStartTimer) {
                clearTimeout(pendingStartTimer);
                pendingStartTimer = 0;
                statusBadge.innerText = 'K√âSZENL√âT';
                statusBadge.style.color = '#03dac6';
                if (btn) btn.textContent = 'FELV√âTEL START';
                return;
            }
            if (isRecording) {
                statusBadge.innerText = "MENT√âS...";
                statusBadge.style.color = "yellow";
                if (autoStopTimer) { clearTimeout(autoStopTimer); autoStopTimer = 0; }
                try { mediaRecorder && mediaRecorder.stop(); } catch (_) { }
                isRecording = false;
                if (btn) btn.textContent = 'FELV√âTEL START';
                return;
            }
            applyStartDelayFromUI();
            if (startDelaySec > 0) {
                statusBadge.innerText = `IND√çT√ÅS ${startDelaySec}s`;
                statusBadge.style.color = 'yellow';
                if (btn) btn.textContent = 'FELV√âTEL STOP';
                pendingStartTimer = setTimeout(() => {
                    pendingStartTimer = 0;
                    void startRecordingNow();
                }, Math.round(startDelaySec * 1000));
                return;
            }
            void startRecordingNow();
        }

        
        // Helper: Overlay rajzol√°s canvas-ra
        function drawOverlayToCanvas(ctx, w, h) {
            if (!overlayReady && !(overlayImg && overlayImg.naturalWidth > 0 && overlayImg.naturalHeight > 0)) {
                return;
            }
            try {
                if (overlayFitMode === 'stretch') {
                    ctx.drawImage(overlayImg, 0, 0, w, h);
                } else {
                    const iw = overlayImg.naturalWidth;
                    const ih = overlayImg.naturalHeight;
                    const iAsp = iw / ih;
                    const dAsp = w / h;
                    let dw, dh;
                    if (overlayFitMode === 'contain') {
                        if (iAsp > dAsp) { dw = w; dh = Math.round(w / iAsp); }
                        else { dh = h; dw = Math.round(h * iAsp); }
                    } else {
                        if (iAsp > dAsp) { dh = h; dw = Math.round(h * iAsp); }
                        else { dw = w; dh = Math.round(w / iAsp); }
                    }
                    const dx = Math.round((w - dw) / 2);
                    const dy = Math.round((h - dh) / 2);
                    ctx.drawImage(overlayImg, dx, dy, dw, dh);
                }
            } catch (e) {
                console.warn('[OVERLAY] drawImage failed:', e);
            }
        }

        // --- 5. F≈ê FELDOLGOZ√ì LOOP (K√ñZ√ñS MINDK√âT M√ìDH√ìZ) ---
        async function startProcessingLoop() {
            isProcessing = true;
            isRecording = false;
            syncAutoRampStateFromUI();
            statusBadge.innerText = "FELDOLGOZ√ÅS..."; statusBadge.style.color = "yellow";
            progressBarContainer.style.display = 'block';
            const startBtn = document.getElementById('startBtn');
            if (startBtn) {
                startBtn.disabled = true;
                startBtn.textContent = 'FELDOLGOZ√ÅS...';
            }
            // Kimenet doboz elrejt√©se feldolgoz√°s alatt
            if (lastOutputBox) lastOutputBox.style.display = 'none';

            liveVideo.style.display = 'none';
            canvas.style.display = 'block';

            // V√°rjuk meg a forr√°s vide√≥ metaadat√°t, hogy tudjuk a k√©par√°nyt
            try {
                if (rawPlayback.readyState < 1) {
                    await new Promise((res) => {
                        const onMeta = () => { rawPlayback.removeEventListener('loadedmetadata', onMeta); res(); };
                        rawPlayback.addEventListener('loadedmetadata', onMeta);
                    });
                }
            } catch (_) { }

            const srcW = rawPlayback.videoWidth || 1280;
            const srcH = rawPlayback.videoHeight || 720;
            const chosen = chooseCanvasSizeByMode(srcW, srcH);

            // Canvas fix m√©ret be√°ll√≠t√°s (a mentett vide√≥ k√©par√°nya IS EZ LESZ)
            canvas.width = chosen.w;
            canvas.height = chosen.h;
            setVideoContainerAspectFromCanvas();

            const baseDuration = getSourceDurationSec(
                (isFinite(rawPlayback.duration) && rawPlayback.duration > 0)
                    ? rawPlayback.duration
                    : undefined
            );
            let trimStartSec = 0;
            if (baseDuration > 0) {
                trimStartSec = await findTrimStartTime(rawPlayback, Math.min(2, baseDuration), 0.05);
            }
            const effectiveDuration = Math.max(0, baseDuration - trimStartSec);

            if (autoRampEnabled) {
                const total = getAutoRampDurationSec(effectiveDuration);
                effects = buildAutoRamp(total);
                selectedEffectIndex = -1;
                renderList();
                renderTimeline();
            } else if (!effects.length) {
                const total = effectiveDuration > 0 ? effectiveDuration : (baseDuration || 4);
                effects = [{ duration: total, speed: 1 }];
                selectedEffectIndex = -1;
                renderList();
                renderTimeline();
            }

            // Zene
            const m = document.getElementById('musicFile');
            let actx, dest, src, hasA = false;
            if (m.files[0]) {
                hasA = true; actx = new (window.AudioContext || window.webkitAudioContext)();
                const b = await m.files[0].arrayBuffer();
                const d = await actx.decodeAudioData(b);
                dest = actx.createMediaStreamDestination();
                src = actx.createBufferSource(); src.buffer = d; src.loop = true; src.connect(dest);
            }

            const cStream = canvas.captureStream(renderFps);
            if (hasA) cStream.addTrack(dest.stream.getAudioTracks()[0]);

            const pick3 = pickRecorderMime(preferredFormat);
            let rec;
            try {
                rec = new MediaRecorder(cStream, { mimeType: pick3.mime, videoBitsPerSecond });
            } catch (e) {
                console.error('[REC] MediaRecorder(captureStream) create failed:', e);
                statusBadge.innerText = 'RENDER HIBA';
                statusBadge.style.color = 'red';
                progressBarContainer.style.display = 'none';
                processText.innerText = 'A b√∂ng√©sz≈ë nem tud canvas streamet r√∂gz√≠teni. Safari-ban ez verzi√≥f√ºgg≈ë. Haszn√°lj Chrome-ot a biztos m≈±k√∂d√©shez.';
                resetUI();
                if (actx) actx.close();
                return;
            }
            const fChunks = [];
            rec.ondataavailable = e => { if (e.data.size > 0) fChunks.push(e.data) };
            rec.onstop = () => {
                const pick4 = pickRecorderMime(preferredFormat);
                const outBlob = new Blob(fChunks, { type: pick4.mime });
                const url = URL.createObjectURL(outBlob);
                const thumb = buildProjectorThumb();

                // Mutassuk meg az oldalon is (mert a macOS sokszor nem nyitja meg a .webm-et)
                setLastOutput(url, pick4.mime, pick4.ext, outBlob.size);

                // Azonnali let√∂lt√©s (marad, de m√°r a v√°lasztott kiterjeszt√©ssel)
                const a = document.createElement('a');
                const now = new Date();
                a.href = url;
                a.download = `360_Video_${now.getHours()}${now.getMinutes()}${now.getSeconds()}.${pick4.ext}`;
                a.click();

                sendToProjector(url, thumb);
                resetUI();
                if (actx) actx.close();
            };

            rec.start();
            if (hasA) src.start(0);

            await seekToTime(rawPlayback, trimStartSec);
            const playOk = await safePlay(rawPlayback, 2000);
            if (!playOk) {
                statusBadge.innerText = 'LEJ√ÅTSZ√ÅS HIBA';
                statusBadge.style.color = 'red';
                processText.innerText = 'A b√∂ng√©sz≈ë nem engedte a lej√°tsz√°st (autoplay).';
                progressBarContainer.style.display = 'none';
                resetUI();
                if (actx) actx.close();
                return;
            }
            await waitForFirstFrame(rawPlayback, 2000);
            const boomerang = !!document.getElementById('boomerangMode')?.checked;
            const pingPong = !!document.getElementById('pingPongMode')?.checked;
            let plan = effects.length > 0 ? effects : [{ duration: 1, speed: 1 }];
            if (boomerang && !pingPong) plan = [...plan, ...plan];
            const reversePlan = pingPong ? [...plan].slice().reverse() : [];

            let totalSec = 0; plan.forEach(p => totalSec += p.duration);
            reversePlan.forEach(p => totalSec += p.duration);
            let processedSec = 0;

            function updateProgress(sec) {
                const p = totalSec > 0 ? Math.min((sec / totalSec) * 100, 100) : 0;
                progressBar.style.width = p + "%";
                processText.innerText = Math.round(p) + "%";
            }

            for (const seg of plan) {
                rawPlayback.playbackRate = seg.speed;
                const s = performance.now();
                const d = seg.duration * 1000;
                const frameMs = renderFps > 0 ? (1000 / renderFps) : 33;
                while (performance.now() - s < d) {
                    drawVideoCoverRotated(ctx, rawPlayback, canvas.width, canvas.height, getEffectiveRotateDeg(rawPlayback));
                    // Overlay: stabilan csak akkor rajzoljuk, ha bet√∂lt√∂tt; tartal√©k naturalWidth alapj√°n
                    drawOverlayToCanvas(ctx, canvas.width, canvas.height);
                    if (isDateOverlayEnabled()) {
                        drawDateStamp(ctx, canvas.width, canvas.height);
                    }

                    const segElapsed = (performance.now() - s) / 1000;
                    updateProgress(processedSec + segElapsed);

                    await new Promise(r => setTimeout(r, frameMs));
                    if (rawPlayback.ended) {
                        if (boomerang && !pingPong) { rawPlayback.currentTime = trimStartSec; await rawPlayback.play(); }
                        else break;
                    }
                }
                processedSec += seg.duration;
                updateProgress(processedSec);
            }

            if (pingPong) {
                rawPlayback.pause();
                const dur = isFinite(rawPlayback.duration) ? rawPlayback.duration : 0;
                const reverseStart = Math.min(dur || 0, trimStartSec + effectiveDuration);
                if (reverseStart > 0) rawPlayback.currentTime = reverseStart;
                for (const seg of reversePlan) {
                    const s = performance.now();
                    const d = seg.duration * 1000;
                    const frameMs = renderFps > 0 ? (1000 / renderFps) : 33;
                    const step = (frameMs / 1000) * (seg.speed || 1);
                    while (performance.now() - s < d) {
                        drawVideoCoverRotated(ctx, rawPlayback, canvas.width, canvas.height, getEffectiveRotateDeg(rawPlayback));
                        drawOverlayToCanvas(ctx, canvas.width, canvas.height);
                        if (isDateOverlayEnabled()) {
                            drawDateStamp(ctx, canvas.width, canvas.height);
                        }

                        const segElapsed = (performance.now() - s) / 1000;
                        updateProgress(processedSec + segElapsed);

                        rawPlayback.currentTime = Math.max(trimStartSec, rawPlayback.currentTime - step);
                        await new Promise(r => setTimeout(r, frameMs));
                        if (rawPlayback.currentTime <= trimStartSec + 0.01) break;
                    }
                    processedSec += seg.duration;
                    updateProgress(processedSec);
                }
            }
            rec.stop();
            rawPlayback.pause();
        }

        function resetUI() {
            isProcessing = false;
            isRecording = false;
            if (pendingStartTimer) { clearTimeout(pendingStartTimer); pendingStartTimer = 0; }
            if (autoStopTimer) { clearTimeout(autoStopTimer); autoStopTimer = 0; }
            progressBarContainer.style.display = 'none'; progressBar.style.width = "0%"; processText.innerText = "";
            const startBtn = document.getElementById('startBtn');
            if (startBtn) {
                startBtn.disabled = false;
                startBtn.textContent = 'FELV√âTEL START';
            }
            statusBadge.innerText = "K√âSZENL√âT"; statusBadge.style.color = "#03dac6";
            if (currentMode === 'cam') {
                // Kamer√°n az el≈ën√©zet maradjon a canvas-on
                liveVideo.style.display = 'none';
                canvas.style.display = 'block';
                syncPreviewCanvasToMode(liveVideo);
                drawLivePreviewLoop();
            }
            else { canvas.style.display = 'block'; } // F√°jl m√≥dban maradjon a canvas a legutols√≥ k√©ppel

            // A kimenet doboz maradhat l√°that√≥ a v√©g√©n, de felv√©telkor/feldolgoz√°skor elrejtj√ºk.
            updateDateOverlayPreview();
        }

        // Kamer√°k bet√∂lt√©se csak user gesture ut√°n (pl. m√≥dv√°lt√°s / gombnyom√°s), k√ºl√∂nben a b√∂ng√©sz≈ë blokkolhatja.
        initOrientationUI(); // Mobil: auto orient√°ci√≥, Desktop: manu√°lis v√°laszt√≥
        applyOutputAspectFromUI();
        applyOverlayFitFromUI();
        applyStartDelayFromUI();
        applyAutoStopFromUI();
        applyQualityFromUI();
        applyUseSourceResolutionFromUI();
        applyCameraResolutionFromUI();
        applyCameraFpsFromUI();
        applyPreviewFpsFromUI();
        applyFormatFromUI();
        applySignalSourceFromUI();
        applySourceCropFromUI();
        applySourceRotateFromUI();
        applyLastOutputAspectFromMode();
        syncLastOutputWidth();
        function updateUiScale() {
            document.documentElement.style.setProperty('--ui-scale', '1');
        }

        function handleOrientationOrResize() {
            updateUiScale();
            applyPreviewAspect();
            if (currentMode === 'cam') {
                syncPreviewCanvasToMode(liveVideo);
            }
            requestAnimationFrame(() => applyLiveVideoTransform());
            setTimeout(applyLiveVideoTransform, 0);
            setTimeout(applyLiveVideoTransform, 50);
            syncLastOutputWidth();
            updateDateOverlayPreview();
        }

        window.addEventListener('resize', handleOrientationOrResize);
        window.addEventListener('orientationchange', () => {
            // Kis k√©sleltet√©s, hogy a viewport stabiliz√°l√≥djon
            setTimeout(handleOrientationOrResize, 100);
            setTimeout(handleOrientationOrResize, 300);
        });
        renderList();

        if (signalInfoTimer) clearInterval(signalInfoTimer);
        signalInfoTimer = setInterval(() => updateSignalInfo(false), 500);
        updateSignalInfo(true);

        // Effektek fel√ºlet inicializ√°l√°s + √©l≈ë friss√≠t√©s
        (function initEffectsUI() {
            const tS = document.getElementById('effTimeSlider');
            const sS = document.getElementById('effSpeedSlider');
            if (tS) tS.addEventListener('input', updateEffectUI);
            if (sS) sS.addEventListener('input', updateEffectUI);
            updateEffectUI();
            renderTimeline();
        })();

        (function initAutoRampUI() {
            const chk = document.getElementById('autoRampMode');
            const presetButtons = document.querySelectorAll('[data-ramp-preset]');
            if (chk) {
                chk.addEventListener('change', () => {
                    autoRampUserTouched = true;
                    setAutoRampEnabled(!!chk.checked);
                    if (autoRampEnabled) applyAutoRampFromDuration();
                });
            }
            presetButtons.forEach((btn) => {
                btn.addEventListener('click', () => {
                    autoRampUserTouched = true;
                    const key = btn.getAttribute('data-ramp-preset');
                    setRampPreset(key);
                });
            });
            setAutoRampEnabled(false);
            if (chk) chk.checked = false;
        })();

        (function initDateOverlayUI() {
            const chk = document.getElementById('dateOverlay');
            if (chk) chk.addEventListener('change', updateDateOverlayPreview);
            updateDateOverlayPreview();
            setInterval(updateDateOverlayPreview, 60 * 1000);
        })();

        (function initPlaybackModeUI() {
            const boomerang = document.getElementById('boomerangMode');
            const pingpong = document.getElementById('pingPongMode');
            if (!boomerang || !pingpong) return;
            boomerang.addEventListener('change', () => {
                if (boomerang.checked) pingpong.checked = false;
            });
            pingpong.addEventListener('change', () => {
                if (pingpong.checked) boomerang.checked = false;
            });
        })();

        window.addEventListener('beforeunload', () => {
            stopLivePreviewLoop();
            if (signalInfoTimer) {
                clearInterval(signalInfoTimer);
                signalInfoTimer = 0;
            }
            try { if (stream) stream.getTracks().forEach(t => t.stop()); } catch (_) { }
        });

        window.addEventListener('pageshow', () => {
            if (autoRampUserTouched) return;
            const chk = document.getElementById('autoRampMode');
            if (chk) {
                chk.checked = false;
                setAutoRampEnabled(false);
            }
        });

        // updateUiScale √©s event listener inicializ√°l√°s m√°r kor√°bban megt√∂rt√©nt
        updateUiScale();
    </script>
</body>

</html>
