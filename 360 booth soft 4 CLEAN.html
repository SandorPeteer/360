<!DOCTYPE html>
<html lang="hu">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>360 selfie ‚Ä¢ v2.1.0 ‚Ä¢ S.P.</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&display=swap');

        :root {
            --bg-0: #0a1016;
            --bg-1: #0e1620;
            --bg-2: #111b27;
            --panel: #0f1822;
            --panel-2: #0b141e;
            --border: #1e2a3a;
            --control-bg: #121c27;
            --control-bg-hover: #162131;
            --control-border: #253244;
            --control-border-strong: #2b3a50;
            --control-radius: 8px;
            --control-radius-sm: 6px;
            --control-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.02);
            --control-height: 30px;
            --control-padding: 6px 8px;
            --control-font: 11px;
            --text: #e8f0f6;
            --muted: #95a3b3;
            --accent: #20d3c1;
            --accent-2: #51f3db;
            --danger: #ff5c7c;
            --shadow: rgba(0, 0, 0, 0.45);
            --ui-scale: 1;
        }

        /* --- DIZ√ÅJN --- */
        html, body {
            margin: 0;
            padding: 0;
            background:
                radial-gradient(900px 500px at 18% -10%, rgba(35, 215, 181, 0.12), transparent 60%),
                radial-gradient(800px 420px at 85% 20%, rgba(94, 234, 212, 0.08), transparent 55%),
                var(--bg-0);
            color: var(--text);
            font-family: 'Space Grotesk', 'Segoe UI', sans-serif;
            height: 100dvh;
            width: 100%;
            min-width: 100%;
            display: flex;
            overflow-x: hidden; /* v√≠zszintes √∫szk√°l√°s tilt√°sa */
            overflow-y: hidden;
            padding-bottom: env(safe-area-inset-bottom);
            overscroll-behavior: none;
            touch-action: pan-y;
            flex: 1 1 auto;
        }

        .container {
            display: flex;
            width: 100%;
            height: 100dvh;
            min-height: 0;
            overflow-x: hidden;
            flex: 1 1 auto;
            align-self: stretch;
        }

        .panel {
            padding: 8px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            gap: 5px;
            overflow-y: auto;
            overflow-x: hidden;
            min-height: 0; /* fontos, hogy mobilon g√∂rgethet≈ë maradjon */
            -webkit-overflow-scrolling: touch;
            background: var(--panel);
            min-width: 0;
        }

        .left-panel {
            width: 28%;
            background: linear-gradient(180deg, var(--panel), var(--panel-2));
            border-right: 1px solid var(--border);
            z-index: 2;
            box-shadow: 5px 0 18px var(--shadow);
            padding-bottom: calc(10px + env(safe-area-inset-bottom));
        }

        .center-panel {
            width: 44%;
            background: var(--bg-1);
            align-items: center;
            justify-content: center;
            position: relative;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            padding-bottom: 10px;
        }

        .right-panel {
            width: 28%;
            background: linear-gradient(180deg, var(--panel), var(--panel-2));
            border-left: 1px solid var(--border);
        }

        .app-header {
            font-size: 17px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 2.5px;
            margin-bottom: 8px;
            text-align: center;
            color: var(--text);
            text-shadow: 0 8px 22px rgba(0, 0, 0, 0.35);
        }

        h3 {
            margin: 0 0 4px 0;
            color: var(--accent);
            border-bottom: 1px solid var(--border);
            padding-bottom: 4px;
            text-transform: uppercase;
            font-size: 11px;
            letter-spacing: 1px;
        }

        label {
            font-size: 10px;
            color: var(--muted);
            text-transform: uppercase;
            margin-top: 2px;
            display: block;
            font-weight: 600;
        }

        .field-stack {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .checkbox-label {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            color: var(--muted);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.6px;
            font-size: 10px;
        }

        .checkbox-label input[type="checkbox"] {
            width: auto;
            min-height: auto;
            margin: 0;
        }

        .inline-row {
            display: flex;
            gap: 6px;
            align-items: center;
        }

        .inline-row input[type="file"] {
            flex: 1 1 auto;
        }

        .btn-clear {
            width: auto;
            padding: 5px 8px;
            background: transparent;
            border: 1px solid var(--border);
            color: var(--muted);
            border-radius: var(--control-radius-sm);
            cursor: pointer;
            font-weight: 700;
        }

        .date-offset-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
        }

        .date-offset-item {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .date-offset-head {
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-size: 9px;
            color: var(--muted);
            text-transform: uppercase;
            letter-spacing: 0.6px;
        }

        input:not([type="checkbox"]):not([type="radio"]):not([type="range"]):not([type="file"]),
        select {
            width: 100%;
            padding: var(--control-padding);
            background: var(--control-bg);
            border: 1px solid var(--control-border);
            color: var(--text);
            border-radius: var(--control-radius);
            box-sizing: border-box;
            margin-bottom: 3px;
            font-size: var(--control-font);
            font-family: inherit;
            min-height: var(--control-height);
            height: var(--control-height);
            box-shadow: var(--control-shadow);
            transition: border-color 0.15s ease, background 0.15s ease, transform 0.05s ease, box-shadow 0.15s ease;

            /* Android/Samsung dark mode fix */
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            color-scheme: dark;
        }

        /* Checkbox √©s radio: nat√≠v megjelen√©s */
        input[type="checkbox"],
        input[type="radio"] {
            width: auto;
            height: auto;
            min-height: 0;
            appearance: auto;
            -webkit-appearance: auto;
            -moz-appearance: auto;
            cursor: pointer;
            margin: 0;
        }

        /* Select ny√≠l (Android custom) */
        select {
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="12" height="8" viewBox="0 0 12 8"><path fill="%2395a3b3" d="M1 1l5 5 5-5"/></svg>');
            background-repeat: no-repeat;
            background-position: right 8px center;
            background-size: 10px;
            padding-right: 24px;
        }

        /* Select option elemek (Android dropdown fix) */
        select option {
            background: var(--control-bg);
            color: var(--text);
            padding: 8px;
            font-size: var(--control-font);
        }

        button {
            width: 100%;
            padding: var(--control-padding);
            background: var(--control-bg);
            border: 1px solid var(--control-border);
            color: var(--text);
            border-radius: var(--control-radius);
            box-sizing: border-box;
            margin-bottom: 3px;
            font-size: var(--control-font);
            font-family: inherit;
            min-height: var(--control-height);
            box-shadow: var(--control-shadow);
            transition: border-color 0.15s ease, background 0.15s ease, transform 0.05s ease, box-shadow 0.15s ease;
        }

        input[type="number"] {
            line-height: 1;
            appearance: textfield;
            -moz-appearance: textfield;
        }

        input[type="number"]::-webkit-outer-spin-button,
        input[type="number"]::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        input:focus,
        select:focus,
        button:focus {
            outline: none;
            border-color: rgba(35, 215, 181, 0.6);
            box-shadow: 0 0 0 2px rgba(35, 215, 181, 0.12);
        }

        button:hover {
            background: var(--control-bg-hover);
        }

        button:active {
            transform: translateY(1px);
        }

        /* A range (cs√∫szka) input ne √∂r√∂k√∂lje az √°ltal√°nos paddinget */
        input[type="range"] {
            padding: 0 !important;
            height: 18px;
            border-radius: 999px;
            background: transparent;
            border: none;
            box-sizing: border-box;
            appearance: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-runnable-track {
            height: 6px;
            background: #0f1722;
            border-radius: 999px;
            border: 1px solid var(--control-border);
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--accent);
            border: 2px solid #0b121a;
            margin-top: -6px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.45);
        }

        input[type="range"]::-moz-range-track {
            height: 6px;
            background: #0f1722;
            border-radius: 999px;
            border: 1px solid var(--control-border);
        }

        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--accent);
            border: 2px solid #0b121a;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.45);
        }

        /* M√ìDV√ÅLT√ì */
        .mode-switch {
            display: flex;
            gap: 6px;
            margin-bottom: 6px;
            background: #121926;
            padding: 3px;
            border-radius: var(--control-radius);
            border: 1px solid var(--control-border);
        }

        .mode-btn {
            flex: 1;
            border: none;
            background: transparent;
            color: var(--muted);
            cursor: pointer;
            padding: 6px;
            font-weight: 700;
        }

        .mode-btn.active {
            background: linear-gradient(135deg, var(--accent), #18b79a);
            color: #051418;
            border-radius: var(--control-radius-sm);
        }

        /* H√öZD IDE */
        #dropZone {
            border: 2px dashed #2c394a;
            background: #0f141d;
            color: var(--muted);
            height: 150px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            cursor: pointer;
            transition: 0.2s;
            margin-top: 10px;
        }

        #dropZone:hover {
            border-color: var(--accent);
            background: #141c26;
            color: var(--text);
        }

        #dropZone.dragover {
            border-color: var(--accent);
            background: #1a2431;
        }

        /* VIDE√ì */
        #videoContainer {
            position: relative;
            width: 100%;
            height: auto;
            aspect-ratio: 16 / 9;
            /* alap: fekv≈ë kont√©ner */
            max-height: 55dvh;
            background: #0a0f14;
            border: none;
            box-shadow: inset 0 0 0 2px var(--border);
            overflow: hidden;
            border-radius: 12px;
            will-change: transform;
            margin: 0 auto;
        }

        #videoContainer video,
        #videoContainer canvas,
        #videoContainer img {
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: #000;
        }

        /* A PNG alpha legyen √°tl√°tsz√≥ a vide√≥/canvas felett (ne legyen fekete h√°tt√©r) */
        #overlayImg {
            background: transparent !important;
        }

        #videoContainer canvas,
        #videoContainer img {
            object-fit: cover;
        }

        #videoContainer video {
            object-fit: cover;
        }

        #badgeRow {
            position: absolute;
            top: 15px;
            right: 15px;
            display: flex;
            gap: 8px;
            align-items: center;
            z-index: 5;
        }

        #statusBadge {
            padding: 6px 12px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 999px;
            font-size: 11px;
            color: var(--accent);
            border: 1px solid var(--border);
            text-transform: uppercase;
            font-weight: bold;
        }

        /* Encoder mode badge - shows GPU or CPU mode */
        #encoderBadge {
            padding: 4px 10px;
            background: rgba(0, 0, 0, 0.9);
            border-radius: 999px;
            font-size: 10px;
            font-weight: 700;
            letter-spacing: 0.5px;
            border: 1px solid;
            display: none;
            text-transform: uppercase;
            white-space: nowrap;
            cursor: pointer;
            user-select: none;
        }

        #encoderBadge.gpu {
            color: #00ff00;
            border-color: #00ff00;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.3);
            display: block;
        }

        #encoderBadge.cpu {
            color: #ffaa00;
            border-color: #ffaa00;
            box-shadow: 0 0 10px rgba(255, 170, 0, 0.3);
            display: block;
        }

        #progressBarContainer {
            width: 100%;
            height: 4px;
            background: #101720;
            margin-top: 15px;
            border-radius: 2px;
            display: none;
            overflow: hidden;
        }

        #progressBar {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, var(--accent), var(--accent-2));
            transition: width 0.2s;
        }

        .btn-start {
            background: linear-gradient(135deg, var(--accent), #149e86);
            color: #fff;
            height: 44px;
            font-size: 14px;
            border: none;
            margin-top: 10px;
            font-weight: bold;
            cursor: pointer;
            border-radius: var(--control-radius);
        }

        .btn-start:hover {
            background: linear-gradient(135deg, #ff5c7c, #ff2d55);
        }

        .btn-projector {
            background: var(--control-bg);
            color: #fff;
            border: 1px solid var(--control-border);
            cursor: pointer;
            font-weight: 700;
        }

        .scroll-area {
            max-height: 150px;
            overflow-y: auto;
            overflow-x: hidden;
            border: 1px solid var(--control-border);
            background: #0c121a;
            padding: 4px;
            border-radius: var(--control-radius);
        }

        #effectsList.scroll-area {
            height: clamp(120px, 18dvh, 200px);
            max-height: clamp(120px, 18dvh, 200px);
            min-height: 120px;
            display: block;
        }

        .effect-item {
            font-size: 11px;
            padding: 5px 6px;
            border-bottom: 1px solid #1b2430;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
        }

        /* EFFEKTEK */
        .eff-compact {
            display: flex;
            flex-direction: column;
            gap: 8px;
            width: 100%;
        }

        .eff-toprow {
            display: grid;
            grid-template-columns: clamp(72px, 10vw, 92px) minmax(0, 1fr) clamp(56px, 10vw, 84px);
            grid-template-areas:
                "tlabel tslider tval"
                "slabel sslider sval";
            column-gap: 12px;
            row-gap: 10px;
            align-items: center;
            width: 100%;
            max-width: 100%;
            overflow: hidden;
        }

        .eff-label {
            font-size: 10px;
            color: var(--muted);
            text-transform: uppercase;
            font-weight: 700;
            margin: 0;
            white-space: nowrap;
            letter-spacing: 0.8px;
            line-height: 1;
        }

        .eff-value {
            font-size: 11px;
            color: var(--accent);
            font-weight: 800;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            line-height: 1;
            font-size: clamp(11px, 1.1vw, 12px);
            justify-self: end;
            text-align: right;
            min-width: 0;
        }

        .eff-slider {
            width: 100%; max-width: 100%;
            margin: 0;
            padding: 0;
            height: 18px;
            min-width: 0;
            max-width: 100%;
            box-sizing: border-box;
        }

        .eff-divider {
            width: 1px;
            height: 18px;
            background: #263244;
            justify-self: center;
            border-radius: 1px;
            display: none; /* alapb√≥l rejtve: iPad-en ne jelenjen meg √°rva cs√≠k */
        }

        /* grid-area k√∂t√©s a k√©t soros eff-toprow-hoz */
        .eff-time-label  { grid-area: tlabel; }
        .eff-time-slider { grid-area: tslider; }
        .eff-time-value  { grid-area: tval; }
        .eff-speed-label { grid-area: slabel; }
        .eff-speed-slider{ grid-area: sslider; }
        .eff-speed-value { grid-area: sval; }

        .eff-bottomrow {
            display: flex;
            justify-content: space-between;
            gap: 10px;
            flex-wrap: wrap;
            width: 100%;
        }

        .eff-preset {
            display: flex;
            gap: 6px;
            align-items: center;
            flex-wrap: wrap;
        }

        .eff-preset button {
            width: auto;
            padding: 5px 8px;
            background: var(--control-bg);
            border: 1px solid var(--control-border);
            border-radius: var(--control-radius-sm);
            cursor: pointer;
            font-weight: 800;
            color: var(--text);
            font-size: 10.5px;
            line-height: 1;
        }

        .eff-preset button.active {
            background: var(--accent);
            color: #071216;
            border: none;
        }

        .eff-actions {
            display: flex;
            gap: 6px;
            align-items: center;
            flex-wrap: wrap;
        }

        .eff-actions button {
            width: auto;
            padding: 6px 10px;
            font-size: 10.5px;
            margin: 0;
            white-space: nowrap;
            border-radius: var(--control-radius-sm);
        }

        .signal-info {
            border: 1px solid var(--border);
            background: #0f141d;
            border-radius: 8px;
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 6px;
            font-size: 11px;
        }

        .signal-head {
            color: var(--accent);
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.8px;
        }

        .signal-row {
            display: flex;
            justify-content: space-between;
            gap: 8px;
            color: var(--muted);
        }

        .signal-row span:last-child {
            color: var(--text);
            font-weight: 600;
        }

        .fold {
            border: 1px solid var(--border);
            background: #0f141d;
            border-radius: 8px;
            padding: 6px 8px;
        }

        .fold summary {
            list-style: none;
            cursor: pointer;
            font-size: 11px;
            text-transform: uppercase;
            color: var(--muted);
            font-weight: 700;
            letter-spacing: 0.7px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .fold summary::-webkit-details-marker {
            display: none;
        }

        .fold .fold-body {
            margin-top: 6px;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .ramp-presets {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            margin-top: 4px;
        }

        .ramp-presets button {
            width: auto;
            padding: 5px 8px;
            font-size: 10.5px;
            border-radius: var(--control-radius-sm);
            background: var(--control-bg);
            border: 1px solid var(--control-border);
            color: var(--text);
            font-weight: 700;
            cursor: pointer;
        }

        .ramp-presets button.active {
            background: var(--accent);
            color: #071216;
            border: none;
        }

        /* Sz≈±kebb n√©zet: a k√©t sor marad, csak a fels≈ë grid t√∂rik */
        @media (max-width: 1100px) {
            .eff-toprow {
                column-gap: 10px;
                row-gap: 10px;
            }
        }

        /* Telefon / keskeny panel: minden egym√°s al√°, c√≠mke + √©rt√©k egy sorban */
        @media (max-width: 700px) {
            .eff-toprow {
                grid-template-columns: 1fr;
                grid-template-areas:
                    "tlabel"
                    "tslider"
                    "tval"
                    "slabel"
                    "sslider"
                    "sval";
            }

            .eff-divider {
                display: none;
            }
        }
        @media (min-width: 2000px) {
            .eff-toprow {
                grid-template-columns:
                    clamp(72px, 8vw, 92px) minmax(0, 1fr) clamp(56px, 8vw, 84px)
                    12px
                    clamp(72px, 8vw, 92px) minmax(0, 1fr) clamp(56px, 8vw, 84px);
                grid-template-areas: "tlabel tslider tval divider slabel sslider sval";
            }
            .eff-divider {
                display: block;
                grid-area: divider;
            }
        }

        /* Extra sz≈±k: kisebb gap √©s bet≈± */
        @media (max-width: 420px) {
            .eff-compact {
                gap: 8px;
            }
            .eff-toprow {
                row-gap: 8px;
            }
            .eff-label {
                font-size: 10px;
            }
        }

        /* Mobil / tablet (iPad/iPhone): panelek egym√°s alatt √°ll√≥ m√≥dban */
        @media (max-width: 1024px) and (orientation: portrait) {
            :root {
                --ui-scale: 1;
            }

            body {
                overflow-y: auto;
                overflow-x: hidden;
            }

            .container {
                display: grid;
                grid-template-columns: 1fr 1fr;
                grid-template-rows: auto 1fr;
                gap: 12px;
                padding: 10px;
                height: auto;
                min-height: 100dvh;
                transform: none;
                width: 100%;
            }

            .left-panel,
            .center-panel,
            .right-panel {
                width: 100%;
            }

            /* Vide√≥ el≈ën√©zet fel√ºl, majd Branding/M√©dia, majd Effektek */
            .center-panel {
                order: 0;
                grid-column: 1 / -1;
                align-items: stretch;
            }
            .left-panel {
                order: 1;
                grid-column: 1;
            }
            .right-panel {
                order: 2;
                grid-column: 2;
            }

            /* iOS/Safari flex+scroll stabiliz√°l√°s */
            .panel {
                min-height: 0;
                padding: 14px;
                gap: 10px;
            }

            /* Effektek: iPad √°ll√≥ m√≥dban ne l√≥gjon ki semmi, √©s legyen mindig l√°that√≥ az id≈ës√°v */
            .eff-divider { display: none; }

            .eff-bottomrow {
                flex-wrap: nowrap;
                align-items: center;
                justify-content: space-between;
                gap: 8px;
            }
            .eff-preset,
            .eff-actions {
                flex-wrap: nowrap;
                gap: 6px;
            }
            .eff-actions button,
            .eff-preset button {
                padding: 7px 9px;
                font-size: 12px;
            }

            #effectsTimeline {
                min-height: 34px;
                height: 34px;
                flex: 0 0 auto;
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }

            #effectsList.scroll-area {
                max-height: 32dvh;
                min-height: 140px;
                overflow-y: auto;
                height: 32dvh;
            }
        }

        /* iPad / tablet fekv≈ë: 2 oszlopos grid, el≈ën√©zet bal fent, branding alatta, vez√©rl≈ëk jobbra */
        @media (max-width: 1366px) and (orientation: landscape) {
            body {
                overflow-y: auto;
                overflow-x: hidden;
            }

            .container {
                display: grid;
                grid-template-columns: minmax(0, 1fr) 360px;
                grid-template-rows: auto 1fr;
                gap: 12px;
                padding: 10px;
                height: auto;
                min-height: 100dvh;
            }

            .center-panel {
                grid-column: 1;
                grid-row: 1;
                align-items: stretch;
                width: auto;
            }

            .left-panel {
                grid-column: 1;
                grid-row: 2;
                width: auto;
            }

            .right-panel {
                grid-column: 2;
                grid-row: 1 / span 2;
                width: auto;
            }

            .panel {
                padding: 14px;
                gap: 10px;
            }

            .app-header {
                font-size: 20px;
                margin-bottom: 14px;
            }

            .btn-start {
                height: 54px;
                font-size: 17px;
            }

            /* Effektek: a f√ºgg≈ëleges elv√°laszt√≥ ne jelenjen meg ezen a m√©reten (cs√≠k bug) */
            .eff-divider { display: none; }

            /* iPad-on a hossz√∫ list√°k legyenek g√∂rgethet≈ëk a panelen bel√ºl */
            #effectsTimeline {
                min-height: 34px;
                height: 34px;
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }

            #effectsList.scroll-area {
                max-height: 28dvh;
                min-height: 140px;
                overflow-y: auto;
                height: 28dvh;
            }

            /* Gombok egy sorban maradjanak */
            .eff-bottomrow {
                flex-wrap: nowrap;
                align-items: center;
                justify-content: space-between;
                gap: 8px;
            }
            .eff-preset,
            .eff-actions {
                flex-wrap: nowrap;
                gap: 6px;
            }
        }

        @media (max-height: 800px) {
            #effectsList.scroll-area {
                height: clamp(110px, 16dvh, 170px);
                max-height: clamp(110px, 16dvh, 170px);
                min-height: 110px;
            }
        }

        @media (max-height: 900px) {
            
        }

        /* DESKTOP ONLY - r√∂vid viewport layout */
        @media (min-width: 1101px) and (max-height: 720px) {
            :root {
                --ui-scale: 1;
            }

            body {
                overflow-y: auto;
                overflow-x: hidden;
            }

            .container {
                display: grid;
                grid-template-columns: 1fr;
                grid-template-rows: auto auto auto;
                gap: 10px;
                padding: 10px;
                height: auto;
                min-height: 100dvh;
                transform: none;
                width: 100%;
            }

            .center-panel,
            .left-panel,
            .right-panel {
                width: 100%;
            }

            .center-panel { order: 0; }
            .right-panel { order: 1; }
            .left-panel { order: 2; }

            .panel {
                padding: 12px;
                gap: 8px;
            }

            .app-header {
                font-size: 18px;
                margin-bottom: 10px;
            }

            #videoContainer {
                max-height: 32dvh;
            }

            #effectsList.scroll-area {
                max-height: 28dvh;
                height: 28dvh;
            }
        }
        /* Effektek id≈ës√°v ‚Äì gyors √°tl√°t√°s */
        #effectsTimeline {
            height: 34px;
            display: flex;
            width: 100%;
            min-width: 0;
            -webkit-overflow-scrolling: touch;
            border: 1px solid var(--border);
            border-radius: 8px;
            background: #0c121a;
            margin-top: 10px;
        }

        .eff-seg {
            display: flex;
            flex: 0 0 auto;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            letter-spacing: 0.3px;
            cursor: pointer;
            user-select: none;
            border-right: 1px solid #1b2430;
            color: #ddd;
            padding: 0 6px;
            min-width: 18px;
        }

        .eff-seg:last-child {
            border-right: none;
        }

        .eff-seg.slow {
            background: rgba(35, 215, 181, 0.18);
        }

        .eff-seg.norm {
            background: rgba(255, 255, 255, 0.06);
        }

        .eff-seg.fast {
            background: rgba(94, 234, 212, 0.18);
        }

        .eff-seg.selected {
            outline: 2px solid var(--accent);
            outline-offset: -2px;
        }

        /* Kijel√∂lhet≈ë lista sor */
        .effect-item.selectable {
            cursor: pointer;
        }

        .effect-item.selectable.selected {
            background: rgba(35, 215, 181, 0.10);
        }

        .eff-del {
            width: auto;
            padding: 6px 8px;
            background: transparent;
            border: 1px solid var(--border);
            color: var(--muted);
            border-radius: 6px;
            cursor: pointer;
            font-size: 11px;
        }

        #effectsSummary {
            font-size: 11px;
            color: var(--muted);
            margin-top: 6px;
            line-height: 1.25;
        }

        /* Utols√≥ kimenet (k√©sz vide√≥) ‚Äì ne nyomja √∂ssze az el≈ën√©zetet, ne legyen t√∫l nagy √°ll√≥ m√≥dban */
        #lastOutput {
            width: 100%;
            max-width: 100%;
            margin-left: auto;
            margin-right: auto;
            align-self: center;
            /* NE stretch: ne h√∫zza sz√©t a dobozt */
        }

        /* A be√©p√≠tett vide√≥-el≈ën√©zet sok b√∂ng√©sz≈ëben (k√ºl√∂n√∂sen √°ll√≥ m√≥dban) sz√©tveri a layoutot.
           A vide√≥ √≠gy is automatikusan let√∂lt≈ëdik, a gombok megmaradnak. */
        #lastOutputVideo {
            display: none;
        }

        #lastOutput video {
            max-height: 34dvh;
        }

        /* √Åll√≥ m√≥dban a player t√∫l magas lenne (9:16) ‚Äì korl√°tozzuk */
        body[data-aspect="portrait"] #lastOutput video {
            max-height: 28dvh;
        }

        /* Ha sz≈±k a viewport, m√©g agressz√≠vebb limit */
        @media (max-height: 800px) {
            #lastOutput video {
                max-height: 28dvh;
            }

            body[data-aspect="portrait"] #lastOutput video {
                max-height: 24dvh;
            }
        }

        /* √Åll√≥ m√≥dban a videoContainer sokkal kisebb helyet foglaljon */

        /* === HAMBURGER MENU === */
        #menuToggle {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 999;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: var(--accent);
            color: #000;
            border: none;
            font-size: 24px;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            transition: opacity 0.3s ease, transform 0.3s ease;
        }

        #menuToggle:hover {
            transform: scale(1.05);
        }

        /* Hide hamburger when menu is open */
        body.menu-open #menuToggle {
            opacity: 0;
            pointer-events: none;
        }

        .menu-drawer {
            position: fixed;
            top: 0;
            right: -100%;
            width: min(400px, 90vw);
            height: 100dvh;
            background: var(--panel);
            z-index: 1000;
            transition: right 0.3s ease;
            overflow-y: auto;
            box-shadow: -5px 0 20px rgba(0,0,0,0.5);
        }

        .menu-drawer.open {
            right: 0;
        }

        .menu-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px;
            border-bottom: 1px solid var(--border);
            position: sticky;
            top: 0;
            background: var(--panel);
            z-index: 10;
        }

        .menu-header h2 {
            margin: 0;
            color: var(--accent);
            font-size: 18px;
        }

        .close-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text);
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1;
        }

        .close-btn:hover {
            background: rgba(255,255,255,0.05);
            border-color: var(--accent);
            color: var(--accent);
        }

        .menu-content {
            padding: 20px;
        }

        .menu-panel {
            display: block !important;
            visibility: visible !important;
            opacity: 1 !important;
        }

        /* REC/STOP icon button */
        .rec-button {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: #ff3b30;
            border: 3px solid #fff;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
            transition: all 0.2s ease;
        }

        .rec-button:hover {
            transform: scale(1.05);
        }

        .rec-button:active {
            transform: scale(0.95);
        }

        /* REC icon - full circle */
        .rec-button.rec-mode::before {
            content: '';
            width: 24px;
            height: 24px;
            background: #fff;
            border-radius: 50%;
        }

        /* STOP icon - square */
        .rec-button.stop-mode::before {
            content: '';
            width: 20px;
            height: 20px;
            background: #fff;
            border-radius: 3px;
        }

        /* Pulsing animation during recording */
        .rec-button.recording {
            animation: pulse 1.5s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% {
                box-shadow: 0 4px 12px rgba(0,0,0,0.4), 0 0 0 0 rgba(255, 59, 48, 0.7);
            }
            50% {
                box-shadow: 0 4px 12px rgba(0,0,0,0.4), 0 0 0 15px rgba(255, 59, 48, 0);
            }
        }

        /* Fullscreen layout for mobile/tablet (includes iPad 6th & 9th gen both orientations) */
        @media (max-width: 1100px) {
            body {
                overflow: hidden;
            }

            .container {
                display: block !important;
                width: 100% !important;
                height: 100dvh !important;
                padding: 0 !important;
                margin: 0 !important;
            }

            .left-panel, .right-panel {
                display: none !important;
            }

            .center-panel {
                width: 100% !important;
                height: 100dvh !important;
                padding: 0 !important;
                margin: 0 !important;
                display: flex !important;
                flex-direction: column !important;
                justify-content: center !important;
                align-items: center !important;
                overflow: visible !important;
                background: var(--bg-0) !important;
            }

            .app-header {
                display: none !important;
            }

            #videoContainer {
                max-height: 75dvh !important;
                width: 100% !important;
                max-width: 100% !important;
                margin: 0 !important;
                flex-shrink: 0 !important;
            }

            #videoContainer video,
            #videoContainer canvas {
                width: 100% !important;
                height: auto !important;
                max-height: 75dvh !important;
            }

            /* Status badge - move to left top on mobile */
            #badgeRow {
                top: 15px !important;
                left: 15px !important;
                right: auto !important;
                gap: 6px !important;
            }

            #statusBadge {
                font-size: 10px !important;
                padding: 5px 10px !important;
            }

            #encoderBadge {
                font-size: 9px !important;
                padding: 3px 8px !important;
            }

            /* Hamburger button - smaller on mobile */
            #menuToggle {
                width: 40px !important;
                height: 40px !important;
                font-size: 20px !important;
                top: 15px !important;
                right: 15px !important;
            }

            /* Progress bar - show during rendering */
            #progressBarContainer {
                position: fixed !important;
                bottom: 100px !important;
                left: 50% !important;
                transform: translateX(-50%) !important;
                width: calc(100% - 40px) !important;
                max-width: 600px !important;
                z-index: 99 !important;
            }

            #processText {
                position: fixed !important;
                bottom: 75px !important;
                left: 50% !important;
                transform: translateX(-50%) !important;
                width: calc(100% - 40px) !important;
                max-width: 600px !important;
                text-align: center !important;
                z-index: 99 !important;
            }

            /* Last output video - show after rendering, hide start button */
            #lastOutput {
                position: fixed !important;
                bottom: 20px !important;
                left: 50% !important;
                transform: translateX(-50%) !important;
                width: calc(100% - 40px) !important;
                max-width: 600px !important;
                z-index: 101 !important;
                margin: 0 !important;
            }

            /* Show mobile start button on mobile - icon style bottom right (symmetric with hamburger) */
            .mobile-start-btn {
                display: flex !important;
                align-items: center !important;
                justify-content: center !important;
                position: fixed !important;
                bottom: 15px !important;
                right: 15px !important;
                left: auto !important;
                transform: none !important;
                width: 40px !important;
                height: 40px !important;
                border-radius: 50% !important;
                background: #ff3b30 !important;
                border: 3px solid #fff !important;
                font-size: 0 !important;
                z-index: 100 !important;
                margin: 0 !important;
                padding: 0 !important;
                box-shadow: 0 4px 12px rgba(0,0,0,0.4) !important;
            }

            .mobile-start-btn:hover {
                transform: scale(1.05) !important;
            }

            .mobile-start-btn:active {
                transform: scale(0.95) !important;
            }

            /* REC icon - white circle inside (smaller for 40px button) */
            .mobile-start-btn::before {
                content: '';
                display: block;
                width: 16px;
                height: 16px;
                background: #fff;
                border-radius: 50%;
                transition: all 0.3s ease;
            }

            /* STOP mode - white square inside + pulsing */
            .mobile-start-btn.recording::before {
                width: 14px;
                height: 14px;
                border-radius: 2px;
            }

            .mobile-start-btn.recording {
                animation: pulseMobile 1.2s ease-in-out infinite !important;
            }

            /* Menu content panels styling */
            .menu-content .panel {
                width: 100% !important;
                padding: 15px !important;
                margin-bottom: 15px !important;
            }

            .menu-content h3 {
                font-size: 14px !important;
                margin-bottom: 10px !important;
            }
        }

        /* Pulse animation for mobile recording button - scale breathing effect */
        @keyframes pulseMobile {
            0%, 100% {
                transform: scale(1);
                box-shadow: 0 4px 12px rgba(0,0,0,0.4), 0 0 0 0 rgba(255, 59, 48, 0.9);
            }
            50% {
                transform: scale(1.15);
                box-shadow: 0 4px 12px rgba(0,0,0,0.4), 0 0 0 8px rgba(255, 59, 48, 0);
            }
        }

        @media (min-width: 1101px) {
            #menuToggle {
                display: none;
            }
        }
    </style>
    <!-- MP4 Muxer for WebCodecs -->
    <script src="https://unpkg.com/mp4-muxer@5.1.2/build/mp4-muxer.js"></script>
</head>

<body>

    <button id="menuToggle" onclick="toggleMenu()">‚ò∞</button>
    <div id="menuDrawer" class="menu-drawer">
        <div class="menu-header">
            <h2>Be√°ll√≠t√°sok</h2>
            <button onclick="toggleMenu()" class="close-btn">‚úï</button>
        </div>
        <div class="menu-content" id="menuContent"></div>
    </div>

    <div class="container">
        <!-- BAL PANEL -->
        <div class="panel left-panel" id="leftPanel">
            <h3>1. Branding & Kijelz≈ë</h3>
            <label>Esem√©ny Neve</label>
            <input type="text" id="brandTitleInput" placeholder="Pl: Moln√°r Esk√ºv≈ë" oninput="updateBranding()">
            <label>Log√≥ (PNG)</label>
            <input type="file" id="logoInput" accept="image/png" onchange="updateLogo()">
            <button class="btn-projector" onclick="openProjectorWindow()">üñ•Ô∏è Kivet√≠t≈ë Nyit√°sa</button>

            <hr style="border-color:#333; width:100%; margin:10px 0;">

            <h3>2. M√©dia elemek</h3>
            <label>Overlay Keret</label>
            <div class="inline-row">
                <input type="file" id="overlayFile" accept="image/png" onchange="loadOverlay(this)">
                <button class="btn-clear" type="button" onclick="clearOverlay()">X</button>
            </div>
            <label>Zene (.mp3)</label>
            <input type="file" id="musicFile" accept="audio/*,.mp3,.m4a,.aac,.wav,.ogg">
            <label style="margin-top:10px; display:flex; align-items:center;">
                <input type="checkbox" id="dateOverlay" style="width:auto; margin-right:8px;"> D√°tum overlay
            </label>
            <label>D√°tum poz√≠ci√≥</label>
            <select id="dateOverlayPos" onchange="updateDateOverlayPreview()">
                <option value="br" selected>Jobb als√≥</option>
                <option value="bl">Bal als√≥</option>
                <option value="tr">Jobb fels≈ë</option>
                <option value="tl">Bal fels≈ë</option>
            </select>
            <div class="date-offset-row">
                <div class="date-offset-item">
                    <div class="date-offset-head">
                        <span>X offset</span>
                        <span id="dateOverlayOffsetXVal">18</span>
                    </div>
                    <input type="range" id="dateOverlayOffsetX" min="0" max="240" step="2" value="18" oninput="updateDateOverlayPreview()">
                </div>
                <div class="date-offset-item">
                    <div class="date-offset-head">
                        <span>Y offset</span>
                        <span id="dateOverlayOffsetYVal">18</span>
                    </div>
                    <input type="range" id="dateOverlayOffsetY" min="0" max="240" step="2" value="18" oninput="updateDateOverlayPreview()">
                </div>
            </div>
        </div>

        <!-- K√ñZ√âP PANEL -->
        <div class="panel center-panel">
            <div class="app-header">360 selfie - KANDO BOOTH</div>

            <div id="videoContainer">
                <!-- √âl≈ëk√©p (csak webkamera m√≥dban) -->
                <video id="liveVideo" autoplay muted playsinline></video>
                <!-- Lej√°tsz√°s (F√°jl m√≥dban √©s renderel√©skor) -->
                <video id="rawPlayback" style="display:none;" muted playsinline></video>
                <canvas id="renderCanvas" width="1280" height="720" style="display:none;"></canvas>
                <img id="overlayImg" style="display:none;">
                <div id="badgeRow">
                    <div id="statusBadge">K√âSZENL√âT</div>
                    <div id="encoderBadge">HW GPU</div>
                </div>

            </div>

            <div id="lastOutput" style="display:none; margin-top:12px; align-self:center;">
                <div
                    style="background:rgba(0,0,0,0.75); border:1px solid #333; border-radius:10px; padding:10px; display:flex; flex-direction:column; gap:10px; align-items:stretch;">
                    <video id="lastOutputVideo" controls playsinline muted
                        style="width:100%; height:auto; aspect-ratio:16/9; object-fit:cover; border-radius:8px; border:1px solid #333;"></video>
                    <div style="flex:1; min-width:0;">
                        <div
                            style="font-size:12px; color:#03dac6; font-weight:800; letter-spacing:1px; text-transform:uppercase;">
                            Utols√≥ vide√≥</div>
                        <div id="lastOutputInfo" style="font-size:11px; color:#aaa; margin-top:4px;">Megtekinthet≈ë
                            itt is, ha a rendszer nem nyitja meg.</div>
                        <div style="display:flex; gap:8px; margin-top:8px; flex-wrap:wrap;">
                            <button id="btnOpenLast"
                                style="width:auto; padding:8px 10px; background:#252525; border:1px solid #333; border-radius:6px; cursor:pointer;">Megnyit√°s
                                √∫j lapon</button>
                            <button id="btnDownloadLast"
                                style="width:auto; padding:8px 10px; background:#03dac6; color:#000; border:none; border-radius:6px; cursor:pointer; font-weight:800;">Let√∂lt√©s</button>
                            <button id="btnHideLast"
                                style="width:auto; padding:8px 10px; background:transparent; border:1px solid #333; color:#aaa; border-radius:6px; cursor:pointer;">Elrejt</button>
                        </div>
                        <div style="font-size:10px; color:#666; margin-top:6px;">MP4-hez szerveres konvert (FFmpeg)
                            aj√°nlott; b√∂ng√©sz≈ëben nem garant√°lt a k√∂zvetlen MP4 r√∂gz√≠t√©s.</div>
                    </div>
                </div>
            </div>

            <div id="progressBarContainer">
                <div id="progressBar"></div>
            </div>
            <p id="processText" style="color:#aaa; font-size:11px; margin-top:5px; text-align:center; height:15px;"></p>

            <!-- Mobile START/STOP button -->
            <button id="mobileStartBtn" class="btn-start mobile-start-btn" onclick="handleMobileStart()" style="display:none;">FELV√âTEL START</button>
        </div>

        <!-- JOBB PANEL -->
        <div class="panel right-panel" id="rightPanel">
            <h3>3. M≈±k√∂d√©si M√≥d</h3>
            <div class="mode-switch">
                <button class="mode-btn active" id="btnModeCam" onclick="setMode('cam')">Kamera ind√≠t√°s</button>
                <button class="mode-btn" id="btnModeFile" onclick="setMode('file')">F√°jl Import</button>
            </div>

            <div id="camControls">
                <label>Kamera Forr√°s</label>
                <select id="camSelect" onchange="startCamera()">
                    <option>Bet√∂lt√©s...</option>
                </select>

                <div id="orientationModeContainer">
                    <!-- Desktop: manu√°lis v√°laszt√≥, Mobil/Tablet: auto info -->
                </div>

                <div style="padding: 8px; background: rgba(32, 211, 193, 0.1); border: 1px solid rgba(32, 211, 193, 0.3); border-radius: 6px; font-size: 10px; color: var(--accent-2); margin: 4px 0;">
                    ‚ÑπÔ∏è Alap c√©l: FULL HD (16:9 / 9:16) 60 fps, ha nem megy, automatikusan 30 fps
                </div>

                <label>Overlay illeszt√©s</label>
                <select id="overlayFit" onchange="applyOverlayFitFromUI()">
                    <option value="stretch" selected>Sz√©lekhez h√∫z (stretch)</option>
                    <option value="cover">Kit√∂lt (crop) (cover)</option>
                    <option value="contain">Teljes k√©p (contain)</option>
                </select>

                <label>Start k√©sleltet√©s (mp)</label>
                <input type="number" id="recordDelay" value="0" min="0" max="30" step="1" oninput="applyStartDelayFromUI()">

                <div class="field-stack">
                    <label class="checkbox-label">
                        <input type="checkbox" id="autoStopEnabled" onchange="applyAutoStopFromUI()" checked>
                        Auto stop (mp)
                    </label>
                    <input type="number" id="autoStopSec" value="10" min="5" max="120" step="1" oninput="applyAutoStopFromUI()">
                </div>

                <details class="fold" id="advancedCameraSettings">
                    <summary>Speci√°lis be√°ll√≠t√°sok</summary>
                    <div class="fold-body">
                        <label>Forr√°s forgat√°s</label>
                        <select id="sourceRotate" onchange="applySourceRotateFromUI()">
                            <option value="0" selected>0¬∞ (nincs)</option>
                            <option value="90">90¬∞ (√°ll√≥ ‚Äì balra)</option>
                            <option value="270">270¬∞ (√°ll√≥ ‚Äì jobbra)</option>
                        </select>

                        <label>Forr√°s v√°g√°s (%)</label>
                        <div class="date-offset-row">
                            <div class="date-offset-item">
                                <div class="date-offset-head">
                                    <span>Fel√ºl</span>
                                    <span id="sourceCropTopVal">0</span>
                                </div>
                                <input type="range" id="sourceCropTop" min="0" max="20" step="1" value="0" oninput="applySourceCropFromUI()">
                            </div>
                            <div class="date-offset-item">
                                <div class="date-offset-head">
                                    <span>Alul</span>
                                    <span id="sourceCropBottomVal">0</span>
                                </div>
                                <input type="range" id="sourceCropBottom" min="0" max="20" step="1" value="0" oninput="applySourceCropFromUI()">
                            </div>
                        </div>
                        <div class="date-offset-row">
                            <div class="date-offset-item">
                                <div class="date-offset-head">
                                    <span>Bal</span>
                                    <span id="sourceCropLeftVal">0</span>
                                </div>
                                <input type="range" id="sourceCropLeft" min="0" max="20" step="1" value="0" oninput="applySourceCropFromUI()">
                            </div>
                            <div class="date-offset-item">
                                <div class="date-offset-head">
                                    <span>Jobb</span>
                                    <span id="sourceCropRightVal">0</span>
                                </div>
                                <input type="range" id="sourceCropRight" min="0" max="20" step="1" value="0" oninput="applySourceCropFromUI()">
                            </div>
                        </div>

                        <label>Kamera felbont√°s</label>
                        <select id="cameraResolution" onchange="applyCameraResolutionFromUI(true)">
                            <option value="1280x720">1280√ó720 (HD)</option>
                            <option value="1920x1080" selected>1920√ó1080 (Full HD)</option>
                            <option value="2560x1440">2560√ó1440 (QHD)</option>
                            <option value="3840x2160">3840√ó2160 (4K)</option>
                        </select>

                        <label>Kamera FPS</label>
                        <select id="cameraFps" onchange="applyCameraFpsFromUI(true)">
                            <option value="24">24 fps</option>
                            <option value="30">30 fps</option>
                            <option value="60" selected>60 fps</option>
                        </select>

                        <label>El≈ën√©zet FPS</label>
                        <select id="previewFps" onchange="applyPreviewFpsFromUI()">
                            <option value="20">20 fps</option>
                            <option value="24">24 fps</option>
                            <option value="30" selected>30 fps</option>
                        </select>

                        <label>Min≈ës√©g</label>
                        <select id="qualityPreset" onchange="applyQualityFromUI()">
                            <option value="low">Alacsony (2.5 Mbps ‚Ä¢ 24 fps)</option>
                            <option value="med">K√∂zepes (5 Mbps ‚Ä¢ 30 fps)</option>
                            <option value="high" selected>Magas (8 Mbps ‚Ä¢ 30 fps)</option>
                        </select>

                        <label style="display:flex; align-items:center; gap:8px;">
                            <input type="checkbox" id="useSourceResolution" style="width:auto;" onchange="applyUseSourceResolutionFromUI()" checked>
                            FHD lock (16:9/9:16) ‚Ä¢ 60 fps
                        </label>

                        <label>Prefer√°lt form√°tum</label>
                        <select id="formatPref" onchange="applyFormatFromUI()">
                            <option value="auto" selected>Auto (b√∂ng√©sz≈ë d√∂nt)</option>
                            <option value="mp4">MP4 (ha t√°mogatott)</option>
                            <option value="webm">WebM</option>
                        </select>
                    </div>
                </details>

                <div class="signal-info">
                    <div class="signal-head">Bej√∂v≈ë jel</div>
                    <div class="signal-row"><span>Forr√°s</span><span id="signalSourceLabel">-</span></div>
                <div class="signal-row"><span>Felbont√°s</span><span id="signalRes">-</span></div>
                <div class="signal-row"><span>FPS (m√©rt)</span><span id="signalFps">-</span></div>
                <div class="signal-row"><span>Auto v√°laszt√°s</span><span id="autoTuneInfo">-</span></div>
                <details class="fold">
                    <summary>R√©szletek</summary>
                        <div class="fold-body">
                            <label>Info m√≥d</label>
                            <select id="signalSource" onchange="applySignalSourceFromUI()">
                                <option value="auto" selected>Automatikus</option>
                                <option value="live">Kamera / √©l≈ë</option>
                                <option value="file">F√°jl / lej√°tsz√°s</option>
                            </select>
                            <div class="signal-row"><span>FPS (be√°ll√≠t√°s)</span><span id="signalFpsTarget">-</span></div>
                        </div>
                    </details>
                </div>

                <button id="startBtn" class="btn-start" onclick="initiateCamSequence()">FELV√âTEL START</button>
            </div>

            <div id="fileControls" style="display:none;">
                <p style="font-size:12px; color:#aaa;">H√∫zd ide a GoPro vide√≥t, vagy kattints a dobozra a tall√≥z√°shoz.
                </p>

                <div id="dropZone" onclick="document.getElementById('videoInput').click()">
                    <span style="font-size:24px;">üìÇ</span>
                    <br>Kattints vagy H√∫zd ide<br>a vide√≥t
                </div>
                <input type="file" id="videoInput" accept="video/*" style="display:none;"
                    onchange="handleFileSelect(this)">

                <button id="processFileBtn" class="btn-start" style="background:#3700b3;" disabled>FELDOLGOZ√ÅS
                    START</button>
            </div>

            <hr style="border-color:#333; width:100%; margin:15px 0;">

            <h3>4. Effektek</h3>
            <label style="margin-top:4px; display:flex; align-items:center;">
                <input type="checkbox" id="autoRampMode" style="width:auto; margin-right:8px;"> Auto ramp (A m√≥d)
            </label>
            <div class="ramp-presets" role="group" aria-label="Ramp preset">
                <button type="button" data-ramp-preset="balanced">Balanced</button>
                <button type="button" data-ramp-preset="smooth">Smooth</button>
                <button type="button" data-ramp-preset="punch">Punch</button>
                <button type="button" data-ramp-preset="slowmo">SlowMo</button>
            </div>

            <div class="eff-compact">
                <div class="eff-toprow">
                    <div class="eff-label eff-time-label">Szakasz</div>
                    <input class="eff-slider eff-time-slider" type="range" id="effTimeSlider" min="0.5" max="10" step="0.5" value="2">
                    <div class="eff-value eff-time-value" id="effTimeVal">2.0 s</div>

                    <div class="eff-divider" aria-hidden="true"></div>

                    <div class="eff-label eff-speed-label">Seb.</div>
                    <input class="eff-slider eff-speed-slider" type="range" id="effSpeedSlider" min="0.25" max="3" step="0.05"
                        value="0.5">
                    <div class="eff-value eff-speed-value" id="effSpeedVal">0.5√ó</div>
                </div>

                <div class="eff-bottomrow">
                    <div class="eff-preset" aria-label="Sebess√©g preset">
                        <button type="button" id="btnSpeed05" onclick="setSpeedPreset(0.5)">0.5√ó</button>
                        <button type="button" id="btnSpeed10" onclick="setSpeedPreset(1.0)">1√ó</button>
                        <button type="button" id="btnSpeed20" onclick="setSpeedPreset(2.0)">2√ó</button>
                    </div>

                    <div class="eff-actions">
                        <button type="button" onclick="addEffect()" style="background:#333;">+ Szakasz</button>
                        <button type="button" onclick="clearEffects()"
                            style="background:transparent; border:1px solid #333; color:#aaa;">T√∂rl√©s</button>
                    </div>
                </div>
            </div>

            <div id="effectsTimeline"
                title="Kattints egy szegmensre: kijel√∂l√©s. A 'Friss√≠t' gomb a kijel√∂lt szakaszt √°t√≠rja a cs√∫szk√°k alapj√°n.">
            </div>
            <div class="scroll-area" id="effectsList" style="margin-top:8px;"></div>
            <div id="effectsSummary"></div>

            <label style="margin-top:10px; display:flex; align-items:center;">
                <input type="checkbox" id="boomerangMode" style="width:auto; margin-right:8px;"> Boomerang
            </label>
            <label style="margin-top:6px; display:flex; align-items:center;">
                <input type="checkbox" id="pingPongMode" style="width:auto; margin-right:8px;"> Oda-vissza (reverse)
            </label>
        </div>
    </div>
    <script>
        // --- V√ÅLTOZ√ìK ---
        let currentMode = 'cam'; // 'cam' vagy 'file'
        let projectorWin = null;
        let stream = null;
        let mediaRecorder = null;
        let chunks = [];
        let effects = [];
        let selectedEffectIndex = -1;
        let isProcessing = false;
        let rawVideoBlob = null;
        let rawVideoUrl = null;
        let currentLogoData = null;
        let autoRampEnabled = false;
        let currentRampPresetKey = 'balanced';
        let qualityPreset = 'high';
        let renderFps = 30;
        let videoBitsPerSecond = 8000000;
        let preferredFormat = 'auto';
        let cameraFps = 60;
        let previewFps = 30;
        let originalPreviewFps = 30; // Store original preview FPS during recording
        let previewFpsManual = 30;
        let cameraWidth = 1920;
        let cameraHeight = 1080;
        let useSourceResolution = true;
        const previewMaxEdge = 1280;
        let autoMaxCameraApplied = false;
        let autoCameraTuned = false;
        let userCameraChoiceTouched = false;
        let sourceCropPct = { top: 0, right: 0, bottom: 0, left: 0 };
        let isRecording = false;
        let pendingStartRecord = false;
        let pendingStartTimer = 0;
        let recordStartMs = 0;
        let recordedDurationSec = 0;

        // WebCodecs support
        let useWebCodecs = false;
        let webCodecsEncoder = null;
        let webCodecsFrameCounter = 0;
        let webCodecsChunks = [];
        let startDelaySec = 0;
        let autoStopEnabled = false;
        let autoStopSec = 10;
        let autoStopTimer = 0;
        let signalSourceMode = 'auto';
        let signalInfoTimer = 0;
        let signalFpsValue = 0;
        let signalFpsFrames = 0;
        let signalFpsLastTs = 0;
        let signalFpsRafId = 0;
        let signalFpsVideoEl = null;
        let autoRampUserTouched = false;
        let encoderPreference = 'auto'; // 'auto' | 'hw' | 'sw'

        // Overlay bet√∂lt√©s √°llapot (stabil rajzol√°s + hibakeres√©s)
        let overlayReady = false;

        // Overlay PNG √°tl√°tsz√≥ perem lev√°g√°s (alpha bbox) ‚Äì hogy a keret t√©nyleg kifusson a sz√©lekig
        // { sx, sy, sw, sh } forr√°s-kiv√°g√°s a PNG-b≈ël
        let overlayCrop = null;

        // V√©gtelen onload ciklus megel≈ëz√©se az overlay k√©pkiv√°g√°sn√°l
        let overlayCroppedOnce = false;

        // Overlay illeszt√©s
        let overlayFitMode = 'stretch'; // 'stretch' | 'cover' | 'contain'

        // Kimenet k√©par√°ny kezel√©s
        let outputAspectMode = 'landscape'; // 'landscape' | 'portrait'
        let isAutoOrientationEnabled = false; // Mobil/tablet: auto, Desktop: manu√°lis

        // Detekt√°ljuk, hogy mobil/tablet vagy desktop
        function isMobileOrTablet() {
            const ua = navigator.userAgent || '';
            const isMobile = /iPhone|iPad|iPod|Android|webOS|BlackBerry|IEMobile|Opera Mini/i.test(ua);
            const isTouch = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
            return isMobile || isTouch;
        }

        function getViewportIsPortrait() {
            if (typeof screen !== 'undefined' && screen.orientation && typeof screen.orientation.type === 'string') {
                if (screen.orientation.type.includes('portrait')) return true;
                if (screen.orientation.type.includes('landscape')) return false;
            }
            const angle = getDeviceRotationAngle();
            if (angle === 90 || angle === -90 || angle === 270) return false;
            if (angle === 0 || angle === 180) return true;
            const vw = window.innerWidth || 0;
            const vh = window.innerHeight || 0;
            if (vw && vh) return vh >= vw;
            if (window.matchMedia) return window.matchMedia('(orientation: portrait)').matches;
            return true;
        }

        function getViewportOrientationMode() {
            return getViewportIsPortrait() ? 'portrait' : 'landscape';
        }

        function getDeviceRotationAngle() {
            if (screen.orientation && typeof screen.orientation.angle === 'number') {
                return screen.orientation.angle;
            }
            if (typeof window.orientation === 'number') {
                return window.orientation;
            }
            return 0;
        }

        function syncBodyAspectMode() {
            if (document && document.body) {
                document.body.dataset.aspect = outputAspectMode;
            }
        }

        // Forr√°s forgat√°s (NDI/telefon √°ll√≥ m√≥dhoz)
        let sourceRotateDeg = 0; // 0 | 90 | 270

        // Automatikus orient√°ci√≥ friss√≠t√©s (mobil/tablet)
        function updateOrientationFromViewport() {
            if (!isAutoOrientationEnabled) return;

            const newMode = getViewportOrientationMode();

            if (outputAspectMode !== newMode) {
                outputAspectMode = newMode;
                syncBodyAspectMode();
                console.log(`[AUTO-ORIENTATION] V√°lt√°s: ${outputAspectMode}`);

                // Friss√≠ts√ºk az UI-t √©s a canvas-t
                applyPreviewAspect();
                if (currentMode === 'cam') {
                    syncPreviewCanvasToMode(liveVideo);
                    if (useSourceResolution && stream) {
                        startCamera();
                    }
                }
                applyLiveVideoTransform();
                updateDateOverlayPreview();
            }
        }

        // Orient√°ci√≥ change listener
        function setupOrientationListener() {
            const orientationMQ = window.matchMedia('(orientation: portrait)');

            // Modern b√∂ng√©sz≈ëk
            if (orientationMQ.addEventListener) {
                orientationMQ.addEventListener('change', updateOrientationFromViewport);
            } else if (orientationMQ.addListener) {
                // R√©gi Safari
                orientationMQ.addListener(updateOrientationFromViewport);
            }

            // Fallback: window.orientationchange (iOS legacy)
            window.addEventListener('orientationchange', () => {
                setTimeout(updateOrientationFromViewport, 100);
            });

            // Fallback: window resize
            window.addEventListener('resize', () => {
                if (isAutoOrientationEnabled) {
                    setTimeout(updateOrientationFromViewport, 100);
                }
            });
        }

        // Forgat√°s: user be√°ll√≠t√°s VAGY automatikus orient√°ci√≥ swap
        function getEffectiveRotateDeg(videoEl) {
            // Explicit user be√°ll√≠t√°s (0, 90, vagy 270)
            const forced = sourceRotateDeg || 0;
            if (forced === 90 || forced === 270) return forced;

            // Automatikus forgat√°s ha az outputAspectMode swap-et okoz
            const v = videoEl || liveVideo || rawPlayback;
            const vw = (v && v.videoWidth) ? v.videoWidth : 0;
            const vh = (v && v.videoHeight) ? v.videoHeight : 0;

            if (vw > 0 && vh > 0) {
                const sourceIsPortrait = vh > vw;
                const wantPortrait = (outputAspectMode === 'portrait');

                if (sourceIsPortrait !== wantPortrait) {
                    if (isAndroidDevice()) {
                        const track = (v && v.srcObject && v.srcObject.getVideoTracks)
                            ? v.srcObject.getVideoTracks()[0]
                            : null;
                        const settings = track && track.getSettings ? track.getSettings() : null;
                        const facing = settings && settings.facingMode ? settings.facingMode : '';
                        const angle = getDeviceRotationAngle();
                        if (wantPortrait) {
                            if (angle === 0) return (facing === 'user') ? 90 : 270;
                            if (angle === 180) return (facing === 'user') ? 270 : 90;
                        }
                        if (facing === 'user' && wantPortrait) return 90;
                    }
                    return 270;
                }
            }

            return 0;
        }

        
        // Helper: Max VH sz√°m√≠t√°s m√≥dhoz
        function getMaxVhForMode(portrait, viewportWidth, viewportHeight) {
            const isViewportPortrait = getViewportIsPortrait();

            if (portrait) {
                // √Åll√≥ kimenet (9:16)
                if (isViewportPortrait) {
                    // Viewport IS √°ll√≥, kimenet IS √°ll√≥ - t√∂k√©letes egyez√©s
                    if (viewportWidth <= 500) return 55;  // Kis mobil
                    if (viewportWidth <= 700) return 60;  // Nagyobb mobil
                    if (viewportWidth <= 1024) return 65; // Tablet
                    return 70;
                } else {
                    // Viewport fekv≈ë, DE kimenet √°ll√≥ - ritk√°bb eset
                    if (viewportWidth <= 900) return 40;
                    return 45;
                }
            } else {
                // Fekv≈ë kimenet (16:9)
                if (!isViewportPortrait) {
                    // Viewport IS fekv≈ë, kimenet IS fekv≈ë - t√∂k√©letes egyez√©s
                    if (viewportWidth <= 700) return 55;  // Kis mobil fekv≈ë
                    if (viewportWidth <= 900) return 60;  // Nagyobb mobil fekv≈ë
                    if (viewportWidth <= 1024) return 65; // Tablet fekv≈ë
                    return 70;
                } else {
                    // Viewport √°ll√≥, DE kimenet fekv≈ë - sz√©les s√°v kell
                    if (viewportWidth <= 500) return 35;  // Kis mobil
                    if (viewportWidth <= 700) return 40;  // Nagyobb mobil
                    if (viewportWidth <= 1024) return 45; // Tablet/iPad
                    return 55;
                }
            }
        }

        function applyPreviewAspect() {
            const vc = document.getElementById('videoContainer');
            if (!vc) return;

            const viewportWidth = window.innerWidth || 0;
            const viewportHeight = window.innerHeight || 0;

            vc.style.transformOrigin = '50% 50%';
            vc.style.transform = 'none';

            // Haszn√°ljuk a canvas t√©nyleges ar√°ny√°t (ami a kamera nat√≠v ar√°nya)
            if (canvas && canvas.width && canvas.height) {
                const canvasAspect = canvas.width / canvas.height;
                const isCanvasPortrait = canvasAspect < 1;

                // Dinamikus maxVh √©rt√©k a kamera ar√°ny√°hoz
                const maxVh = getMaxVhForMode(isCanvasPortrait, viewportWidth, viewportHeight);

                vc.style.aspectRatio = `${canvas.width} / ${canvas.height}`;

                if (isCanvasPortrait) {
                    // √Åll√≥ kamera ar√°ny
                    vc.style.width = 'auto';
                    vc.style.height = `${maxVh}dvh`;
                    vc.style.maxHeight = `${maxVh}dvh`;
                    vc.style.maxWidth = '100%';
                } else {
                    // Fekv≈ë kamera ar√°ny
                    vc.style.width = '100%';
                    vc.style.height = 'auto';
                    vc.style.maxHeight = `${maxVh}dvh`;
                    vc.style.maxWidth = '100%';
                }
            }
            syncLastOutputWidth();
        }

        function applySourceRotateFromUI() {
            const sel = document.getElementById('sourceRotate');
            const v = sel ? parseInt(sel.value, 10) : 0;
            sourceRotateDeg = (v === 90 || v === 270) ? v : 0;

            // El≈ën√©zet keret + vide√≥ transzform friss√≠t√©se
            applyPreviewAspect();
            if (currentMode === 'cam') {
                syncPreviewCanvasToMode(liveVideo);
            }
            requestAnimationFrame(() => applyLiveVideoTransform());
            setTimeout(applyLiveVideoTransform, 0);
        }

        function applyLiveVideoTransform() {
            const vc = document.getElementById('videoContainer');
            if (!vc || !liveVideo) return;

            const eff = getEffectiveRotateDeg(liveVideo);
            const deg = ((eff % 360) + 360) % 360;

            // A liveVideo elemet nem CSS-sel m√©retezz√ºk/forgatjuk, mert abb√≥l j√∂n a zoom/kicsiny√≠t√©s.
            // A korrekt el≈ën√©zetet a canvas-ra rajzoljuk (drawLivePreviewLoop).
            liveVideo.style.transform = 'none';
            liveVideo.style.objectFit = 'cover';
            liveVideo.style.transformOrigin = '50% 50%';

            // A st√°tusz badge maradjon a kont√©nerben, nem forgatjuk.
            // A forgat√°s a canvas rajzol√°sn√°l t√∂rt√©nik.

            // Biztons√°g: ha valaki m√©gis bekapcsolja a liveVideo megjelen√≠t√©st, legal√°bb forogjon.
            if (liveVideo.style.display !== 'none' && deg !== 0) {
                liveVideo.style.transform = `rotate(${deg}deg)`;
            }
        }

        function pickSignalVideoEl() {
            if (signalSourceMode === 'live') return liveVideo;
            if (signalSourceMode === 'file') return rawPlayback;
            if (currentMode === 'cam' && liveVideo && liveVideo.srcObject) return liveVideo;
            if (rawPlayback && rawPlayback.src) return rawPlayback;
            return liveVideo || rawPlayback;
        }

        function stopSignalFpsMeter() {
            if (signalFpsVideoEl && typeof signalFpsVideoEl.cancelVideoFrameCallback === 'function' && signalFpsRafId) {
                try { signalFpsVideoEl.cancelVideoFrameCallback(signalFpsRafId); } catch (_) { }
            }
            signalFpsRafId = 0;
            signalFpsVideoEl = null;
            signalFpsFrames = 0;
            signalFpsLastTs = 0;
            signalFpsValue = 0;
        }

        function startSignalFpsMeter(el) {
            stopSignalFpsMeter();
            if (!el) return;
            signalFpsVideoEl = el;
            if (typeof el.requestVideoFrameCallback === 'function') {
                const onFrame = (now) => {
                    signalFpsFrames += 1;
                    if (!signalFpsLastTs) signalFpsLastTs = now;
                    const dt = now - signalFpsLastTs;
                    if (dt >= 1000) {
                        signalFpsValue = (signalFpsFrames * 1000) / dt;
                        signalFpsFrames = 0;
                        signalFpsLastTs = now;
                    }
                    signalFpsRafId = el.requestVideoFrameCallback(onFrame);
                };
                signalFpsRafId = el.requestVideoFrameCallback(onFrame);
            }
        }

        function updateSignalInfo(forceRestart) {
            const srcLabel = document.getElementById('signalSourceLabel');
            const resEl = document.getElementById('signalRes');
            const fpsEl = document.getElementById('signalFps');
            const fpsTargetEl = document.getElementById('signalFpsTarget');
            const autoEl = document.getElementById('autoTuneInfo');
            const el = pickSignalVideoEl();

            if (!el) return;
            if (forceRestart || signalFpsVideoEl !== el) startSignalFpsMeter(el);

            const hasStream = !!el.srcObject;
            const srcText = hasStream ? 'Kamera (MediaStream)' : (el.src ? 'F√°jl / stream' : 'Nincs jel');
            if (srcLabel) srcLabel.textContent = srcText;

            const w = el.videoWidth || 0;
            const h = el.videoHeight || 0;
            if (resEl) resEl.textContent = (w && h) ? `${w}√ó${h}` : '-';

            if (fpsEl) fpsEl.textContent = signalFpsValue ? `${signalFpsValue.toFixed(1)} fps` : '-';

            let targetFpsText = '-';
            if (hasStream) {
                const track = el.srcObject.getVideoTracks ? el.srcObject.getVideoTracks()[0] : null;
                const settings = track && track.getSettings ? track.getSettings() : null;
                if (settings && settings.frameRate) targetFpsText = `${settings.frameRate} fps`;
            } else if (el === rawPlayback) {
                targetFpsText = renderFps ? `${renderFps} fps` : '-';
            }
            if (fpsTargetEl) fpsTargetEl.textContent = targetFpsText;
            if (autoEl) {
                autoEl.textContent = useSourceResolution ? 'LOCK FHD' : (autoCameraTuned ? 'AUTO OK' : '-');
            }
        }

        function fmtMbps(bps) {
            const n = Number(bps);
            if (!isFinite(n) || n <= 0) return '';
            const mbps = n / 1000000;
            return `${mbps % 1 === 0 ? mbps.toFixed(0) : mbps.toFixed(1)}M`;
        }

        function isAndroidDevice() {
            return /Android/i.test(navigator.userAgent || '');
        }

        function getSupportedMp4Mime() {
            if (!window.MediaRecorder || !MediaRecorder.isTypeSupported) return '';
            const mp4 = [
                'video/mp4;codecs=avc1.42E01E,mp4a.40.2',
                'video/mp4;codecs=avc1.42E01E',
                'video/mp4'
            ];
            for (const m of mp4) {
                try {
                    if (MediaRecorder.isTypeSupported(m)) return m;
                } catch (_) { }
            }
            return '';
        }

        function autoPreferMp4OnAndroid() {
            if (!isAndroidDevice()) return;
            if (preferredFormat !== 'auto') return;
            const mp4 = getSupportedMp4Mime();
            if (!mp4) return;
            preferredFormat = 'mp4';
            const sel = document.getElementById('formatPref');
            if (sel) sel.value = 'mp4';
        }

        function isH264Mime(mime) {
            const m = String(mime || '').toLowerCase();
            return m.includes('avc1') || m.includes('h264') || m.includes('mp4');
        }

        function getRecorderCodecLabel(mime) {
            const m = String(mime || '').toLowerCase();
            if (m.includes('avc1') || m.includes('h264') || m.includes('mp4')) return 'MR H.264';
            if (m.includes('vp9')) return 'MR VP9';
            if (m.includes('vp8')) return 'MR VP8';
            if (m.includes('av1')) return 'MR AV1';
            return 'MR';
        }

        function buildRecorderBadgeText(mime, settings, bps) {
            const label = getRecorderCodecLabel(mime);
            const w = settings && settings.width ? settings.width : 0;
            const h = settings && settings.height ? settings.height : 0;
            const fr = settings && settings.frameRate ? settings.frameRate : 0;
            const parts = [label];
            if (w && h && fr) parts.push(`${w}x${h}@${Math.round(fr)}fps`);
            if (bps) parts.push(fmtMbps(bps));
            return parts.filter(Boolean).join(' ');
        }

        function setEncoderBadge(text, mode) {
            const badge = document.getElementById('encoderBadge');
            if (!badge) return;
            if (!text || !mode) {
                badge.className = '';
                badge.textContent = '';
                return;
            }
            badge.textContent = text;
            badge.className = mode;
        }

        function applyEncoderPreference() {
            if (encoderPreference === 'sw') {
                useWebCodecs = false;
                setEncoderBadge('SW READY', 'cpu');
                autoPreferMp4OnAndroid();
                return;
            }
            if (encoderPreference === 'hw') {
                detectWebCodecsSupport(true);
                return;
            }
            detectWebCodecsSupport(false);
        }

        function toggleEncoderPreference() {
            if (isRecording || isProcessing) return;
            encoderPreference = (encoderPreference === 'hw') ? 'sw' : 'hw';
            applyEncoderPreference();
        }

        function buildEncoderBadgeText(cfg, modeLabel) {
            if (!cfg) return modeLabel || '';
            const codec = cfg.codec || 'avc1';
            const w = cfg.width || 0;
            const h = cfg.height || 0;
            const fr = cfg.framerate || cfg.frameRate || 0;
            const br = cfg.bitrate || 0;
            const parts = [modeLabel, codec];
            if (w && h && fr) parts.push(`${w}x${h}@${Math.round(fr)}fps`);
            if (br) parts.push(fmtMbps(br));
            return parts.filter(Boolean).join(' ');
        }

        // Orient√°ci√≥ UI inicializ√°l√°s (auto + manu√°lis v√°laszt√≥)
        let orientationListenerReady = false;
        function initOrientationUI() {
            const container = document.getElementById('orientationModeContainer');
            if (!container) return;

            const isMobile = isMobileOrTablet();

            container.innerHTML = `
                <label>Orient√°ci√≥ m√≥d</label>
                <select id="outputAspect" onchange="applyOutputAspectFromUI()">
                    <option value="auto">Auto (szenzor)</option>
                    <option value="landscape">Fekv≈ë (16:9)</option>
                    <option value="portrait">√Åll√≥ (9:16)</option>
                </select>
                ${isMobile ? '<div style="padding: 6px 8px; background: rgba(32, 211, 193, 0.12); border: 1px solid rgba(32, 211, 193, 0.35); border-radius: 6px; font-size: 10px; color: var(--accent-2); margin: 4px 0;">üì± Ha az auto nem j√≥, v√°lts k√©zire itt.</div>' : ''}
            `;

            const sel = container.querySelector('#outputAspect');
            if (sel) {
                if (isMobile) {
                    sel.value = 'auto';
                    isAutoOrientationEnabled = true;
                } else {
                    sel.value = outputAspectMode;
                    isAutoOrientationEnabled = false;
                }
            }

            if (isAutoOrientationEnabled) {
                updateOrientationFromViewport();
                if (!orientationListenerReady) {
                    setupOrientationListener();
                    orientationListenerReady = true;
                }
            }
        }

        function applyOutputAspectFromUI() {
            const sel = document.getElementById('outputAspect');
            if (sel) {
                const v = sel.value;
                if (v === 'auto') {
                    isAutoOrientationEnabled = true;
                    updateOrientationFromViewport();
                    if (!orientationListenerReady) {
                        setupOrientationListener();
                        orientationListenerReady = true;
                    }
                } else {
                    isAutoOrientationEnabled = false;
                    outputAspectMode = v;
                }
            }
            syncBodyAspectMode();

            // El≈ën√©zet keret friss√≠t√©se
            applyPreviewAspect();

            // Utols√≥ kimenet el≈ën√©zet
            applyLastOutputAspectFromMode();

            // Ha kamer√°n vagyunk, igaz√≠tsuk az el≈ën√©zeti canvas m√©ret√©t
            if (currentMode === 'cam') {
                syncPreviewCanvasToMode(liveVideo);
                if (useSourceResolution && stream) {
                    startCamera();
                }
            }

            // A vide√≥ transzform √∫jrasz√°mol√°sa
            requestAnimationFrame(() => applyLiveVideoTransform());
            setTimeout(applyLiveVideoTransform, 0);
            setTimeout(applyLiveVideoTransform, 50);
            updateDateOverlayPreview();
        }

        function applyOverlayFitFromUI() {
            const sel = document.getElementById('overlayFit');
            overlayFitMode = sel ? sel.value : 'stretch';
            // Az overlay illeszt√©s most m√°r csak a canvas rajzol√°sn√°l haszn√°l√≥dik (drawOverlayToCanvas)
        }

        function applySourceCropFromUI() {
            const top = document.getElementById('sourceCropTop');
            const right = document.getElementById('sourceCropRight');
            const bottom = document.getElementById('sourceCropBottom');
            const left = document.getElementById('sourceCropLeft');
            const t = top ? parseInt(top.value, 10) : 0;
            const r = right ? parseInt(right.value, 10) : 0;
            const b = bottom ? parseInt(bottom.value, 10) : 0;
            const l = left ? parseInt(left.value, 10) : 0;
            sourceCropPct = {
                top: isFinite(t) ? t : 0,
                right: isFinite(r) ? r : 0,
                bottom: isFinite(b) ? b : 0,
                left: isFinite(l) ? l : 0
            };
            const topVal = document.getElementById('sourceCropTopVal');
            const rightVal = document.getElementById('sourceCropRightVal');
            const bottomVal = document.getElementById('sourceCropBottomVal');
            const leftVal = document.getElementById('sourceCropLeftVal');
            if (topVal) topVal.textContent = String(sourceCropPct.top);
            if (rightVal) rightVal.textContent = String(sourceCropPct.right);
            if (bottomVal) bottomVal.textContent = String(sourceCropPct.bottom);
            if (leftVal) leftVal.textContent = String(sourceCropPct.left);
        }

        function getSourceCropPx(videoEl) {
            const vw = videoEl.videoWidth || 0;
            const vh = videoEl.videoHeight || 0;
            const t = Math.min(40, Math.max(0, sourceCropPct.top));
            const r = Math.min(40, Math.max(0, sourceCropPct.right));
            const b = Math.min(40, Math.max(0, sourceCropPct.bottom));
            const l = Math.min(40, Math.max(0, sourceCropPct.left));
            return {
                top: Math.round(vh * (t / 100)),
                right: Math.round(vw * (r / 100)),
                bottom: Math.round(vh * (b / 100)),
                left: Math.round(vw * (l / 100))
            };
        }

        function applyStartDelayFromUI() {
            const input = document.getElementById('recordDelay');
            const v = input ? parseFloat(input.value) : 0;
            startDelaySec = isFinite(v) && v >= 0 ? v : 0;
        }

        function applyAutoStopFromUI() {
            const chk = document.getElementById('autoStopEnabled');
            const sec = document.getElementById('autoStopSec');
            autoStopEnabled = !!(chk && chk.checked);
            const v = sec ? parseFloat(sec.value) : 10;
            autoStopSec = isFinite(v) && v > 0 ? v : 10;
            if (sec) sec.disabled = !autoStopEnabled;
        }

        function applyQualityFromUI() {
            const sel = document.getElementById('qualityPreset');
            qualityPreset = sel ? sel.value : 'high';

            if (qualityPreset === 'low') {
                renderFps = 24;
                videoBitsPerSecond = 2500000;
            } else if (qualityPreset === 'high') {
                renderFps = 30;
                videoBitsPerSecond = 8000000;
            } else {
                renderFps = 30;
                videoBitsPerSecond = 5000000;
            }
        }

        function applyCameraFpsFromUI(fromUser) {
            const sel = document.getElementById('cameraFps');
            const v = sel ? parseInt(sel.value, 10) : 60;
            cameraFps = isFinite(v) ? v : 60;
            if (fromUser) userCameraChoiceTouched = true;
            if (currentMode === 'cam' && stream) {
                startCamera();
            }
        }

        function applyCameraResolutionFromUI(fromUser) {
            const sel = document.getElementById('cameraResolution');
            const val = sel ? String(sel.value || '1280x720') : '1280x720';
            const parts = val.split('x').map((n) => parseInt(n, 10));
            const w = parts[0] || 1280;
            const h = parts[1] || 720;
            cameraWidth = w;
            cameraHeight = h;
            if (fromUser) userCameraChoiceTouched = true;
            if (currentMode === 'cam' && stream) {
                startCamera();
            }
        }

        function setSelectValueOrAdd(select, value, label) {
            if (!select) return;
            const str = String(value);
            const found = Array.from(select.options).some((opt) => opt.value === str);
            if (!found) {
                const opt = document.createElement('option');
                opt.value = str;
                opt.textContent = label || str;
                select.prepend(opt);
            }
            select.value = str;
        }

        function applyPreviewFpsFromUI() {
            const sel = document.getElementById('previewFps');
            const v = sel ? parseInt(sel.value, 10) : 30;
            previewFpsManual = isFinite(v) ? v : 30;
            if (!useSourceResolution) {
                previewFps = previewFpsManual;
            }
        }

        function applyUseSourceResolutionFromUI() {
            const chk = document.getElementById('useSourceResolution');
            useSourceResolution = !!(chk && chk.checked);
            const resSel = document.getElementById('cameraResolution');
            const fpsSel = document.getElementById('cameraFps');
            const previewSel = document.getElementById('previewFps');
            if (resSel) resSel.disabled = useSourceResolution;
            if (fpsSel) fpsSel.disabled = useSourceResolution;
            if (previewSel) previewSel.disabled = useSourceResolution;
            if (useSourceResolution) {
                autoCameraTuned = false;
            } else {
                previewFps = previewFpsManual;
                if (previewSel) previewSel.value = String(previewFpsManual);
            }
            applyPreviewAspect();
            syncPreviewCanvasToMode(liveVideo);
            syncLastOutputWidth();
            if (currentMode === 'cam' && stream) {
                startCamera();
            }
        }

        function applyPreviewFpsLockFromSettings(settings) {
            if (!useSourceResolution) return;
            const baseFps = settings && settings.frameRate ? settings.frameRate : (cameraFps || 60);
            const autoFps = Math.max(1, Math.round(baseFps / 5));
            previewFps = autoFps;
            setSelectValueOrAdd(
                document.getElementById('previewFps'),
                String(autoFps),
                `${autoFps} fps (lock)`
            );
        }

        function getAspectCandidates(targetAspect, maxW, maxH) {
            const base = [
                { w: 3840, h: 2160 },
                { w: 2560, h: 1440 },
                { w: 1920, h: 1080 },
                { w: 1280, h: 720 },
                { w: 960, h: 540 },
                { w: 854, h: 480 },
                { w: 640, h: 360 }
            ];
            const list = base.map((c) => {
                const isPortrait = targetAspect < 1;
                return isPortrait ? { w: c.h, h: c.w } : { w: c.w, h: c.h };
            });
            return list.filter((c) => c.w <= maxW && c.h <= maxH);
        }

        function scoreSettings(s) {
            const fps = Number(s.frameRate) || 0;
            const area = (Number(s.width) || 0) * (Number(s.height) || 0);
            return { fps, area };
        }

        async function autoTuneCameraForBestFps(track) {
            if (!track || typeof track.getCapabilities !== 'function') return;
            const caps = track.getCapabilities();
            if (!caps || !caps.width || !caps.height || !caps.frameRate) return;

            const maxW = caps.width.max || caps.width.ideal || 0;
            const maxH = caps.height.max || caps.height.ideal || 0;
            const maxFps = caps.frameRate.max || caps.frameRate.ideal || 60;
            if (!maxW || !maxH) return;

            const targetAspect = (outputAspectMode === 'portrait') ? (9 / 16) : (16 / 9);
            const candidates = getAspectCandidates(targetAspect, maxW, maxH);
            if (!candidates.length) return;

            let best = null;
            for (const c of candidates) {
                try {
                    await track.applyConstraints({
                        width: { ideal: c.w },
                        height: { ideal: c.h },
                        frameRate: { ideal: maxFps }
                    });
                } catch (_) {
                    continue;
                }
                const s = track.getSettings ? track.getSettings() : {};
                const score = scoreSettings(s);
                if (!best || score.fps > best.score.fps || (score.fps === best.score.fps && score.area > best.score.area)) {
                    best = { score, settings: s, constraints: c };
                }
            }

            if (best && best.constraints) {
                try {
                    await track.applyConstraints({
                        width: { ideal: best.constraints.w },
                        height: { ideal: best.constraints.h },
                        frameRate: { ideal: maxFps }
                    });
                } catch (_) { }
            }
        }

        async function enforceLockedCameraConstraints(track) {
            if (!track || !useSourceResolution || typeof track.applyConstraints !== 'function') return;
            const caps = (typeof track.getCapabilities === 'function') ? track.getCapabilities() : null;
            const maxFps = caps && caps.frameRate && caps.frameRate.max ? caps.frameRate.max : 0;
            const wantPortrait = outputAspectMode === 'portrait';
            const lockWidth = wantPortrait ? 1080 : 1920;
            const lockHeight = wantPortrait ? 1920 : 1080;
            const targetAspect = wantPortrait ? (9 / 16) : (16 / 9);
            const attempts = [
                ...(maxFps >= 60 ? [{ w: lockWidth, h: lockHeight, fps: 60, exact: true }] : []),
                ...(maxFps >= 30 ? [{ w: lockWidth, h: lockHeight, fps: 30, exact: true }] : []),
                { w: lockWidth, h: lockHeight, fps: 60, minFps: 30 },
                { w: lockWidth, h: lockHeight, fps: 30, minFps: 24 },
                { w: 1280, h: 720, fps: 60, minFps: 30 },
                { w: 1280, h: 720, fps: 30, minFps: 24 },
                { w: 0, h: 0, fps: 30, minFps: 0 }
            ];

            for (const a of attempts) {
                const c = { aspectRatio: targetAspect };
                if (a.w) c.width = { ideal: a.w };
                if (a.h) c.height = { ideal: a.h };
                if (a.fps && a.exact) {
                    c.frameRate = { exact: a.fps };
                } else if (a.fps) {
                    c.frameRate = { ideal: a.fps, ...(a.minFps ? { min: a.minFps } : {}) };
                }
                try {
                    await track.applyConstraints(c);
                } catch (_) {
                    continue;
                }
                const s = track.getSettings ? track.getSettings() : null;
                if (!s) break;
                const ratioOk = isAspectClose(s.width, s.height, targetAspect, 0.04);
                const fpsOk = s.frameRate ? s.frameRate >= (a.minFps || 0) : true;
                if (ratioOk && fpsOk) break;
            }
        }

        function applySignalSourceFromUI() {
            const sel = document.getElementById('signalSource');
            signalSourceMode = sel ? sel.value : 'auto';
            updateSignalInfo(true);
        }

        function applyFormatFromUI() {
            const sel = document.getElementById('formatPref');
            preferredFormat = sel ? sel.value : 'auto';
        }

        function setVideoContainerAspectFromCanvas() {
            const vc = document.getElementById('videoContainer');
            if (!vc) return;

            // A renderCanvas m√©rete dikt√°lja a kimeneti k√©par√°nyt (ez lesz a mentett vide√≥ is)
            if (canvas && canvas.width && canvas.height) {
                vc.style.aspectRatio = `${canvas.width} / ${canvas.height}`;
            } else {
                // tartal√©k
                applyPreviewAspect();
            }
        }

        function isAspectClose(w, h, targetAspect, tol = 0.04) {
            if (!w || !h) return false;
            const r = w / h;
            return Math.abs(r - targetAspect) <= tol;
        }

        function getLockedCanvasSize() {
            const wantPortrait = outputAspectMode === 'portrait';
            return wantPortrait ? { w: 1080, h: 1920 } : { w: 1920, h: 1080 };
        }

        function chooseCanvasSizeByMode(sourceW, sourceH) {
            if (currentMode === 'cam' && useSourceResolution) {
                return getLockedCanvasSize();
            }
            // NAT√çV kamera felbont√°s haszn√°lata
            const sw = sourceW || 1280;
            const sh = sourceH || 720;

            // Hat√°rozd meg a kamera nat√≠v ar√°ny√°t
            const sourceIsPortrait = sh > sw;

            // Hat√°rozd meg a k√≠v√°nt kimenet ar√°ny√°t
            const wantPortrait = (outputAspectMode === 'portrait');

            // Ha a kamera ar√°nya NEM egyezik a k√≠v√°nt orient√°ci√≥val, SWAP!
            if (sourceIsPortrait !== wantPortrait) {
                // Felcser√©lj√ºk a sz√©less√©g/magass√°g √©rt√©keit
                return { w: sh, h: sw };
            }

            // Egy√©bk√©nt nat√≠v m√©ret
            return { w: sw, h: sh };
        }

        function getPreviewCanvasSize(sourceW, sourceH) {
            const base = chooseCanvasSizeByMode(sourceW, sourceH);
            if (useSourceResolution) return base;

            const maxEdge = Math.max(1, previewMaxEdge);
            const scale = Math.min(1, maxEdge / Math.max(base.w, base.h));
            return {
                w: Math.max(1, Math.round(base.w * scale)),
                h: Math.max(1, Math.round(base.h * scale))
            };
        }

        function drawVideoCoverToRect(ctx2, videoEl, dx, dy, dw, dh) {
            const vw = videoEl.videoWidth || dw;
            const vh = videoEl.videoHeight || dh;

            const crop = getSourceCropPx(videoEl);
            const cvw = Math.max(1, vw - crop.left - crop.right);
            const cvh = Math.max(1, vh - crop.top - crop.bottom);
            const srcAspect = cvw / cvh;
            const dstAspect = dw / dh;

            let sx = crop.left, sy = crop.top, sw = cvw, sh = cvh;

            if (srcAspect > dstAspect) {
                sh = cvh;
                sw = Math.round(cvh * dstAspect);
                sx = crop.left + Math.round((cvw - sw) / 2);
                sy = crop.top;
            } else {
                sw = cvw;
                sh = Math.round(cvw / dstAspect);
                sx = crop.left;
                sy = crop.top + Math.round((cvh - sh) / 2);
            }

            ctx2.drawImage(videoEl, sx, sy, sw, sh, dx, dy, dw, dh);
        }

        function drawVideoCover(ctx2, videoEl, dstW, dstH) {
            drawVideoCoverToRect(ctx2, videoEl, 0, 0, dstW, dstH);
        }

        function drawVideoCoverRotated(ctx2, videoEl, dstW, dstH, rotateDeg) {
            const deg = (rotateDeg % 360 + 360) % 360;
            if (deg === 0) {
                drawVideoCoverToRect(ctx2, videoEl, 0, 0, dstW, dstH);
                return;
            }

            const rad = (deg * Math.PI) / 180;

            ctx2.save();
            ctx2.translate(dstW / 2, dstH / 2);
            ctx2.rotate(rad);

            const swap = (deg === 90 || deg === 270);
            const rw = swap ? dstH : dstW;
            const rh = swap ? dstW : dstH;

            drawVideoCoverToRect(ctx2, videoEl, -rw / 2, -rh / 2, rw, rh);
            ctx2.restore();
        }

        async function waitForFirstFrame(videoEl, timeoutMs = 1500) {
            if (!videoEl) return;
            if (videoEl.readyState >= 2 && videoEl.videoWidth && videoEl.videoHeight) return;

            let done = false;
            const fallback = new Promise((res) => {
                setTimeout(() => {
                    if (!done) res();
                }, timeoutMs);
            });

            const byEvent = new Promise((res) => {
                const onReady = () => {
                    if (done) return;
                    done = true;
                    videoEl.removeEventListener('canplay', onReady);
                    videoEl.removeEventListener('playing', onReady);
                    res();
                };
                videoEl.addEventListener('canplay', onReady, { once: true });
                videoEl.addEventListener('playing', onReady, { once: true });
            });

            const byFrame = (typeof videoEl.requestVideoFrameCallback === 'function')
                ? new Promise((res) => {
                    videoEl.requestVideoFrameCallback(() => {
                        if (!done) {
                            done = true;
                            res();
                        }
                    });
                })
                : null;

            await Promise.race([fallback, byEvent, byFrame].filter(Boolean));
        }

        function seekToTime(videoEl, timeSec, timeoutMs = 600) {
            return new Promise((res) => {
                if (!videoEl) return res();
                const t = Math.max(0, timeSec || 0);
                if (Math.abs((videoEl.currentTime || 0) - t) < 0.01) return res();
                let done = false;
                const onSeeked = () => {
                    if (done) return;
                    done = true;
                    videoEl.removeEventListener('seeked', onSeeked);
                    res();
                };
                const timer = setTimeout(() => {
                    if (done) return;
                    done = true;
                    videoEl.removeEventListener('seeked', onSeeked);
                    res();
                }, timeoutMs);
                videoEl.addEventListener('seeked', onSeeked, { once: true });
                try { videoEl.currentTime = t; } catch (_) { clearTimeout(timer); res(); }
            });
        }

        async function safePlay(videoEl, timeoutMs = 1200) {
            if (!videoEl) return false;
            try {
                const p = videoEl.play();
                if (p && typeof p.then === 'function') {
                    const ok = await Promise.race([
                        p.then(() => true).catch(() => false),
                        new Promise((res) => setTimeout(() => res(false), timeoutMs))
                    ]);
                    return ok === true;
                } else {
                    await new Promise((res) => setTimeout(res, 0));
                    return true;
                }
            } catch (_) {
                return false;
            }
        }

        async function findTrimStartTime(videoEl, maxSec = 2, stepSec = 0.05) {
            if (!videoEl) return 0;
            const duration = isFinite(videoEl.duration) ? videoEl.duration : 0;
            if (duration <= 0) return 0;
            const limit = Math.min(maxSec, duration);
            const tmp = document.createElement('canvas');
            const tw = 64;
            const th = 36;
            tmp.width = tw;
            tmp.height = th;
            const tctx = tmp.getContext('2d');
            for (let t = 0; t <= limit + 0.0001; t += stepSec) {
                await seekToTime(videoEl, t);
                try {
                    tctx.drawImage(videoEl, 0, 0, tw, th);
                    const data = tctx.getImageData(0, 0, tw, th).data;
                    let sum = 0;
                    for (let i = 0; i < data.length; i += 4) {
                        sum += data[i] + data[i + 1] + data[i + 2];
                    }
                    const avg = sum / (data.length / 4);
                    if (avg > 12) return t;
                } catch (_) {
                    return 0;
                }
            }
            return 0;
        }

        function buildProjectorThumb() {
            try {
                return canvas.toDataURL('image/jpeg', 0.72);
            } catch (_) {
                return null;
            }
        }

        // R√∂gz√≠t≈ë kimenet form√°tum (pr√≥b√°lunk kompatibiliset v√°lasztani)
        let lastOutputUrl = null;
        let lastOutputExt = 'webm';
        let lastOutputMime = 'video/webm';

        // Elemek
        const liveVideo = document.getElementById('liveVideo');
        const rawPlayback = document.getElementById('rawPlayback');
        const canvas = document.getElementById('renderCanvas');
        const ctx = canvas.getContext('2d');
        const overlayImg = document.getElementById('overlayImg');
        const statusBadge = document.getElementById('statusBadge');
        const encoderBadge = document.getElementById('encoderBadge');
        const progressBar = document.getElementById('progressBar');
        const progressBarContainer = document.getElementById('progressBarContainer');
        const processText = document.getElementById('processText');

        if (encoderBadge) {
            encoderBadge.addEventListener('click', toggleEncoderPreference);
            encoderBadge.title = 'Kattints: HW/SW';
        }

        // --- √âL≈ê EL≈êN√âZET CANVAS CIKLUS (kamera el≈ën√©zet a canvas-on) ---
        let livePreviewRAF = 0;
        let lastPreviewDrawMs = 0;

        function stopLivePreviewLoop() {
            if (livePreviewRAF) {
                cancelAnimationFrame(livePreviewRAF);
                livePreviewRAF = 0;
            }
        }

        function syncPreviewCanvasToMode(videoEl) {
            const v = videoEl || liveVideo;
            const vw = (v && v.videoWidth) ? v.videoWidth : 1280;
            const vh = (v && v.videoHeight) ? v.videoHeight : 720;
            const chosen = getPreviewCanvasSize(vw, vh);
            if (canvas.width !== chosen.w || canvas.height !== chosen.h) {
                canvas.width = chosen.w;
                canvas.height = chosen.h;
            }
            setVideoContainerAspectFromCanvas();
        }

        function drawLivePreviewOnce() {
            if (currentMode !== 'cam') return;
            if (isProcessing) return;
            if (!liveVideo || !liveVideo.srcObject) return;
            if (liveVideo.readyState < 2) return; // nincs k√©p m√©g

            // Az el≈ën√©zet mindig a canvas-on megy, √≠gy nem lesz se "√≥ri√°si zoom", se "b√©lyegk√©p".
            try {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawVideoCoverRotated(ctx, liveVideo, canvas.width, canvas.height, getEffectiveRotateDeg(liveVideo));
                // Overlay falt√≥l-falig a canvas m√©ret√©hez igazodva (mint a render loop-ban)
                drawOverlayToCanvas(ctx, canvas.width, canvas.height);
                if (isDateOverlayEnabled()) {
                    drawDateStamp(ctx, canvas.width, canvas.height);
                }
            } catch (e) {
                // ne √°lljon le a ciklus
                console.warn('[PREVIEW] draw failed:', e);
            }
        }

        function drawLivePreviewLoop() {
            stopLivePreviewLoop();
            const loop = () => {
                const now = performance.now();
                const frameMs = previewFps > 0 ? (1000 / previewFps) : 33;
                if (now - lastPreviewDrawMs >= frameMs) {
                    lastPreviewDrawMs = now;
                    drawLivePreviewOnce();
                }
                livePreviewRAF = requestAnimationFrame(loop);
            };
            livePreviewRAF = requestAnimationFrame(loop);
        }

        // Utols√≥ kimenet UI

        const lastOutputBox = document.getElementById('lastOutput');
        const lastOutputVideo = document.getElementById('lastOutputVideo');
        const lastOutputInfo = document.getElementById('lastOutputInfo');
        const btnOpenLast = document.getElementById('btnOpenLast');
        const btnDownloadLast = document.getElementById('btnDownloadLast');
        const btnHideLast = document.getElementById('btnHideLast');

        function applyLastOutputAspectFromMode() {
            if (!lastOutputVideo) return;

            // A vide√≥ saj√°t aspect ratio-j√°t haszn√°lja (nat√≠v kamera ar√°ny)
            // Nincs k√©nyszer√≠tett 9:16 vagy 16:9
            try {
                lastOutputVideo.style.aspectRatio = 'auto';
            } catch (_) {
                // Safari: nem baj
            }
        }

        function syncLastOutputWidth() {
            const vc = document.getElementById('videoContainer');
            const lo = document.getElementById('lastOutput');
            if (!vc || !lo) return;

            // A k√©sz vide√≥ + gombok doboza ugyanakkora sz√©less√©g≈± legyen, mint az el≈ën√©zet keret.
            // √çgy √°ll√≥ m√≥dban nem lesz ‚Äû≈±ber nagy‚Äù full panel sz√©less√©g≈±.
            const r = vc.getBoundingClientRect();
            const w = Math.max(0, Math.floor(r.width));
            if (w > 0) {
                lo.style.width = w + 'px';
                lo.style.maxWidth = w + 'px';
            } else {
                lo.style.width = '100%';
                lo.style.maxWidth = '100%';
            }
        }

        // MediaRecorder t√°mogatott mimeType kiv√°laszt√°sa (Mac-en a VP9 gyakran probl√©m√°s lej√°tsz√°sn√°l)
        function pickRecorderMime(pref) {
            const mp4 = [
                { mime: 'video/mp4;codecs=avc1.42E01E,mp4a.40.2', ext: 'mp4' },
                { mime: 'video/mp4;codecs=avc1.42E01E', ext: 'mp4' }
            ];
            const webm = [
                { mime: 'video/webm;codecs=vp8', ext: 'webm' },
                { mime: 'video/webm;codecs=vp9', ext: 'webm' },
                { mime: 'video/webm', ext: 'webm' }
            ];
            const candidates = (pref === 'mp4') ? [...mp4, ...webm]
                : (pref === 'webm') ? [...webm, ...mp4]
                : [...mp4, ...webm];

            if (!window.MediaRecorder || !MediaRecorder.isTypeSupported) {
                return { mime: 'video/webm', ext: 'webm' };
            }

            for (const c of candidates) {
                try {
                    if (MediaRecorder.isTypeSupported(c.mime)) return c;
                } catch (_) { }
            }
            return { mime: 'video/webm', ext: 'webm' };
        }

        function setLastOutput(url, mime, ext, bytes) {
            // R√©gi URL felszabad√≠t√°s
            try { if (lastOutputUrl) URL.revokeObjectURL(lastOutputUrl); } catch (_) { }

            lastOutputUrl = url;
            lastOutputMime = mime;
            lastOutputExt = ext;

            lastOutputVideo.src = url;
            lastOutputBox.style.display = 'block';
            // Az el≈ën√©zet lej√°tsz√≥ igazodjon a v√°lasztott kimeneti k√©par√°nyhoz
            applyLastOutputAspectFromMode();
            syncLastOutputWidth();

            const sizeMB = bytes ? (bytes / (1024 * 1024)).toFixed(1) : '?';
            lastOutputInfo.innerText = `Form√°tum: ${ext.toUpperCase()} (${mime}) ‚Ä¢ M√©ret: ${sizeMB} MB`;
        }

        btnOpenLast.onclick = () => {
            if (!lastOutputUrl) return;
            window.open(lastOutputUrl, '_blank');
        };
        btnDownloadLast.onclick = () => {
            if (!lastOutputUrl) return;
            const a = document.createElement('a');
            const now = new Date();
            a.href = lastOutputUrl;
            a.download = `360_Video_${now.getHours()}${now.getMinutes()}${now.getSeconds()}.${lastOutputExt}`;
            a.click();
        };
        btnHideLast.onclick = () => {
            lastOutputBox.style.display = 'none';
        };

        // Safari/MediaRecorder diagnosztika: ha nincs MediaRecorder, a feldolgoz√°s nem fog menni.
        (function bootChecks() {
            // A "Utols√≥ vide√≥" doboz csak a feldolgoz√°s v√©g√©n jelenik meg.
            try {
                if (lastOutputInfo) {
                    lastOutputInfo.innerText = 'A feldolgoz√°s v√©g√©n itt jelenik meg az utols√≥ vide√≥ (el≈ën√©zet + let√∂lt√©s).';
                }
            } catch (_) { }

            if (!window.MediaRecorder) {
                console.error('[REC] MediaRecorder NOT available in this browser.');
                statusBadge.innerText = 'SAFARI: NINCS FELV√âTEL';
                statusBadge.style.color = 'red';
                processText.innerText = 'Ez a Safari verzi√≥ nem t√°mogatja a MediaRecorder-t. Haszn√°lj Chrome-ot, vagy enged√©lyezd a Safari k√≠s√©rleti MediaRecorder/WebRTC opci√≥it.';
            }
        })();

        // --- 0. M√ìDV√ÅLT√ÅS ---
        function setMode(mode) {
            currentMode = mode;
            document.getElementById('btnModeCam').className = mode === 'cam' ? 'mode-btn active' : 'mode-btn';
            document.getElementById('btnModeFile').className = mode === 'file' ? 'mode-btn active' : 'mode-btn';

            document.getElementById('camControls').style.display = mode === 'cam' ? 'block' : 'none';
            document.getElementById('fileControls').style.display = mode === 'file' ? 'block' : 'none';

            if (mode === 'cam') {
                // Kamera m√≥dban a korrekt el≈ën√©zetet canvas-on mutatjuk (nem a video elemen),
                // √≠gy a portrait/rotate nem fog sz√©tesni.
                liveVideo.style.display = 'none';
                canvas.style.display = 'block';
                rawPlayback.style.display = 'none';
                // DropZone elrejt√©se kamera m√≥dban
                const dz = document.getElementById('dropZone');
                if (dz) dz.style.display = 'none';
                loadCameras();
            } else {
                stopLivePreviewLoop();
                liveVideo.style.display = 'none';
                rawPlayback.style.display = 'none'; // Csak feldolgoz√°skor l√°tszik
                if (stream) stream.getTracks().forEach(t => t.stop());

                // F√°jldoboz esem√©nyek
                const dz = document.getElementById('dropZone');
                // Biztosan l√°tsz√≥djon a drop zone f√°jl m√≥dban
                if (dz) dz.style.display = 'flex';
                dz.ondragover = (e) => { e.preventDefault(); dz.classList.add('dragover'); };
                dz.ondragleave = () => dz.classList.remove('dragover');
                dz.ondrop = (e) => {
                    e.preventDefault(); dz.classList.remove('dragover');
                    if (e.dataTransfer.files[0]) processImportedFile(e.dataTransfer.files[0]);
                };
            }
        }

        function handleFileSelect(input) {
            if (input.files[0]) processImportedFile(input.files[0]);
        }

        function setRawPlaybackSource(blob) {
            try { if (rawVideoUrl) URL.revokeObjectURL(rawVideoUrl); } catch (_) { }
            rawVideoUrl = URL.createObjectURL(blob);
            rawPlayback.src = rawVideoUrl;
        }

        async function processImportedFile(file) {
            statusBadge.innerText = "F√ÅJL BET√ñLTVE";
            statusBadge.style.color = "#fff";

            // Blob l√©trehoz√°sa a f√°jlb√≥l
            rawVideoBlob = file;
            setRawPlaybackSource(rawVideoBlob);

            // Azonnali ind√≠t√°s
            startProcessingLoop();
        }


        // --- 1. BRANDING & KIVET√çT≈ê ---
        function updateBranding() {
            const text = document.getElementById('brandTitleInput').value || "360 Booth";
            if (projectorWin && !projectorWin.closed) {
                projectorWin.postMessage({ type: 'updateBrand', title: text, logo: currentLogoData }, '*');
            }
        }
        function updateLogo() {
            const file = document.getElementById('logoInput').files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function (e) { currentLogoData = e.target.result; updateBranding(); }
                reader.readAsDataURL(file);
            }
        }
        function openProjectorWindow() {
            if (projectorWin && !projectorWin.closed) { projectorWin.focus(); return; }
            const displayHTML = `<!DOCTYPE html>
<html lang="hu">
<head>
  <meta charset="UTF-8">
  <title>360 Booth - Kivet√≠t≈ë</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@500;600;700&display=swap');
    :root{
      --bg-0:#0a0f14;--bg-1:#0f151d;--panel:#0f141d;--border:#1e2a38;--text:#e6edf3;--muted:#9aa4b2;--accent:#23d7b5;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:'Space Grotesk',sans-serif;
      color:var(--text);
      background:
        radial-gradient(900px 500px at 10% -10%, rgba(35,215,181,.12), transparent 60%),
        var(--bg-0);
      display:grid;
      grid-template-columns:minmax(0,1fr) 320px;
      height:100dvh;
      overflow:hidden;
    }
    #main{
      display:flex;flex-direction:column;align-items:center;justify-content:center;
      padding:28px;gap:18px;background:var(--bg-1);
    }
    #brand{display:flex;flex-direction:column;align-items:center;gap:10px}
    #title{font-size:28px;letter-spacing:4px;text-transform:uppercase;margin:0}
    #logo{max-height:84px;display:none}
    #dispWrap{
      width:min(92%,1200px);aspect-ratio:16/9;background:#090e13;
      border:1px solid var(--border);border-radius:14px;overflow:hidden;
      display:flex;align-items:center;justify-content:center;position:relative;
    }
    #disp{width:100%;height:100%;object-fit:cover;display:none}
    #wait{font-size:16px;color:var(--muted);text-align:center}
    #tap{
      position:absolute;inset:auto auto 18px 18px;
      background:rgba(15,20,29,.75);border:1px solid var(--border);
      color:var(--text);padding:8px 12px;border-radius:8px;display:none;
      font-size:12px;cursor:pointer;
    }
    #side{
      background:var(--panel);border-left:1px solid var(--border);
      padding:18px;display:flex;flex-direction:column;gap:12px;
    }
    .side-title{font-size:12px;letter-spacing:2px;text-transform:uppercase;color:var(--muted)}
    #gal{overflow-y:auto;display:grid;gap:10px}
    .g-item{
      border:1px solid var(--border);border-radius:10px;overflow:hidden;
      cursor:pointer;background:#0b1016;
    }
    .g-item video{width:100%;aspect-ratio:16/9;object-fit:cover;display:block}
    .g-thumb{width:100%;aspect-ratio:16/9;object-fit:cover;display:block}
  </style>
</head>
<body>
  <div id="main">
    <div id="brand">
      <h1 id="title">360 Booth</h1>
      <img id="logo" alt="Logo">
    </div>
    <div id="dispWrap">
      <video id="disp" muted playsinline></video>
      <div id="wait">V√°rakoz√°s...</div>
      <button id="tap" type="button">Kattints a lej√°tsz√°shoz</button>
    </div>
  </div>
  <div id="side">
    <div class="side-title">Gal√©ria</div>
    <div id="gal"></div>
  </div>
  <script>
    const disp = document.getElementById('disp');
    const wait = document.getElementById('wait');
    const tap = document.getElementById('tap');
    const gal = document.getElementById('gal');

    function playVideo(url) {
      disp.src = url;
      disp.muted = true;
      disp.playsInline = true;
      disp.autoplay = true;
      disp.loop = true;
      disp.controls = false;
      disp.style.display = 'block';
      wait.style.display = 'none';
      tap.style.display = 'none';
      const p = disp.play();
      if (p && typeof p.catch === 'function') {
        p.catch(() => {
          tap.style.display = 'block';
        });
      }
    }

    tap.addEventListener('click', () => {
      disp.play().then(() => { tap.style.display = 'none'; }).catch(() => {});
    });

    window.addEventListener('message', (e) => {
      const d = e.data || {};
      if (d.type === 'updateBrand') {
        document.getElementById('title').innerText = d.title || '360 Booth';
        if (d.logo) {
          document.getElementById('logo').src = d.logo;
          document.getElementById('logo').style.display = 'block';
        } else {
          document.getElementById('logo').style.display = 'none';
        }
      }
      if (d.type === 'newVideo') {
        playVideo(d.url);
        const g = document.createElement('div');
        g.className = 'g-item';
        const img = document.createElement('img');
        img.className = 'g-thumb';
        img.alt = 'Video thumbnail';
        if (d.thumb) img.src = d.thumb;
        g.appendChild(img);
        g.onclick = () => playVideo(d.url);
        gal.prepend(g);
      }
    });
  <\/script>
</body>
</html>`;
            projectorWin = window.open("", "ProjectorWindow", "width=1280,height=720,menubar=no,toolbar=no");
            projectorWin.document.write(displayHTML);
            projectorWin.document.close();
            setTimeout(() => updateBranding(), 500);
        }
        function sendToProjector(blobUrl, thumbUrl) {
            if (projectorWin && !projectorWin.closed) {
                projectorWin.postMessage({ type: 'newVideo', url: blobUrl, thumb: thumbUrl || null }, '*');
            }
        }

        // --- 2. KAMERA (Ha m√©gis kell) ---
        async function loadCameras() {
            // Kamera lista megb√≠zhat√≥ bet√∂lt√©se: el≈ëbb enged√©lyt k√©r√ºnk,
            // majd enumerateDevices, v√©g√ºl ind√≠t√°s.
            try {
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    console.error('[CAM] mediaDevices/getUserMedia not available. Use HTTPS or localhost.');
                    statusBadge.innerText = 'KAMERA NEM EL√âRHET≈ê';
                    statusBadge.style.color = 'red';
                    return;
                }

                // Enged√©lyk√©r√©s (labels + videoinput lista csak ez ut√°n megb√≠zhat√≥)
                let tmpStream = null;
                try {
                    tmpStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
                } catch (e) {
                    console.error('[CAM] Permission/getUserMedia failed:', e);
                    statusBadge.innerText = 'KAMERA ENGED√âLY KELL';
                    statusBadge.style.color = 'red';
                    return;
                } finally {
                    if (tmpStream) tmpStream.getTracks().forEach(t => t.stop());
                }

                const d = await navigator.mediaDevices.enumerateDevices();
                const s = document.getElementById('camSelect');
                s.innerHTML = '';

                const cams = d.filter(x => x.kind === 'videoinput');
                if (cams.length === 0) {
                    console.error('[CAM] No videoinput devices found.');
                    s.innerHTML = '<option value="">Nincs kamera</option>';
                    statusBadge.innerText = 'NINCS KAMERA';
                    statusBadge.style.color = 'red';
                    return;
                }

                cams.forEach((x, idx) => {
                    const o = document.createElement('option');
                    o.value = x.deviceId;
                    o.text = x.label || `Kamera ${idx + 1}`;
                    s.appendChild(o);
                });

                // Csak kamera m√≥dban ind√≠tunk
                if (currentMode === 'cam') await startCamera();

            } catch (e) {
                console.error('[CAM] loadCameras error:', e);
                statusBadge.innerText = 'KAMERA HIBA';
                statusBadge.style.color = 'red';
            }
        }

        async function startCamera() {
            if (currentMode !== 'cam') return;

            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                console.error('[CAM] mediaDevices/getUserMedia not available. Use HTTPS or localhost.');
                statusBadge.innerText = 'KAMERA NEM EL√âRHET≈ê';
                statusBadge.style.color = 'red';
                return;
            }

            const id = document.getElementById('camSelect').value;
            if (isAutoOrientationEnabled) {
                outputAspectMode = getViewportOrientationMode();
                syncBodyAspectMode();
            }

            // El≈ëz≈ë stream le√°ll√≠t√°sa (k√ºl√∂nben Safari/Chrome n√©ha nem v√°lt kamer√°t rendesen)
            try {
                if (stream) stream.getTracks().forEach(t => t.stop());
            } catch (_) { }
            stream = null;

            try {
                // Kamera be√°ll√≠t√°sok: FHD lock (16:9/9:16) 60fps, vagy UI szerinti c√©l
                const useNative = !!useSourceResolution;
                const targetWidth = cameraWidth || 1920;
                const targetHeight = cameraHeight || 1080;
                const targetFps = cameraFps || 60;
                const wantPortrait = outputAspectMode === 'portrait';
                const lockWidth = wantPortrait ? 1080 : 1920;
                const lockHeight = wantPortrait ? 1920 : 1080;
                const constraints = {
                    video: {
                        width: useNative ? { ideal: lockWidth } : { ideal: targetWidth },
                        height: useNative ? { ideal: lockHeight } : { ideal: targetHeight },
                        frameRate: useNative ? { ideal: 60, min: 30 } : { ideal: targetFps },
                        aspectRatio: useNative ? (wantPortrait ? 9 / 16 : 16 / 9) : undefined,
                        ...(id ? { deviceId: { exact: id } } : {})
                    },
                    audio: false
                };

                stream = await navigator.mediaDevices.getUserMedia(constraints);
                liveVideo.srcObject = stream;

                // iOS/Safari: n√©ha kell explicit play
                try { await liveVideo.play(); } catch (_) { }

                // Canvas el≈ën√©zet inicializ√°l√°s
                canvas.style.display = 'block';
                liveVideo.style.display = 'none';

                // Amint megvan a vide√≥ metadata, √∫jrasz√°moljuk a rotate+scale transzformot
                const onMeta = () => {
                    liveVideo.removeEventListener('loadedmetadata', onMeta);
                    applyPreviewAspect();
                    syncPreviewCanvasToMode(liveVideo);
                    applyLiveVideoTransform();
                    drawLivePreviewLoop();
                };
                liveVideo.addEventListener('loadedmetadata', onMeta);

                applyPreviewAspect();
                syncPreviewCanvasToMode(liveVideo);
                applyLiveVideoTransform();
                drawLivePreviewLoop();

                const track = stream.getVideoTracks ? stream.getVideoTracks()[0] : null;
                if (track && useNative) {
                    await enforceLockedCameraConstraints(track);
                }
                if (track && !userCameraChoiceTouched && !useSourceResolution && !autoCameraTuned) {
                    await autoTuneCameraForBestFps(track);
                    autoCameraTuned = true;
                }
                const settings = track && track.getSettings ? track.getSettings() : null;
                if (settings) {
                    // Nat√≠v be√°ll√≠t√°sok csak akkor √≠rj√°k fel√ºl a UI-t, ha az opci√≥ akt√≠v
                    if (settings.width && settings.height) {
                        if (useNative) {
                            cameraWidth = settings.width;
                            cameraHeight = settings.height;
                            setSelectValueOrAdd(
                                document.getElementById('cameraResolution'),
                                `${cameraWidth}x${cameraHeight}`,
                                `${cameraWidth}x${cameraHeight} (lock)`
                            );
                        }
                    }
                    if (settings.frameRate) {
                        if (useNative) {
                            cameraFps = Math.round(settings.frameRate);
                            setSelectValueOrAdd(
                                document.getElementById('cameraFps'),
                                String(cameraFps),
                                `${cameraFps} fps (lock)`
                            );
                        }
                    }
                }
                if (useNative) {
                    applyPreviewFpsLockFromSettings(settings);
                }
                const autoEl = document.getElementById('autoTuneInfo');
                if (autoEl) {
                    if (useNative && autoCameraTuned && settings && settings.width && settings.height && settings.frameRate) {
                        autoEl.textContent = `${settings.width}x${settings.height} @ ${Math.round(settings.frameRate)} fps`;
                    } else {
                        autoEl.textContent = autoCameraTuned ? 'AUTO OK' : '-';
                    }
                }

                // Nat√≠v be√°ll√≠t√°sok haszn√°lata - nincs sz√ºks√©g √∫jraind√≠t√°sra
                autoMaxCameraApplied = true;

                statusBadge.innerText = 'K√âSZENL√âT';
                statusBadge.style.color = '#03dac6';
                if (pendingStartRecord) {
                    pendingStartRecord = false;
                    setTimeout(() => initiateCamSequence(), 0);
                }

            } catch (e) {
                console.error('[CAM] startCamera getUserMedia failed:', e);
                statusBadge.innerText = 'KAMERA HIBA';
                statusBadge.style.color = 'red';
            }
        }

        // --- 3. EFFEKTEK ---
        function fmtNum(x, d = 2) {
            const n = Number(x);
            if (!isFinite(n)) return '0';
            return n.toFixed(d).replace(/\.00$/, '.0').replace(/\.(\d)0$/, '.$1');
        }

        function updateEffectUI() {
            const tS = document.getElementById('effTimeSlider');
            const sS = document.getElementById('effSpeedSlider');
            const tV = document.getElementById('effTimeVal');
            const sV = document.getElementById('effSpeedVal');
            if (tS && tV) tV.innerText = `${fmtNum(tS.value, 1)} s`;
            if (sS && sV) sV.innerText = `${fmtNum(sS.value, 2)}√ó`;
            updateSpeedPresetButtons(parseFloat(sS ? sS.value : '1'));

            // Automatikus friss√≠t√©s: ha van kijel√∂lt szakasz, a cs√∫szka/preset mozgat√°s azonnal √°t√≠rja.
            scheduleAutoApplyToSelected();
        }

        function updateSpeedPresetButtons(v) {
            const b05 = document.getElementById('btnSpeed05');
            const b10 = document.getElementById('btnSpeed10');
            const b20 = document.getElementById('btnSpeed20');
            const eq = (a, b) => Math.abs(a - b) < 0.001;
            if (b05) b05.classList.toggle('active', eq(v, 0.5));
            if (b10) b10.classList.toggle('active', eq(v, 1.0));
            if (b20) b20.classList.toggle('active', eq(v, 2.0));
        }

        // --- AUTO ALKALMAZ√ÅS (kijel√∂lt szakasz azonnali friss√≠t√©se cs√∫szka/preset mozgat√°skor) ---
        let _autoApplyTimer = 0;

        function scheduleAutoApplyToSelected() {
            if (selectedEffectIndex < 0 || selectedEffectIndex >= effects.length) return;
            if (_autoApplyTimer) clearTimeout(_autoApplyTimer);
            _autoApplyTimer = setTimeout(() => {
                _autoApplyTimer = 0;
                applyToSelected();
            }, 120);
        }

        function setSpeedPreset(v) {
            const sS = document.getElementById('effSpeedSlider');
            if (sS) sS.value = String(v);
            updateEffectUI();
            scheduleAutoApplyToSelected();
        }

        function selectEffect(idx) {
            if (!Array.isArray(effects) || effects.length === 0) {
                selectedEffectIndex = -1;
                return;
            }
            if (idx < 0 || idx >= effects.length) {
                selectedEffectIndex = -1;
                return;
            }
            selectedEffectIndex = idx;

            // cs√∫szk√°k felv√©tele a kijel√∂lt szakaszra
            const tS = document.getElementById('effTimeSlider');
            const sS = document.getElementById('effSpeedSlider');
            if (tS) tS.value = String(effects[idx].duration);
            if (sS) sS.value = String(effects[idx].speed);
            updateEffectUI();
            renderList();
            renderTimeline();
        }

        function applyToSelected() {
            if (selectedEffectIndex < 0 || selectedEffectIndex >= effects.length) return;
            disableAutoRamp();
            const tS = document.getElementById('effTimeSlider');
            const sS = document.getElementById('effSpeedSlider');
            const dur = parseFloat(tS ? tS.value : '0');
            const spd = parseFloat(sS ? sS.value : '0');
            if (!isFinite(dur) || dur <= 0) return;
            if (!isFinite(spd) || spd <= 0) return;
            effects[selectedEffectIndex] = { duration: dur, speed: spd };
            renderList();
            renderTimeline();
        }

        function addEffect() {
            disableAutoRamp();
            const tS = document.getElementById('effTimeSlider');
            const sS = document.getElementById('effSpeedSlider');
            const dur = parseFloat(tS ? tS.value : '2');
            const spd = parseFloat(sS ? sS.value : '1');
            if (!isFinite(dur) || dur <= 0) return;
            if (!isFinite(spd) || spd <= 0) return;
            effects.push({ duration: dur, speed: spd });
            renderList();
        }

        function deleteEffect(idx) {
            if (idx < 0 || idx >= effects.length) return;
            effects.splice(idx, 1);
            if (selectedEffectIndex === idx) selectedEffectIndex = -1;
            else if (selectedEffectIndex > idx) selectedEffectIndex -= 1;
            renderList();
        }

        function clearEffects() {
            disableAutoRamp();
            effects = [];
            selectedEffectIndex = -1;
            renderList();
        }

        function setAutoRampEnabled(val) {
            autoRampEnabled = !!val;
            const chk = document.getElementById('autoRampMode');
            if (chk) chk.checked = autoRampEnabled;
            updateRampPresetButtons();
        }

        function syncAutoRampStateFromUI() {
            const chk = document.getElementById('autoRampMode');
            if (!chk) return;
            autoRampEnabled = !!chk.checked;
            updateRampPresetButtons();
        }

        function disableAutoRamp() {
            if (!autoRampEnabled) return;
            setAutoRampEnabled(false);
        }

        const rampPresets = {
            balanced: {
                ratios: [0.3, 0.4, 0.2, 0.1],
                speeds: [1.0, 0.5, 2.0, 1.0]
            },
            smooth: {
                ratios: [0.35, 0.3, 0.2, 0.15],
                speeds: [1.0, 0.8, 1.4, 1.0]
            },
            punch: {
                ratios: [0.2, 0.45, 0.2, 0.15],
                speeds: [1.0, 0.4, 2.2, 1.0]
            },
            slowmo: {
                ratios: [0.25, 0.5, 0.15, 0.1],
                speeds: [1.0, 0.35, 1.6, 1.0]
            }
        };

        function getActiveRampPreset() {
            return rampPresets[currentRampPresetKey] || rampPresets.balanced;
        }

        function updateRampPresetButtons() {
            const buttons = document.querySelectorAll('[data-ramp-preset]');
            buttons.forEach((btn) => {
                const key = btn.getAttribute('data-ramp-preset');
                const isActive = autoRampEnabled && key === currentRampPresetKey;
                btn.classList.toggle('active', isActive);
            });
        }

        function setRampPreset(key) {
            if (!rampPresets[key]) return;
            currentRampPresetKey = key;
            setAutoRampEnabled(true);
            applyAutoRampFromDuration();
        }

        function quantizeDurations(durs, total, step) {
            const out = durs.map(v => Math.max(step, v));
            const sum = out.reduce((a, b) => a + b, 0);
            const diff = total - sum;
            if (Math.abs(diff) < step) return out;
            const last = out.length - 1;
            out[last] = Math.max(step, out[last] + diff);
            return out;
        }

        function buildAutoRamp(totalSec) {
            const preset = getActiveRampPreset();
            const ratios = preset.ratios;
            const speeds = preset.speeds;
            const rawSource = ratios.map(r => totalSec * r);
            const sourceDurs = quantizeDurations(rawSource, totalSec, 0.01);
            return sourceDurs.map((src, i) => {
                const spd = speeds[i] || 1;
                const outDur = src / Math.max(0.05, spd);
                return { duration: +outDur.toFixed(3), speed: spd };
            });
        }

        function getSourceDurationSec(fallback) {
            if (autoStopEnabled && autoStopSec > 0) return autoStopSec;
            if (recordedDurationSec && recordedDurationSec > 0) return recordedDurationSec;
            if (isFinite(fallback) && fallback > 0) return fallback;
            return 4;
        }

        function getAutoRampDurationSec(fallback) {
            if (autoStopEnabled && autoStopSec > 0) return autoStopSec;
            if (recordedDurationSec && recordedDurationSec > 0) return recordedDurationSec;
            if (isFinite(fallback) && fallback > 0) return fallback;
            return 4;
        }

        function applyAutoRampFromDuration() {
            if (!autoRampEnabled) return;
            const fileDur = (rawPlayback && isFinite(rawPlayback.duration) && rawPlayback.duration > 0)
                ? rawPlayback.duration
                : undefined;
            const total = getSourceDurationSec(fileDur);
            effects = buildAutoRamp(total);
            selectedEffectIndex = -1;
            renderList();
            renderTimeline();
        }

        function renderTimeline() {
            const tl = document.getElementById('effectsTimeline');
            if (!tl) return;

            if (!Array.isArray(effects) || effects.length === 0) {
                tl.innerHTML = '<div style="color:#666; font-size:11px; display:flex; align-items:center; justify-content:center; width:100%;">Nincs szakasz ‚Äì alap 1√ó</div>';
                return;
            }

            const total = effects.reduce((a, b) => a + (Number(b.duration) || 0), 0) || 1;

            tl.innerHTML = effects.map((e, i) => {
                const dur = Number(e.duration) || 0;
                const spd = Number(e.speed) || 1;
                const cls = (spd < 0.99) ? 'slow' : (spd > 1.01 ? 'fast' : 'norm');
                const sel = (i === selectedEffectIndex) ? 'selected' : '';

                // flex ar√°ny: id≈ëtartam alapj√°n (min√©l hosszabb, ann√°l sz√©lesebb szegmens)
                const flex = Math.max(0.2, dur);
                const label = `${fmtNum(dur, 1)}s ¬∑ ${fmtNum(spd, 2)}√ó`;

                return `<div class="eff-seg ${cls} ${sel}" style="flex:${flex} 1 0%;" title="${label}" onclick="selectEffect(${i})">${fmtNum(spd, 2)}√ó</div>`;
            }).join('');
        }

        function renderList() {
            const listEl = document.getElementById('effectsList');
            const sumEl = document.getElementById('effectsSummary');
            if (!listEl) return;

            renderTimeline();

            listEl.innerHTML = effects.map((e, i) => {
                const d = fmtNum(e.duration, 1);
                const s = fmtNum(e.speed, 2);
                const sel = (i === selectedEffectIndex);
                return `
                    <div class="effect-item selectable ${sel ? 'selected' : ''}" onclick="selectEffect(${i})">
                        <div style="display:flex; gap:8px; align-items:center; min-width:0;">
                            <div style="font-weight:800; color:#03dac6;">#${i + 1}</div>
                            <div style="white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">${d}s ‚Üí ${s}√ó</div>
                        </div>
                        <button class="eff-del" type="button" onclick="event.stopPropagation(); deleteEffect(${i})">T√∂rl√©s</button>
                    </div>
                `;
            }).join('');

            const total = effects.reduce((a, b) => a + (Number(b.duration) || 0), 0);
            if (sumEl) {
                if (effects.length === 0) {
                    sumEl.innerText = 'Nincs szakaszlista: alap√©rtelmezett 1√ó lej√°tsz√°s.';
                } else {
                    sumEl.innerText = `Szakaszok: ${effects.length} db ‚Ä¢ √ñssz-id≈ë: ${fmtNum(total, 1)} s (a feldolgoz√°s ideje)`;
                }
            }
        }

        // --- OVERLAY BET√ñLT√âS ---

        function computeAlphaBBoxFromImage(imgEl) {
            try {
                const w = imgEl.naturalWidth || 0;
                const h = imgEl.naturalHeight || 0;
                if (w <= 0 || h <= 0) return null;

                const tmp = document.createElement('canvas');
                tmp.width = w;
                tmp.height = h;
                const tctx = tmp.getContext('2d', { willReadFrequently: true });
                tctx.clearRect(0, 0, w, h);
                tctx.drawImage(imgEl, 0, 0);

                const data = tctx.getImageData(0, 0, w, h).data;
                let minX = w, minY = h, maxX = -1, maxY = -1;

                // Alpha csatorna: data[i+3]
                for (let y = 0; y < h; y++) {
                    const row = y * w * 4;
                    for (let x = 0; x < w; x++) {
                        const a = data[row + x * 4 + 3];
                        if (a > 0) {
                            if (x < minX) minX = x;
                            if (y < minY) minY = y;
                            if (x > maxX) maxX = x;
                            if (y > maxY) maxY = y;
                        }
                    }
                }

                if (maxX < minX || maxY < minY) return null;

                // +1 mert maxX/maxY pixel is kell
                const sx = minX;
                const sy = minY;
                const sw = (maxX - minX + 1);
                const sh = (maxY - minY + 1);

                // Ha gyakorlatilag teljes k√©p, nem v√°gunk
                if (sx === 0 && sy === 0 && sw === w && sh === h) return null;

                return { sx, sy, sw, sh, w, h };
            } catch (e) {
                console.warn('[OVERLAY] bbox compute failed:', e);
                return null;
            }
        }
        function loadOverlay(i) {
            overlayReady = false;
            overlayCrop = null;
            overlayCroppedOnce = false;

            if (!i || !i.files || !i.files[0]) {
                try {
                    overlayImg.removeAttribute('src');
                } catch (_) { }
                overlayImg.style.display = 'none';
                return;
            }

            const file = i.files[0];

            // Csak PNG-t enged√ºnk (k√ºl√∂nben Safari/Chrome furcs√°n viselkedhet)
            const nameOk = (file.name || '').toLowerCase().endsWith('.png');
            const typeOk = (file.type || '').toLowerCase().includes('png');
            if (!nameOk && !typeOk) {
                statusBadge.innerText = 'OVERLAY NEM PNG';
                statusBadge.style.color = 'red';
                try {
                    overlayImg.removeAttribute('src');
                } catch (_) { }
                overlayImg.style.display = 'none';
                return;
            }

            // Az overlay CSAK canvas-on rajzol√≥dik, az IMG elem rejtve marad
            // (r√©gebben DOM overlay volt, de az nem tartotta az ar√°nyokat)
            overlayImg.style.display = 'none';
            overlayImg.style.pointerEvents = 'none';

            overlayImg.onload = () => {
                overlayReady = true;

                // Alpha bbox kiv√°g√°s: lev√°gjuk a teljesen √°tl√°tsz√≥ peremet, hogy a keret kifusson a sz√©lekig
                overlayCrop = computeAlphaBBoxFromImage(overlayImg);

                // Fontos: az el≈ën√©zetben (IMG overlay) is l√°tsz√≥djon a kiv√°g√°s.
                // Ehhez egyszer (csak egyszer!) fizikailag √∫j PNG-t gener√°lunk a lev√°gott tartalomb√≥l,
                // √©s visszat√∂ltj√ºk az overlayImg-be. √çgy elt≈±nik a k√ºls≈ë √°tl√°tsz√≥ perem miatti fekete s√°v.
                if (overlayCrop && !overlayCroppedOnce) {
                    try {
                        const tmp = document.createElement('canvas');
                        tmp.width = overlayCrop.sw;
                        tmp.height = overlayCrop.sh;
                        const tctx = tmp.getContext('2d');
                        tctx.clearRect(0, 0, tmp.width, tmp.height);
                        tctx.drawImage(
                            overlayImg,
                            overlayCrop.sx, overlayCrop.sy, overlayCrop.sw, overlayCrop.sh,
                            0, 0, overlayCrop.sw, overlayCrop.sh
                        );

                        // Jel√∂lj√ºk, hogy ez m√°r a "kiv√°gott" verzi√≥, hogy ne legyen v√©gtelen onload ciklus
                        overlayCroppedOnce = true;

                        // A tov√°bbi rajzol√°shoz m√°r nincs sz√ºks√©g forr√°s-kiv√°g√°s adatra az el≈ën√©zethez,
                        // de a canvas renderben m√©g haszn√°lhat√≥ lenne. Mivel itt fizikailag lev√°gtuk a k√©pet,
                        // lenull√°zzuk, √≠gy a renderben sima drawImage is teljesen kifut.
                        overlayCrop = null;

                        // √öj PNG bet√∂lt√©se (√∫jra fog futni az onload egyszer)
                        overlayImg.src = tmp.toDataURL('image/png');
                        return;
                    } catch (e) {
                        console.warn('[OVERLAY] preview crop build failed:', e);
                        // ha a kiv√°g√°s gener√°l√°s elhasal, marad a kor√°bbi logika
                    }
                }

                if (overlayCrop) {
                    console.log('[OVERLAY] alpha-crop', overlayCrop);
                }

                console.log('[OVERLAY] loaded', overlayImg.naturalWidth, overlayImg.naturalHeight);
                statusBadge.innerText = 'OVERLAY OK';
                statusBadge.style.color = '#03dac6';
            };

            overlayImg.onerror = (e) => {
                overlayReady = false;
                console.error('[OVERLAY] load error', e);
                statusBadge.innerText = 'OVERLAY HIBA';
                statusBadge.style.color = 'red';
            };

            const r = new FileReader();
            r.onload = (e) => {
                overlayImg.src = e.target.result;
            };
            r.onerror = (e) => {
                overlayReady = false;
                console.error('[OVERLAY] FileReader error', e);
                statusBadge.innerText = 'OVERLAY OLVAS√ÅS HIBA';
                statusBadge.style.color = 'red';
            };
            r.readAsDataURL(file);
        }

        function clearOverlay() {
            overlayReady = false;
            overlayCrop = null;
            overlayCroppedOnce = false;
            try { overlayImg.removeAttribute('src'); } catch (_) { }
            overlayImg.style.display = 'none';
            const input = document.getElementById('overlayFile');
            if (input) input.value = '';
            statusBadge.innerText = 'OVERLAY OFF';
            statusBadge.style.color = '#aaa';
        }

        function isDateOverlayEnabled() {
            const chk = document.getElementById('dateOverlay');
            return !!(chk && chk.checked);
        }

        function getDateOverlayPos() {
            const sel = document.getElementById('dateOverlayPos');
            return sel ? sel.value : 'br';
        }

        function getDateOverlayOffsets() {
            const ox = document.getElementById('dateOverlayOffsetX');
            const oy = document.getElementById('dateOverlayOffsetY');
            const x = ox ? parseInt(ox.value, 10) : 18;
            const y = oy ? parseInt(oy.value, 10) : 18;
            return { x: isFinite(x) ? x : 18, y: isFinite(y) ? y : 18 };
        }

        function updateDateOverlayPreview() {
            const xVal = document.getElementById('dateOverlayOffsetXVal');
            const yVal = document.getElementById('dateOverlayOffsetYVal');
            const off = getDateOverlayOffsets();
            if (xVal) xVal.textContent = String(off.x);
            if (yVal) yVal.textContent = String(off.y);
        }

        function formatDateStamp(d) {
            const y = d.getFullYear();
            const m = String(d.getMonth() + 1).padStart(2, '0');
            const day = String(d.getDate()).padStart(2, '0');
            return `${y}.${m}.${day}`;
        }

        function drawDateStamp(ctx2, w, h) {
            const text = formatDateStamp(new Date());
            const size = Math.max(18, Math.round(w * 0.02));
            const padX = Math.round(size * 0.6);
            const padY = Math.round(size * 0.45);
            ctx2.save();
            ctx2.font = `600 ${size}px "Space Grotesk", sans-serif`;
            const metrics = ctx2.measureText(text);
            const boxW = Math.ceil(metrics.width + padX * 2);
            const boxH = Math.ceil(size + padY * 2);
            const pos = getDateOverlayPos();
            const off = getDateOverlayOffsets();
            let x = w - boxW - Math.round(size * 0.8);
            let y = h - boxH - Math.round(size * 0.7);
            if (pos === 'bl') {
                x = off.x;
                y = h - boxH - off.y;
            } else if (pos === 'tr') {
                x = w - boxW - off.x;
                y = off.y;
            } else if (pos === 'tl') {
                x = off.x;
                y = off.y;
            } else {
                x = w - boxW - off.x;
                y = h - boxH - off.y;
            }
            const r = Math.max(6, Math.round(size * 0.35));
            ctx2.fillStyle = 'rgba(10, 15, 20, 0.65)';
            ctx2.strokeStyle = 'rgba(30, 42, 56, 0.9)';
            ctx2.lineWidth = 1;
            ctx2.beginPath();
            if (typeof ctx2.roundRect === 'function') {
                ctx2.roundRect(x, y, boxW, boxH, r);
            } else {
                const rr = Math.min(r, Math.floor(boxW / 2), Math.floor(boxH / 2));
                ctx2.moveTo(x + rr, y);
                ctx2.arcTo(x + boxW, y, x + boxW, y + boxH, rr);
                ctx2.arcTo(x + boxW, y + boxH, x, y + boxH, rr);
                ctx2.arcTo(x, y + boxH, x, y, rr);
                ctx2.arcTo(x, y, x + boxW, y, rr);
                ctx2.closePath();
            }
            ctx2.fill();
            ctx2.stroke();
            ctx2.fillStyle = '#e6edf3';
            ctx2.textBaseline = 'middle';
            ctx2.fillText(text, x + padX, y + boxH / 2);
            ctx2.restore();
        }

        // --- 4. R√ñGZ√çT√âS (WEBCAM M√ìD) ---
        async function startRecordingNow() {
            const btn = document.getElementById('startBtn');
            syncAutoRampStateFromUI();
            statusBadge.innerText = "FELV√âTEL..."; statusBadge.style.color = "red";
            chunks = [];
            try { await waitForFirstFrame(liveVideo, 2000); } catch (_) { }

            // Lower preview FPS during recording to prioritize recording quality
            originalPreviewFps = previewFps;
            previewFps = 2;

            // === USE WEBCODECS IF AVAILABLE ===
            if (useWebCodecs) {
                try {
                    console.log('[REC] Using WebCodecs H.264 hardware encoding');
                    webCodecsEncoder = new WebCodecsRecorder(stream, { videoBitsPerSecond });
                    await webCodecsEncoder.start();
                    if (webCodecsEncoder && webCodecsEncoder.chosenConfig) {
                        setEncoderBadge(buildEncoderBadgeText(webCodecsEncoder.chosenConfig, 'HW'), 'gpu');
                    } else {
                        setEncoderBadge('HW H.264', 'gpu');
                    }

                    isRecording = true;
                    recordStartMs = performance.now();
                    if (btn) btn.textContent = 'FELV√âTEL STOP';
                    statusBadge.innerText = "FELV√âTEL (GPU)";
                    statusBadge.style.color = "#00ff00";

                    if (autoStopEnabled && autoStopSec > 0) {
                        autoStopTimer = setTimeout(() => {
                            if (isRecording) initiateCamSequence();
                        }, autoStopSec * 1000);
                    }
                    return; // Exit early, WebCodecs handles recording
                } catch (e) {
                    console.error('[WebCodecs] Start failed, falling back to MediaRecorder:', e);
                    useWebCodecs = false; // Disable for this session
                    webCodecsEncoder = null;
                    setEncoderBadge('MR READY', 'cpu');
                }
            }

            // === FALLBACK: MEDIARECORDER ===
            const pick1 = pickRecorderMime(preferredFormat);
            try {
                mediaRecorder = new MediaRecorder(stream, {
                    mimeType: pick1.mime,
                    videoBitsPerSecond,
                    videoKeyFrameInterval: 1000
                });
            } catch (e) {
                try {
                    mediaRecorder = new MediaRecorder(stream, { mimeType: pick1.mime, videoBitsPerSecond });
                } catch (err) {
                    console.error('[REC] MediaRecorder create failed:', err);
                    statusBadge.innerText = 'R√ñGZ√çT√âS HIBA';
                    statusBadge.style.color = 'red';
                    processText.innerText = 'A b√∂ng√©sz≈ë nem tud r√∂gz√≠teni (MediaRecorder). Safari-ban ez gyakori. Pr√≥b√°ld Chrome-ban, vagy Safari Develop ‚Üí Experimental Features alatt MediaRecorder/WebRTC opci√≥kat enged√©lyezni.';
                    if (btn) btn.textContent = 'FELV√âTEL START';
                    previewFps = originalPreviewFps;
                    return;
                }
            }
            mediaRecorder.ondataavailable = e => { if (e.data.size > 0) chunks.push(e.data) };
            mediaRecorder.onstop = () => {
                recordedDurationSec = Math.max(0, (performance.now() - recordStartMs) / 1000);
                if (autoStopTimer) { clearTimeout(autoStopTimer); autoStopTimer = 0; }
                if (autoRampEnabled) applyAutoRampFromDuration();
                const pick2 = pickRecorderMime(preferredFormat);
                rawVideoBlob = new Blob(chunks, { type: pick2.mime });
                setRawPlaybackSource(rawVideoBlob);
                startProcessingLoop();
                previewFps = originalPreviewFps;
            };
            try { mediaRecorder.start(); } catch (_) { }
            isRecording = true;
            recordStartMs = performance.now();
            if (btn) btn.textContent = 'FELV√âTEL STOP';
            const track = stream && stream.getVideoTracks ? stream.getVideoTracks()[0] : null;
            const settings = track && track.getSettings ? track.getSettings() : null;
            const badgeText = buildRecorderBadgeText(pick1.mime, settings, videoBitsPerSecond);
            const badgeMode = isH264Mime(pick1.mime) ? 'gpu' : 'cpu';
            setEncoderBadge(badgeText, badgeMode);

            if (autoStopEnabled && autoStopSec > 0) {
                autoStopTimer = setTimeout(() => {
                    if (isRecording) initiateCamSequence();
                }, autoStopSec * 1000);
            }
        }

        async function initiateCamSequence() {
            if (!stream) {
                console.warn('[CAM] No active stream. Trying to start camera...');
                statusBadge.innerText = 'KAMERA IND√çT√ÅS...';
                statusBadge.style.color = 'yellow';
                pendingStartRecord = true;
                loadCameras();
                return;
            }
            const btn = document.getElementById('startBtn');
            if (!isRecording && pendingStartTimer) {
                clearTimeout(pendingStartTimer);
                pendingStartTimer = 0;
                statusBadge.innerText = 'K√âSZENL√âT';
                statusBadge.style.color = '#03dac6';
                if (btn) btn.textContent = 'FELV√âTEL START';
                return;
            }
            if (isRecording) {
                statusBadge.innerText = "MENT√âS...";
                statusBadge.style.color = "yellow";
                if (autoStopTimer) { clearTimeout(autoStopTimer); autoStopTimer = 0; }

                // Stop WebCodecs or MediaRecorder
                if (webCodecsEncoder) {
                    try {
                        const blob = await webCodecsEncoder.stop();
                        recordedDurationSec = Math.max(0, (performance.now() - recordStartMs) / 1000);
                        if (autoRampEnabled) applyAutoRampFromDuration();

                        // Set the recorded blob as raw video
                        rawVideoBlob = blob;
                        setRawPlaybackSource(rawVideoBlob);
                        startProcessingLoop();

                        webCodecsEncoder = null;
                        previewFps = originalPreviewFps || 30;
                    } catch (e) {
                        console.error('[WebCodecs] Stop error:', e);
                    }
                } else {
                    try { mediaRecorder && mediaRecorder.stop(); } catch (_) { }
                }

                isRecording = false;
                if (btn) btn.textContent = 'FELV√âTEL START';
                return;
            }
            applyStartDelayFromUI();
            if (startDelaySec > 0) {
                statusBadge.innerText = `IND√çT√ÅS ${startDelaySec}s`;
                statusBadge.style.color = 'yellow';
                if (btn) btn.textContent = 'FELV√âTEL STOP';
                pendingStartTimer = setTimeout(() => {
                    pendingStartTimer = 0;
                    void startRecordingNow();
                }, Math.round(startDelaySec * 1000));
                return;
            }
            void startRecordingNow();
        }

        
        // Helper: Overlay rajzol√°s canvas-ra
        function drawOverlayToCanvas(ctx, w, h) {
            if (!overlayReady && !(overlayImg && overlayImg.naturalWidth > 0 && overlayImg.naturalHeight > 0)) {
                return;
            }
            try {
                if (overlayFitMode === 'stretch') {
                    ctx.drawImage(overlayImg, 0, 0, w, h);
                } else {
                    const iw = overlayImg.naturalWidth;
                    const ih = overlayImg.naturalHeight;
                    const iAsp = iw / ih;
                    const dAsp = w / h;
                    let dw, dh;
                    if (overlayFitMode === 'contain') {
                        if (iAsp > dAsp) { dw = w; dh = Math.round(w / iAsp); }
                        else { dh = h; dw = Math.round(h * iAsp); }
                    } else {
                        if (iAsp > dAsp) { dh = h; dw = Math.round(h * iAsp); }
                        else { dw = w; dh = Math.round(w / iAsp); }
                    }
                    const dx = Math.round((w - dw) / 2);
                    const dy = Math.round((h - dh) / 2);
                    ctx.drawImage(overlayImg, dx, dy, dw, dh);
                }
            } catch (e) {
                console.warn('[OVERLAY] drawImage failed:', e);
            }
        }

        // --- 5. F≈ê FELDOLGOZ√ì LOOP (K√ñZ√ñS MINDK√âT M√ìDH√ìZ) ---
        async function startProcessingLoop() {
            isProcessing = true;
            isRecording = false;
            syncAutoRampStateFromUI();
            statusBadge.innerText = "FELDOLGOZ√ÅS..."; statusBadge.style.color = "yellow";
            progressBarContainer.style.display = 'block';
            const startBtn = document.getElementById('startBtn');
            if (startBtn) {
                startBtn.disabled = true;
                startBtn.textContent = 'FELDOLGOZ√ÅS...';
            }
            // Kimenet doboz elrejt√©se feldolgoz√°s alatt
            if (lastOutputBox) lastOutputBox.style.display = 'none';

            liveVideo.style.display = 'none';
            canvas.style.display = 'block';

            // V√°rjuk meg a forr√°s vide√≥ metaadat√°t, hogy tudjuk a k√©par√°nyt
            try {
                if (rawPlayback.readyState < 1) {
                    await new Promise((res) => {
                        const onMeta = () => { rawPlayback.removeEventListener('loadedmetadata', onMeta); res(); };
                        rawPlayback.addEventListener('loadedmetadata', onMeta);
                    });
                }
            } catch (_) { }

            const srcW = rawPlayback.videoWidth || 1280;
            const srcH = rawPlayback.videoHeight || 720;
            const chosen = chooseCanvasSizeByMode(srcW, srcH);

            // Canvas fix m√©ret be√°ll√≠t√°s (a mentett vide√≥ k√©par√°nya IS EZ LESZ)
            canvas.width = chosen.w;
            canvas.height = chosen.h;
            setVideoContainerAspectFromCanvas();

            const baseDuration = getSourceDurationSec(
                (isFinite(rawPlayback.duration) && rawPlayback.duration > 0)
                    ? rawPlayback.duration
                    : undefined
            );
            let trimStartSec = 0;
            if (baseDuration > 0) {
                trimStartSec = await findTrimStartTime(rawPlayback, Math.min(2, baseDuration), 0.05);
            }
            const effectiveDuration = Math.max(0, baseDuration - trimStartSec);
            const endTime = trimStartSec + effectiveDuration;

            if (autoRampEnabled) {
                const total = getAutoRampDurationSec(effectiveDuration);
                effects = buildAutoRamp(total);
                selectedEffectIndex = -1;
                renderList();
                renderTimeline();
            } else if (!effects.length) {
                const total = effectiveDuration > 0 ? effectiveDuration : (baseDuration || 4);
                effects = [{ duration: total, speed: 1 }];
                selectedEffectIndex = -1;
                renderList();
                renderTimeline();
            }

            // Zene
            const m = document.getElementById('musicFile');
            let actx, dest, src, hasA = false;
            if (m.files[0]) {
                hasA = true; actx = new (window.AudioContext || window.webkitAudioContext)();
                const b = await m.files[0].arrayBuffer();
                const d = await actx.decodeAudioData(b);
                dest = actx.createMediaStreamDestination();
                src = actx.createBufferSource(); src.buffer = d; src.loop = true; src.connect(dest);
            }

            const cStream = canvas.captureStream(renderFps);
            if (hasA) cStream.addTrack(dest.stream.getAudioTracks()[0]);

            const pick3 = pickRecorderMime(preferredFormat);
            let rec;
            try {
                rec = new MediaRecorder(cStream, { mimeType: pick3.mime, videoBitsPerSecond });
            } catch (e) {
                console.error('[REC] MediaRecorder(captureStream) create failed:', e);
                statusBadge.innerText = 'RENDER HIBA';
                statusBadge.style.color = 'red';
                progressBarContainer.style.display = 'none';
                processText.innerText = 'A b√∂ng√©sz≈ë nem tud canvas streamet r√∂gz√≠teni. Safari-ban ez verzi√≥f√ºgg≈ë. Haszn√°lj Chrome-ot a biztos m≈±k√∂d√©shez.';
                resetUI();
                if (actx) actx.close();
                return;
            }
            const fChunks = [];
            rec.ondataavailable = e => { if (e.data.size > 0) fChunks.push(e.data) };
            rec.onstop = () => {
                const pick4 = pickRecorderMime(preferredFormat);
                const outBlob = new Blob(fChunks, { type: pick4.mime });
                const url = URL.createObjectURL(outBlob);
                const thumb = buildProjectorThumb();

                // Mutassuk meg az oldalon is (mert a macOS sokszor nem nyitja meg a .webm-et)
                setLastOutput(url, pick4.mime, pick4.ext, outBlob.size);

                // Azonnali let√∂lt√©s (marad, de m√°r a v√°lasztott kiterjeszt√©ssel)
                const a = document.createElement('a');
                const now = new Date();
                a.href = url;
                a.download = `360_Video_${now.getHours()}${now.getMinutes()}${now.getSeconds()}.${pick4.ext}`;
                a.click();

                sendToProjector(url, thumb);
                resetUI();
                if (actx) actx.close();
            };

            rec.start();
            if (hasA) src.start(0);

            await seekToTime(rawPlayback, trimStartSec);
            const playOk = await safePlay(rawPlayback, 2000);
            if (!playOk) {
                statusBadge.innerText = 'LEJ√ÅTSZ√ÅS HIBA';
                statusBadge.style.color = 'red';
                processText.innerText = 'A b√∂ng√©sz≈ë nem engedte a lej√°tsz√°st (autoplay).';
                progressBarContainer.style.display = 'none';
                resetUI();
                if (actx) actx.close();
                return;
            }
            await waitForFirstFrame(rawPlayback, 2000);
            const boomerang = !!document.getElementById('boomerangMode')?.checked;
            const pingPong = !!document.getElementById('pingPongMode')?.checked;
            let plan = effects.length > 0 ? effects : [{ duration: 1, speed: 1 }];
            if (boomerang && !pingPong) plan = [...plan, ...plan];
            const reversePlan = pingPong ? [...plan].slice().reverse() : [];

            let totalSec = 0; plan.forEach(p => totalSec += p.duration);
            reversePlan.forEach(p => totalSec += p.duration);
            let processedSec = 0;

            function updateProgress(sec) {
                const p = totalSec > 0 ? Math.min((sec / totalSec) * 100, 100) : 0;
                progressBar.style.width = p + "%";
                processText.innerText = Math.round(p) + "%";
            }

            for (const seg of plan) {
                rawPlayback.playbackRate = seg.speed;
                const s = performance.now();
                const d = seg.duration * 1000;
                const frameMs = renderFps > 0 ? (1000 / renderFps) : 33;
                while (performance.now() - s < d) {
                    drawVideoCoverRotated(ctx, rawPlayback, canvas.width, canvas.height, getEffectiveRotateDeg(rawPlayback));
                    // Overlay: stabilan csak akkor rajzoljuk, ha bet√∂lt√∂tt; tartal√©k naturalWidth alapj√°n
                    drawOverlayToCanvas(ctx, canvas.width, canvas.height);
                    if (isDateOverlayEnabled()) {
                        drawDateStamp(ctx, canvas.width, canvas.height);
                    }

                    const segElapsed = (performance.now() - s) / 1000;
                    updateProgress(processedSec + segElapsed);

                    await new Promise(r => setTimeout(r, frameMs));
                    if (rawPlayback.ended || (endTime > 0 && rawPlayback.currentTime >= endTime - 0.01)) {
                        if (boomerang && !pingPong) {
                            rawPlayback.currentTime = trimStartSec;
                            await rawPlayback.play();
                        } else {
                            try { rawPlayback.pause(); } catch (_) { }
                            try { rawPlayback.currentTime = endTime; } catch (_) { }
                        }
                    }
                }
                processedSec += seg.duration;
                updateProgress(processedSec);
            }

            if (pingPong) {
                rawPlayback.pause();
                const dur = isFinite(rawPlayback.duration) ? rawPlayback.duration : 0;
                const reverseStart = Math.min(dur || 0, trimStartSec + effectiveDuration);
                if (reverseStart > 0) rawPlayback.currentTime = reverseStart;
                for (const seg of reversePlan) {
                    const s = performance.now();
                    const d = seg.duration * 1000;
                    const frameMs = renderFps > 0 ? (1000 / renderFps) : 33;
                    const step = (frameMs / 1000) * (seg.speed || 1);
                    while (performance.now() - s < d) {
                        drawVideoCoverRotated(ctx, rawPlayback, canvas.width, canvas.height, getEffectiveRotateDeg(rawPlayback));
                        drawOverlayToCanvas(ctx, canvas.width, canvas.height);
                        if (isDateOverlayEnabled()) {
                            drawDateStamp(ctx, canvas.width, canvas.height);
                        }

                        const segElapsed = (performance.now() - s) / 1000;
                        updateProgress(processedSec + segElapsed);

                        rawPlayback.currentTime = Math.max(trimStartSec, rawPlayback.currentTime - step);
                        await new Promise(r => setTimeout(r, frameMs));
                        if (rawPlayback.currentTime <= trimStartSec + 0.01) {
                            try { rawPlayback.pause(); } catch (_) { }
                            try { rawPlayback.currentTime = trimStartSec; } catch (_) { }
                        }
                    }
                    processedSec += seg.duration;
                    updateProgress(processedSec);
                }
            }
            rec.stop();
            rawPlayback.pause();
        }

        function resetUI() {
            isProcessing = false;
            isRecording = false;
            if (pendingStartTimer) { clearTimeout(pendingStartTimer); pendingStartTimer = 0; }
            if (autoStopTimer) { clearTimeout(autoStopTimer); autoStopTimer = 0; }
            progressBarContainer.style.display = 'none'; progressBar.style.width = "0%"; processText.innerText = "";
            const startBtn = document.getElementById('startBtn');
            if (startBtn) {
                startBtn.disabled = false;
                startBtn.textContent = 'FELV√âTEL START';
            }
            statusBadge.innerText = "K√âSZENL√âT"; statusBadge.style.color = "#03dac6";
            if (currentMode === 'cam') {
                // Kamer√°n az el≈ën√©zet maradjon a canvas-on
                liveVideo.style.display = 'none';
                canvas.style.display = 'block';
                syncPreviewCanvasToMode(liveVideo);
                drawLivePreviewLoop();
            }
            else { canvas.style.display = 'block'; } // F√°jl m√≥dban maradjon a canvas a legutols√≥ k√©ppel

            // A kimenet doboz maradhat l√°that√≥ a v√©g√©n, de felv√©telkor/feldolgoz√°skor elrejtj√ºk.
            updateDateOverlayPreview();
            applyEncoderPreference();
        }

        // === WEBCODECS INITIALIZATION ===
        async function detectWebCodecsSupport(forceHw) {
            if (!('VideoEncoder' in window) || !('VideoDecoder' in window)) {
                useWebCodecs = false;
                console.log('[WebCodecs] Not supported - using MediaRecorder fallback');
                setEncoderBadge(forceHw ? 'HW UNAVAILABLE' : 'SW CPU', 'cpu');
                autoPreferMp4OnAndroid();
                return;
            }

            if (typeof Mp4Muxer === 'undefined') {
                useWebCodecs = false;
                console.log('[WebCodecs] MP4 muxer not loaded - using MediaRecorder fallback');
                setEncoderBadge(forceHw ? 'HW UNAVAILABLE' : 'SW CPU', 'cpu');
                autoPreferMp4OnAndroid();
                return;
            }
            if (!forceHw && isAndroidDevice() && getSupportedMp4Mime()) {
                useWebCodecs = false;
                console.log('[WebCodecs] Android prefers MediaRecorder H.264');
                setEncoderBadge('MR READY', 'gpu');
                autoPreferMp4OnAndroid();
                return;
            }

            // Test H.264 encoding support
            try {
                const config = {
                    codec: 'avc1.42001E', // H.264 Baseline
                    width: 1280,
                    height: 720,
                    bitrate: 2000000,
                    framerate: 30,
                    hardwareAcceleration: 'prefer-hardware',
                    latencyMode: 'realtime'
                };

                const support = await VideoEncoder.isConfigSupported(config);
                if (support.supported) {
                    console.log('[WebCodecs] ‚úÖ H.264 encoding SUPPORTED');
                } else {
                    console.log('[WebCodecs] H.264 baseline test failed, trying anyway.');
                }
                useWebCodecs = true;
                setEncoderBadge('HW READY', 'gpu');
            } catch (e) {
                console.error('[WebCodecs] Detection error, trying anyway:', e);
                useWebCodecs = true;
                setEncoderBadge('HW READY', 'gpu');
            }
            autoPreferMp4OnAndroid();
        }

        // WebCodecs Recorder Class with MP4 Muxer
        class WebCodecsRecorder {
            constructor(stream, options = {}) {
                this.stream = stream;
                this.videoTrack = stream.getVideoTracks()[0];
                this.options = options;
                this.encoder = null;
                this.muxer = null;
                this.frameCounter = 0;
                this.startTime = 0;
                this.reader = null;
                this.isRecording = false;
                this.keyFrameIntervalFrames = 0;
            }

            async start() {
                const settings = this.videoTrack.getSettings();
                const width = settings.width || 1280;
                const height = settings.height || 720;
                const framerate = settings.frameRate || 30;
                const refBaseBitrate = Math.max(this.options.videoBitsPerSecond || 8000000, 12000000);
                const refPixelsPerSec = 1920 * 1080 * 30;
                const scale = (width * height * framerate) / refPixelsPerSec;
                const minBitrate = 8000000;
                const maxBitrate = 120000000;
                const bitrate = Math.min(maxBitrate, Math.max(minBitrate, Math.round(refBaseBitrate * Math.max(1, scale))));
                this.keyFrameIntervalFrames = Math.max(1, Math.round(framerate * 2));

                this.frameCounter = 0;
                this.startTime = performance.now();
                this.isRecording = true;

                // Initialize MP4 Muxer
                this.muxer = new Mp4Muxer.Muxer({
                    target: new Mp4Muxer.ArrayBufferTarget(),
                    video: {
                        codec: 'avc',
                        width,
                        height
                    },
                    fastStart: 'in-memory'
                });

                // Configure encoder for hardware acceleration
                const baseCandidates = (width * height >= 3840 * 2160)
                    ? ['avc1.640033', 'avc1.640032', 'avc1.64002A', 'avc1.640029', 'avc1.4D402A', 'avc1.4D4029', 'avc1.42E02A', 'avc1.42E01F', 'avc1.42E01E', 'avc1.42001E']
                    : (width * height >= 1920 * 1080)
                        ? ['avc1.64002A', 'avc1.4D402A', 'avc1.640029', 'avc1.4D4029', 'avc1.42E01F', 'avc1.42E01E', 'avc1.42001E']
                        : ['avc1.42E01F', 'avc1.42E01E', 'avc1.42001E'];
                const androidPreferred = ['avc1.42001E', 'avc1.42E01E', 'avc1.42E01F'];
                const codecCandidates = isAndroidDevice()
                    ? [...androidPreferred, ...baseCandidates.filter((c) => !androidPreferred.includes(c))]
                    : baseCandidates;
                const baseConfig = {
                    width,
                    height,
                    bitrate,
                    framerate
                };
                const configVariants = [
                    { ...baseConfig, bitrateMode: 'variable', latencyMode: 'quality' },
                    { ...baseConfig, latencyMode: 'quality' },
                    { ...baseConfig, bitrateMode: 'variable' },
                    { ...baseConfig }
                ];
                const accelVariants = ['prefer-hardware', 'no-preference'];
                let chosen = null;
                for (const accel of accelVariants) {
                    for (const codec of codecCandidates) {
                        for (const variant of configVariants) {
                            const cfg = { ...variant, codec, hardwareAcceleration: accel };
                            const support = await VideoEncoder.isConfigSupported(cfg);
                            if (support && support.supported) {
                                chosen = support.config || cfg;
                                break;
                            }
                        }
                        if (chosen) break;
                    }
                    if (chosen) break;
                }
                if (!chosen) {
                    throw new Error('No supported H.264 encoder config for current resolution.');
                }
                this.chosenConfig = chosen;

                this.encoder = new VideoEncoder({
                    output: (chunk, metadata) => {
                        // Send encoded chunk to muxer
                        this.muxer.addVideoChunk(chunk, metadata);
                    },
                    error: (e) => {
                        console.error('[WebCodecs] Encode error:', e);
                    }
                });

                this.encoder.configure(chosen);

                // Check if MediaStreamTrackProcessor is available (Chrome only)
                if (typeof MediaStreamTrackProcessor !== 'undefined') {
                    // Chrome method - direct frame access
                    const processor = new MediaStreamTrackProcessor({ track: this.videoTrack });
                    this.reader = processor.readable.getReader();
                    this.processFrames();
                } else {
                    // Safari fallback - use canvas to capture frames
                    this.captureFramesWithCanvas(width, height, framerate);
                }
            }

            async processFrames() {
                try {
                    while (this.isRecording) {
                        const { done, value: frame } = await this.reader.read();
                        if (done) break;

                        if (frame && this.encoder.state === 'configured') {
                            const keyFrame = this.frameCounter % this.keyFrameIntervalFrames === 0;
                            this.encoder.encode(frame, { keyFrame });
                            this.frameCounter++;
                        }

                        frame?.close();
                    }
                } catch (e) {
                    console.error('[WebCodecs] Frame processing error:', e);
                }
            }

            captureFramesWithCanvas(width, height, framerate) {
                // Safari method - canvas-based frame capture
                const video = document.createElement('video');
                video.srcObject = this.stream;
                video.autoplay = true;
                video.muted = true;
                video.playsInline = true;

                const canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                const ctx = canvas.getContext('2d');

                const frameInterval = 1000 / framerate;
                let lastFrameTime = 0;

                const captureFrame = async (timestamp) => {
                    if (!this.isRecording) return;

                    const elapsed = timestamp - lastFrameTime;
                    if (elapsed >= frameInterval) {
                        lastFrameTime = timestamp;

                        try {
                            // Draw video frame to canvas
                            ctx.drawImage(video, 0, 0, width, height);

                            // Create VideoFrame from canvas (Safari-compatible method)
                            const frame = new VideoFrame(canvas, {
                                timestamp: this.frameCounter * (1_000_000 / framerate),
                                duration: 1_000_000 / framerate
                            });

                            if (this.encoder.state === 'configured') {
                            const keyFrame = this.frameCounter % this.keyFrameIntervalFrames === 0;
                                this.encoder.encode(frame, { keyFrame });
                                this.frameCounter++;
                            }

                            frame.close();
                        } catch (e) {
                            console.error('[WebCodecs] Frame capture error:', e);
                        }
                    }

                    if (this.isRecording) {
                        requestAnimationFrame(captureFrame);
                    }
                };

                video.addEventListener('loadedmetadata', () => {
                    requestAnimationFrame(captureFrame);
                });
            }

            async stop() {
                this.isRecording = false;

                if (this.reader) {
                    try {
                        await this.reader.cancel();
                    } catch (e) {
                        console.error('[WebCodecs] Reader cancel error:', e);
                    }
                    this.reader = null;
                }

                if (this.encoder && this.encoder.state === 'configured') {
                    try {
                        await this.encoder.flush();
                        this.encoder.close();
                    } catch (e) {
                        console.error('[WebCodecs] Encoder flush/close error:', e);
                    }
                }

                // Finalize muxer and create MP4 blob
                if (this.muxer) {
                    this.muxer.finalize();
                    const { buffer } = this.muxer.target;
                    console.log(`[WebCodecs] Created MP4 file: ${(buffer.byteLength / 1024 / 1024).toFixed(2)} MB`);
                    return new Blob([buffer], { type: 'video/mp4' });
                }

                console.warn('[WebCodecs] No muxer available');
                return new Blob([], { type: 'video/mp4' });
            }
        }

        // Kamer√°k bet√∂lt√©se csak user gesture ut√°n (pl. m√≥dv√°lt√°s / gombnyom√°s), k√ºl√∂nben a b√∂ng√©sz≈ë blokkolhatja.
        applyEncoderPreference(); // Encoder init (HW/SW/auto)
        initOrientationUI(); // Mobil: auto orient√°ci√≥, Desktop: manu√°lis v√°laszt√≥
        applyOutputAspectFromUI();
        applyOverlayFitFromUI();
        applyStartDelayFromUI();
        applyAutoStopFromUI();
        applyQualityFromUI();
        applyUseSourceResolutionFromUI();
        applyCameraResolutionFromUI();
        applyCameraFpsFromUI();
        applyPreviewFpsFromUI();
        applyFormatFromUI();
        applySignalSourceFromUI();
        applySourceCropFromUI();
        applySourceRotateFromUI();
        applyLastOutputAspectFromMode();
        syncLastOutputWidth();

        // Initialize mobile button sync
        setTimeout(syncMobileButton, 100);
        function updateUiScale() {
            document.documentElement.style.setProperty('--ui-scale', '1');
        }

        function handleOrientationOrResize() {
            updateUiScale();
            if (isAutoOrientationEnabled) {
                updateOrientationFromViewport();
            }
            applyPreviewAspect();
            if (currentMode === 'cam') {
                syncPreviewCanvasToMode(liveVideo);
            }
            requestAnimationFrame(() => applyLiveVideoTransform());
            setTimeout(applyLiveVideoTransform, 0);
            setTimeout(applyLiveVideoTransform, 50);
            syncLastOutputWidth();
            updateDateOverlayPreview();
        }

        window.addEventListener('resize', handleOrientationOrResize);
        window.addEventListener('orientationchange', () => {
            // Kis k√©sleltet√©s, hogy a viewport stabiliz√°l√≥djon
            setTimeout(handleOrientationOrResize, 100);
            setTimeout(handleOrientationOrResize, 300);
        });
        renderList();

        if (signalInfoTimer) clearInterval(signalInfoTimer);
        signalInfoTimer = setInterval(() => updateSignalInfo(false), 500);
        updateSignalInfo(true);

        // Effektek fel√ºlet inicializ√°l√°s + √©l≈ë friss√≠t√©s
        (function initEffectsUI() {
            const tS = document.getElementById('effTimeSlider');
            const sS = document.getElementById('effSpeedSlider');
            if (tS) tS.addEventListener('input', updateEffectUI);
            if (sS) sS.addEventListener('input', updateEffectUI);
            updateEffectUI();
            renderTimeline();
        })();

        (function initAutoRampUI() {
            const chk = document.getElementById('autoRampMode');
            const presetButtons = document.querySelectorAll('[data-ramp-preset]');
            if (chk) {
                chk.addEventListener('change', () => {
                    autoRampUserTouched = true;
                    setAutoRampEnabled(!!chk.checked);
                    if (autoRampEnabled) applyAutoRampFromDuration();
                });
            }
            presetButtons.forEach((btn) => {
                btn.addEventListener('click', () => {
                    autoRampUserTouched = true;
                    const key = btn.getAttribute('data-ramp-preset');
                    setRampPreset(key);
                });
            });
            setAutoRampEnabled(false);
            if (chk) chk.checked = false;
        })();

        (function initDateOverlayUI() {
            const chk = document.getElementById('dateOverlay');
            if (chk) chk.addEventListener('change', updateDateOverlayPreview);
            updateDateOverlayPreview();
            setInterval(updateDateOverlayPreview, 60 * 1000);
        })();

        (function initPlaybackModeUI() {
            const boomerang = document.getElementById('boomerangMode');
            const pingpong = document.getElementById('pingPongMode');
            if (!boomerang || !pingpong) return;
            boomerang.addEventListener('change', () => {
                if (boomerang.checked) pingpong.checked = false;
            });
            pingpong.addEventListener('change', () => {
                if (pingpong.checked) boomerang.checked = false;
            });
        })();

        window.addEventListener('beforeunload', () => {
            stopLivePreviewLoop();
            if (signalInfoTimer) {
                clearInterval(signalInfoTimer);
                signalInfoTimer = 0;
            }
            try { if (stream) stream.getTracks().forEach(t => t.stop()); } catch (_) { }
        });

        window.addEventListener('pageshow', () => {
            if (autoRampUserTouched) return;
            const chk = document.getElementById('autoRampMode');
            if (chk) {
                chk.checked = false;
                setAutoRampEnabled(false);
            }
        });

        // updateUiScale √©s event listener inicializ√°l√°s m√°r kor√°bban megt√∂rt√©nt
        updateUiScale();

        // === MOBILE START BUTTON ===
        function handleMobileStart() {
            // Sync with desktop button - use the same function
            const desktopBtn = document.getElementById('startBtn');
            if (desktopBtn) {
                desktopBtn.click();
                // Force sync after click with delay to catch state change
                setTimeout(syncMobileButton, 100);
            }
        }

        // Sync mobile button state with desktop button
        function syncMobileButton() {
            const desktopBtn = document.getElementById('startBtn');
            const mobileBtn = document.getElementById('mobileStartBtn');
            if (desktopBtn && mobileBtn) {
                mobileBtn.disabled = desktopBtn.disabled;
                const btnText = desktopBtn.textContent || '';
                const isRec = btnText.includes('STOP');

                if (isRec) {
                    mobileBtn.classList.add('recording');
                } else {
                    mobileBtn.classList.remove('recording');
                }
            }
        }

        // Watch for changes to desktop button
        const desktopBtnObserver = new MutationObserver(() => {
            syncMobileButton();
        });
        const desktopStartBtn = document.getElementById('startBtn');
        if (desktopStartBtn) {
            desktopBtnObserver.observe(desktopStartBtn, {
                childList: true,
                characterData: true,
                subtree: true,
                attributes: true,
                attributeFilter: ['disabled']
            });
        }

        // Fallback: watch for global isRecording changes
        setInterval(() => {
            const mobileBtn = document.getElementById('mobileStartBtn');
            if (mobileBtn && typeof isRecording !== 'undefined') {
                if (isRecording && !mobileBtn.classList.contains('recording')) {
                    mobileBtn.classList.add('recording');
                } else if (!isRecording && mobileBtn.classList.contains('recording')) {
                    mobileBtn.classList.remove('recording');
                }
            }
        }, 500);

        // === HAMBURGER MENU ===
        const menuPanelState = {
            left: null,
            right: null,
            leftParent: null,
            rightParent: null,
            leftNext: null,
            rightNext: null
        };

        function initMenuPanels() {
            if (menuPanelState.left && menuPanelState.right) return;
            const left = document.getElementById('leftPanel') || document.querySelector('.left-panel');
            const right = document.getElementById('rightPanel') || document.querySelector('.right-panel');
            if (!left || !right) return;
            menuPanelState.left = left;
            menuPanelState.right = right;
            menuPanelState.leftParent = left.parentNode;
            menuPanelState.rightParent = right.parentNode;
            menuPanelState.leftNext = left.nextSibling;
            menuPanelState.rightNext = right.nextSibling;
        }

        function movePanelsToMenu() {
            const content = document.getElementById('menuContent');
            if (!content) return;
            content.innerHTML = '';
            initMenuPanels();
            if (!menuPanelState.left || !menuPanelState.right) return;
            menuPanelState.left.classList.remove('left-panel');
            menuPanelState.right.classList.remove('right-panel');
            menuPanelState.left.classList.add('menu-panel');
            menuPanelState.right.classList.add('menu-panel');
            content.appendChild(menuPanelState.left);
            content.appendChild(menuPanelState.right);
        }

        function restorePanelsFromMenu() {
            if (!menuPanelState.left || !menuPanelState.right) return;
            menuPanelState.left.classList.remove('menu-panel');
            menuPanelState.right.classList.remove('menu-panel');
            menuPanelState.left.classList.add('left-panel');
            menuPanelState.right.classList.add('right-panel');
            const leftParent = menuPanelState.leftParent || document.querySelector('.container');
            const rightParent = menuPanelState.rightParent || document.querySelector('.container');
            if (leftParent) {
                leftParent.insertBefore(menuPanelState.left, menuPanelState.leftNext);
            }
            if (rightParent) {
                if (menuPanelState.rightNext) {
                    rightParent.insertBefore(menuPanelState.right, menuPanelState.rightNext);
                } else {
                    rightParent.appendChild(menuPanelState.right);
                }
            }
        }

        function toggleMenu() {
            const drawer = document.getElementById('menuDrawer');
            const isOpen = drawer.classList.contains('open');

            if (!isOpen) {
                movePanelsToMenu();
                document.body.classList.add('menu-open');
            } else {
                restorePanelsFromMenu();
                document.body.classList.remove('menu-open');
            }

            drawer.classList.toggle('open');
        }

        function rebindMenuEvents() {
            // Re-attach all onchange/oninput events for cloned elements
            const menuContent = document.getElementById('menuContent');

            // Brand title
            const brandInput = menuContent.querySelector('#brandTitleInput');
            if (brandInput) brandInput.oninput = updateBranding;

            // Logo
            const logoInput = menuContent.querySelector('#logoInput');
            if (logoInput) logoInput.onchange = updateLogo;

            // Overlay file
            const overlayInput = menuContent.querySelector('#overlayFile');
            if (overlayInput) overlayInput.onchange = function() { loadOverlay(this); };

            // Clear overlay button
            const clearBtn = menuContent.querySelector('.btn-clear');
            if (clearBtn) clearBtn.onclick = clearOverlay;

            // Date overlay checkbox
            const dateCheck = menuContent.querySelector('#dateOverlay');
            if (dateCheck) dateCheck.onchange = updateDateOverlayPreview;

            // Date position
            const datePos = menuContent.querySelector('#dateOverlayPos');
            if (datePos) datePos.onchange = updateDateOverlayPreview;

            // Date offsets
            const offsetX = menuContent.querySelector('#dateOverlayOffsetX');
            if (offsetX) offsetX.oninput = updateDateOverlayPreview;

            const offsetY = menuContent.querySelector('#dateOverlayOffsetY');
            if (offsetY) offsetY.oninput = updateDateOverlayPreview;

            // Mode buttons
            const btnCam = menuContent.querySelector('#btnModeCam');
            if (btnCam) btnCam.onclick = () => setMode('cam');

            const btnFile = menuContent.querySelector('#btnModeFile');
            if (btnFile) btnFile.onclick = () => setMode('file');

            // Camera select
            const camSelect = menuContent.querySelector('#camSelect');
            if (camSelect) camSelect.onchange = startCamera;

            // Output aspect (if exists)
            const outputAspect = menuContent.querySelector('#outputAspect');
            if (outputAspect) outputAspect.onchange = applyOutputAspectFromUI;

            // Overlay fit
            const overlayFit = menuContent.querySelector('#overlayFit');
            if (overlayFit) overlayFit.onchange = applyPreviewAspect;

            // Projector button
            const projBtn = menuContent.querySelector('.btn-projector');
            if (projBtn) projBtn.onclick = openProjectorWindow;

            // All other buttons and inputs - generic re-binding
            menuContent.querySelectorAll('button, input, select').forEach(el => {
                const onclick = el.getAttribute('onclick');
                const onchange = el.getAttribute('onchange');
                const oninput = el.getAttribute('oninput');

                if (onclick) {
                    el.onclick = function() { eval(onclick); };
                }
                if (onchange) {
                    el.onchange = function() { eval(onchange); };
                }
                if (oninput) {
                    el.oninput = function() { eval(oninput); };
                }
            });
        }
    </script>
</body>

</html>
